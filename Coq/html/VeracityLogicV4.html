<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Veracity Logic Mechanised in Coq V3</title>
<script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js?config=TeX-AMS_CHTML"></script>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="veracity-logic-mechanised-in-coq-v3">
<h1 class="title">Veracity Logic Mechanised in Coq V3</h1>

<p>This version aims to more closely align with the draft paper.
It also features a LaTeX/MathJax visualisation of completed proofs.</p>
<p>This is possible due to not using <code class="highlight coq"><span class="kt">Prop</span></code> at all. &quot;<em>In fact in my logic there are no propositions</em>&quot; - Steve.
Instead, this aims to model the process of constructing proof trees, just like they are done on paper.</p>
<p>A correct proof tree is a datatype with similarities to a tree datatype, which makes it possible to write a function that prints a proof out.</p>
<p>Coq is useful here because we can construct correct proof trees in &quot;proof mode&quot;. In fact, we are just defining particular proof trees, but it is convenient to use &quot;proof mode&quot;.</p>
<p>Lastly, we use Coq's dependent types to enforce that it's not just any proof tree that we build, but it is a correct proof tree for the given judgement.
The type <code class="highlight coq"><span class="n">proofTreeOf</span></code> depends on the value, <code class="highlight coq"><span class="n">j</span></code>, of type <code class="highlight coq"><span class="n">judgement</span></code> which constrains what a <code class="highlight coq"><span class="n">proofTreeOf</span> <span class="n">j</span></code> is.
This is similar to a type such as <code class="highlight coq"><span class="n">vector</span></code> depending on a value, <code class="highlight coq"><span class="n">n</span></code>, (the vector's length) of type <code class="highlight coq"><span class="n">nat</span></code> which constrains what a <code class="highlight coq"><span class="n">vector</span> <span class="n">n</span></code> is.</p>
<p>Handling a trust relation and weights are future work (2024).</p>
<!-- The following is required to get MathJax to process the outputs marked with the class coq-math. -->
<link rel="stylesheet" href="overrides.css">

<script type="text/javascript">
  document.addEventListener("DOMContentLoaded", () => {
     // 1. Find all relevant Alectryon tags
     var spans = document.querySelectorAll(".coq-math > * > * > * > * > * > .s2, .custom-math");

     // 2. Wrap the contents of each in \(\) math delimiters, add mathjax class
     spans.forEach(function (e) {
         e.innerText = '\\[' + e.innerText + '\\]';
         e.classList.add("mathjax_process");
     });

     // 3. If MathJax has already loaded, force reprocessing
     window.MathJax && MathJax.typesetPromise(spans);
  });
</script>

<style type="text/css"> /* Override MathJax margins */
    .coq-math .goal-conclusion > *,
    .coq-math .hyp-body span > *,
    .coq-math .hyp-type span > * {
        margin: 0 !important;
    }
</style><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> String.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Strings.Ascii.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Bool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Program.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">VeracityLogic</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">atomic_evid_name</span> :=
  | _e_
  | _e1_
  | _e2_
  | _e3_
  | _e4_
  | _eB_
  | _eQ_
  | _l_
  | _s_
  | _c_evid_
  | _belief_
  | _testing_
  | _audit_
  | _compile_
  | _review_
  | _assess_
  | _ingredients_percentage_list_
  | _breakdown_of_formulations_list_
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">atomic_evid_name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">actor_name</span> :=
  | _a1_
  | _a2_
  | _a3_
  | _a4_
  | _aQ_
  | _retailer_
  | _vineyard_
  | _winery_
  | _P_
  | _Q_
  | _applicant_
  | _certifier_
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">actor_name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">claim_name</span> :=
  | _c_
  | _c1_
  | _c2_
  | _c3_
  | _c4_
  | _c5_
  | _cQ_
  | _healthy_
  | _nonToxic_
  | _organic_
  | _ingredients_valid_
  | _recipe_valid_
  | _percentage_ingredients_valid_
  | _breakdown_of_formulations_valid_
  | _successful_market_compliance_assessment_
.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">claim_name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">trust_relation_name</span> :=
  | _T_
  | _U_
  | _V_
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">trust_relation_name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ShowForProofTree</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    showForProofTree : A -&gt; string
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree atomic_evid_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _e_ =&gt; <span class="s2">&quot;e&quot;</span>
      | _e1_ =&gt; <span class="s2">&quot;e_{1}&quot;</span>
      | _e2_ =&gt; <span class="s2">&quot;e_{2}&quot;</span>
      | _e3_ =&gt; <span class="s2">&quot;e_{3}&quot;</span>
      | _e4_ =&gt; <span class="s2">&quot;e_{4}&quot;</span>
      | _eB_  =&gt; <span class="s2">&quot;e_{\bot}&quot;</span>
      | _eQ_ =&gt; <span class="s2">&quot;e_{?}&quot;</span>
      | _l_ =&gt; <span class="s2">&quot;l&quot;</span>
      | _s_ =&gt; <span class="s2">&quot;s&quot;</span>
      | _c_evid_ =&gt; <span class="s2">&quot;c&quot;</span>
      | _belief_ =&gt; <span class="s2">&quot;b&quot;</span>
      | _testing_ =&gt; <span class="s2">&quot;t&quot;</span>
      | _audit_ =&gt; <span class="s2">&quot;a&quot;</span>
      | _compile_=&gt; <span class="s2">&quot;c&quot;</span>
      | _review_=&gt; <span class="s2">&quot;r&quot;</span>
      | _assess_ =&gt; <span class="s2">&quot;a&quot;</span>
      | _ingredients_percentage_list_ =&gt; <span class="s2">&quot;e_{PI}&quot;</span>
      | _breakdown_of_formulations_list_=&gt; <span class="s2">&quot;e_{BF}&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree actor_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _a1_ =&gt; <span class="s2">&quot;a_{1}&quot;</span>
      | _a2_ =&gt; <span class="s2">&quot;a_{2}&quot;</span>
      | _a3_ =&gt; <span class="s2">&quot;a_{3}&quot;</span>
      | _a4_ =&gt; <span class="s2">&quot;a_{4}&quot;</span>
      | _aQ_ =&gt; <span class="s2">&quot;a_{?}&quot;</span>
      | _retailer_ =&gt; <span class="s2">&quot;r&quot;</span>
      | _vineyard_ =&gt; <span class="s2">&quot;v&quot;</span>
      | _winery_ =&gt; <span class="s2">&quot;w&quot;</span>
      | _P_ =&gt; <span class="s2">&quot;P&quot;</span>
      | _Q_ =&gt; <span class="s2">&quot;Q&quot;</span>
      | _applicant_ =&gt; <span class="s2">&quot;A&quot;</span>
      | _certifier_ =&gt; <span class="s2">&quot;C&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree claim_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _c_ =&gt; <span class="s2">&quot;C&quot;</span>
      | _c1_ =&gt; <span class="s2">&quot;C_{1}&quot;</span>
      | _c2_ =&gt; <span class="s2">&quot;C_{2}&quot;</span>
      | _c3_ =&gt; <span class="s2">&quot;C_{3}&quot;</span>
      | _c4_ =&gt; <span class="s2">&quot;C_{4}&quot;</span>
      | _c5_ =&gt; <span class="s2">&quot;C_{5}&quot;</span>
      | _cQ_ =&gt; <span class="s2">&quot;C_{?}&quot;</span>
      | _healthy_ =&gt; <span class="s2">&quot;H&quot;</span>
      | _nonToxic_ =&gt; <span class="s2">&quot;N&quot;</span>
      | _organic_ =&gt; <span class="s2">&quot;O&quot;</span>
      | _ingredients_valid_ =&gt; <span class="s2">&quot;IV&quot;</span>
      | _recipe_valid_ =&gt; <span class="s2">&quot;RV&quot;</span>      
      | _percentage_ingredients_valid_ =&gt; <span class="s2">&quot;PIV&quot;</span>
      | _breakdown_of_formulations_valid_ =&gt; <span class="s2">&quot;BFV&quot;</span>
      | _successful_market_compliance_assessment_ =&gt; <span class="s2">&quot;SMCA&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree trust_relation_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _T_ =&gt; <span class="s2">&quot;T&quot;</span>
      | _U_ =&gt; <span class="s2">&quot;U&quot;</span>
      | _V_ =&gt; <span class="s2">&quot;V&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ShowForNaturalLanguage</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    showForNaturalLanguage : A -&gt; string
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ShowForLogSeq</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    showForLogSeq : A -&gt; string
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage atomic_evid_name := { 
  showForNaturalLanguage n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _e_ =&gt; <span class="s2">&quot;atomic evidence e&quot;</span>
      | _e1_ =&gt; <span class="s2">&quot;atomic evidence 1&quot;</span>
      | _e2_ =&gt; <span class="s2">&quot;atomic evidence 2&quot;</span>
      | _e3_ =&gt; <span class="s2">&quot;atomic evidence 3&quot;</span>
      | _e4_ =&gt; <span class="s2">&quot;atomic evidence 4&quot;</span>
      | _eB_ =&gt;  <span class="s2">&quot;evidence for bottom&quot;</span>
      | _eQ_ =&gt;  <span class="s2">&quot;unknown evidence&quot;</span>
      | _l_ =&gt; <span class="s2">&quot;atomic evidence l&quot;</span>
      | _s_ =&gt; <span class="s2">&quot;atomic evidence s&quot;</span>
      | _c_evid_ =&gt; <span class="s2">&quot;atomic evidence c&quot;</span>
      | _belief_ =&gt; <span class="s2">&quot;belief&quot;</span>
      | _testing_ =&gt; <span class="s2">&quot;testing&quot;</span>
      | _audit_ =&gt; <span class="s2">&quot;audit&quot;</span>
      | _compile_=&gt; <span class="s2">&quot;compile&quot;</span>
      | _review_=&gt; <span class="s2">&quot;review&quot;</span>
      | _assess_ =&gt; <span class="s2">&quot;assess&quot;</span>
      | _ingredients_percentage_list_ =&gt; <span class="s2">&quot;ingredients percentage list&quot;</span>
      | _breakdown_of_formulations_list_ =&gt; <span class="s2">&quot;breakdown of formulations list&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq atomic_evid_name := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage actor_name := { 
  showForNaturalLanguage n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _a1_ =&gt; <span class="s2">&quot;actor 1&quot;</span>
      | _a2_ =&gt; <span class="s2">&quot;actor 2&quot;</span>
      | _a3_ =&gt; <span class="s2">&quot;actor 3&quot;</span>
      | _a4_ =&gt; <span class="s2">&quot;actor 4&quot;</span>
      | _aQ_ =&gt; <span class="s2">&quot;unknown actor&quot;</span>
      | _retailer_ =&gt; <span class="s2">&quot;retailer&quot;</span>
      | _vineyard_ =&gt; <span class="s2">&quot;vineyard&quot;</span>
      | _winery_ =&gt; <span class="s2">&quot;winery&quot;</span>
      | _P_ =&gt; <span class="s2">&quot;Penelope&quot;</span>
      | _Q_ =&gt; <span class="s2">&quot;Quintin&quot;</span>
      | _applicant_ =&gt; <span class="s2">&quot;applicant&quot;</span>
      | _certifier_ =&gt; <span class="s2">&quot;certifier&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq actor_name := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage claim_name := { 
  showForNaturalLanguage n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _c_ =&gt; <span class="s2">&quot;claim c&quot;</span>
      | _c1_ =&gt; <span class="s2">&quot;claim 1&quot;</span>
      | _c2_ =&gt; <span class="s2">&quot;claim 2&quot;</span>
      | _c3_ =&gt; <span class="s2">&quot;claim 3&quot;</span>
      | _c4_ =&gt; <span class="s2">&quot;claim 4&quot;</span>
      | _c5_ =&gt; <span class="s2">&quot;claim 5&quot;</span>
      | _cQ_ =&gt; <span class="s2">&quot;unknown claim&quot;</span>
      | _healthy_ =&gt; <span class="s2">&quot;healthy&quot;</span>
      | _nonToxic_ =&gt; <span class="s2">&quot;non-toxic&quot;</span>
      | _organic_ =&gt; <span class="s2">&quot;organic&quot;</span>
      | _ingredients_valid_ =&gt; <span class="s2">&quot;ingredients-valid&quot;</span>
      | _recipe_valid_ =&gt; <span class="s2">&quot;recipe-valid&quot;</span>      
      | _percentage_ingredients_valid_ =&gt; <span class="s2">&quot;percentage-ingredients-valid&quot;</span>
      | _breakdown_of_formulations_valid_ =&gt; <span class="s2">&quot;breakdown-of-formulations-valid&quot;</span>
      | _successful_market_compliance_assessment_ =&gt; <span class="s2">&quot;successful-market-compliance-assessment&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq claim_name := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage trust_relation_name := { 
  showForNaturalLanguage n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _T_ =&gt; <span class="s2">&quot;trust relation T&quot;</span>
      | _U_ =&gt; <span class="s2">&quot;trust relation U&quot;</span>
      | _V_ =&gt; <span class="s2">&quot;trust relation V&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq trust_relation_name := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">evid</span> :=
  | HoleEvid
  | AtomicEvid (n : atomic_evid_name)
  | Pair (e1 e2: evid)
  | Left (e1 : evid)
  | Right (e1 : evid)
  | Lambda (e1 e2: evid)
  | Apply (e1 e2: evid).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">evid</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">actor</span> :=
  | Actor (n : actor_name).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">actor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">claim</span> :=
  | AtomicClaim (n : claim_name)
  | Bottom
  | And (c1 c2 : claim)
  | Or  (c1 c2 : claim)
  | Implies (a : actor) (c1 c2 : claim).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">claim</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">judgementPart</span> :=
  | JudgementPart (a : actor) (c: claim).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">judgementPart</span>.</span></span></pre><p>Judgements are a list of <strong>single</strong> judgements entailing some single judgement, or state that some claim <code class="highlight coq"><span class="n">c</span></code> is a veracity claim.</p>
<p>Next, we introduce some notation for Coq.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;\by A \in C&quot;</span> := (JudgementPart A C) (<span class="kn">at level</span> <span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;/\&#39;&quot;</span> := And (<span class="kn">at level</span> <span class="mi">81</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;\/&#39;&quot;</span> := Or (<span class="kn">at level</span> <span class="mi">86</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;_|_&quot;</span> := (Bottom) (<span class="kn">at level</span> <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{{ x , y , .. , z }}&quot;</span> := (Pair .. (Pair x y) .. z).</span></span></pre><p>We define a tagged type representing a trust relation.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">trustRelation</span> :=
  | Trust (n : trust_relation_name).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">trustRelation</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">judgement</span> :=
  Judgement (e : evid) (jp : judgementPart).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">judgement</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Beq</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    beq : A -&gt; A -&gt; bool
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk0"><span class="kn">Infix</span> <span class="s2">&quot;=?&quot;</span> := beq : beq_scope.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Declaring a scope implicitly <span class="kr">is</span> deprecated; use <span class="kr">in</span>
advance an explicit <span class="s2">&quot;Declare Scope beq_scope.&quot;</span>.
[undeclared-scope,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq atomic_evid_name := { beq := atomic_evid_name_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq actor_name := { beq := actor_name_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq claim_name := { beq := claim_name_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq trust_relation_name := { beq := trust_relation_name_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq evid := { beq := evid_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq claim := { beq := claim_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq actor := { beq := actor_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq judgementPart := { beq := judgementPart_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq trustRelation := { beq := trustRelation_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq judgement := { beq := judgement_beq }.</span></span></pre><p>For now, I have only implemented one inference rule, <code class="highlight coq"><span class="n">and_intro</span></code>, as well as the <code class="highlight coq"><span class="n">assume</span></code> rule and a rule <code class="highlight coq"><span class="n">leaf</span></code> that declares that it is correct for a proof tree to stop on a statement such as <span class="math">\(C_1 \textit{ is a claim}\)</span>.</p>
<p><code class="highlight coq"><span class="n">proofTreeOf</span></code> is a data type, a tree, which depends on a judgement. The type <code class="highlight coq"><span class="n">tree</span> <span class="n">j</span></code> describes a tree which correctly proves <code class="highlight coq"><span class="n">j</span></code>.</p>
<p>But this is not a proposition. This is best thought of as the datatype for (correct) proof trees.</p>
<p>The remaining rules will be easy to add, this will be done in 2024.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">proofTreeOf</span> : judgementPart -&gt; <span class="kt">Type</span> :=
| hole j : proofTreeOf j
| assume (e : evid) a (c : claim) : proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> c)
| bot_elim a C

        (M : proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> _|_))
                           :
           proofTreeOf ((\<span class="bp">by</span> a \<span class="kr">in</span> C))

| and_intro a C1 C2

(L: proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> C1))
                           (R: proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> C2))
                        :
    proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2))

| and_elim1 a C1 C2

    (M : proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2)))
                           :
             proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> C1)

| and_elim2 a C1 C2

    (M : proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2)))
                          :
        proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> C2)

| or_intro1 a C1 C2

           (M: proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> C1))
                          :
    proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2))

| or_intro2 a C1 C2

           (M: proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> C2))
                          :
    proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2))

| or_elim1 a C1 C2

      (M: proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2)))
                          :
        proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> C1)

| or_elim2 a C1 C2

      (M : proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2)))
                            :
          proofTreeOf (\<span class="bp">by</span> a \<span class="kr">in</span> C2)

| trust a1 a2 C (name : trustRelation)

(L: proofTreeOf (\<span class="bp">by</span> a2 \<span class="kr">in</span> C))
                          :
            proofTreeOf (\<span class="bp">by</span> a1 \<span class="kr">in</span> C)

| impl_intro (e1 : evid) (C1 : claim) a1 a2 C2

         (M: proofTreeOf (\<span class="bp">by</span> a2 \<span class="kr">in</span> C2))
                              :
   proofTreeOf (\<span class="bp">by</span> a2 \<span class="kr">in</span> (Implies a1 C1 C2))

| impl_elim a1 a2 C1 C2

(L: proofTreeOf (\<span class="bp">by</span> a2 \<span class="kr">in</span> (Implies a1 C1 C2)))
                           (R: proofTreeOf (\<span class="bp">by</span> a1 \<span class="kr">in</span> C1))
                        :
    proofTreeOf (\<span class="bp">by</span> a2 \<span class="kr">in</span> C2)
.</span></span></pre><p>This is the <code class="highlight coq"><span class="n">and_intro</span></code> rule as Coq sees it:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk1"><span class="kn">Check</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">and_intro
     : <span class="kr">forall</span> (<span class="nv">a</span> : actor) (<span class="nv">C1</span> <span class="nv">C2</span> : claim),
       proofTreeOf \<span class="bp">by</span> a \<span class="kr">in</span> C1 -&gt;
       proofTreeOf \<span class="bp">by</span> a \<span class="kr">in</span> C2 -&gt;
       proofTreeOf \<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">computeEvidence</span> (<span class="nv">j</span> : judgementPart) (<span class="nv">p</span> : proofTreeOf j) : evid := 
<span class="kr">match</span> p <span class="kr">with</span>
| hole _ =&gt; HoleEvid
| assume e a c =&gt; e
| bot_elim a C M =&gt; computeEvidence _ M
| and_intro a C1 C2 L R =&gt; {{computeEvidence _ L,computeEvidence _ R}}
| and_elim1 a C1 C2 M =&gt; <span class="kr">match</span> computeEvidence _ M <span class="kr">with</span>
                          | {{e1,e2}} =&gt; e1
                          | e =&gt; e
                          <span class="kr">end</span>
| and_elim2 a C1 C2 M =&gt; <span class="kr">match</span> computeEvidence _ M <span class="kr">with</span>
                          | {{e1,e2}} =&gt; e2
                          | e =&gt; e
                          <span class="kr">end</span>
| or_intro1 a C1 C2 M =&gt; Left (computeEvidence _ M)
| or_intro2 a C1 C2 M =&gt; Right (computeEvidence _ M)
| or_elim1 a C1 C2 M =&gt; <span class="kr">match</span> computeEvidence _ M <span class="kr">with</span>
                          | (Left e1) =&gt; e1
                          | e =&gt; e
                          <span class="kr">end</span>
| or_elim2 a C1 C2 M =&gt; <span class="kr">match</span> computeEvidence _ M <span class="kr">with</span>
                          | (Right e2) =&gt; e2
                          | e =&gt; e
                          <span class="kr">end</span>
| trust a1 a2 C name L =&gt; computeEvidence _ L
| impl_intro e1 C1 a1 a2 C2 M =&gt; Lambda e1 (computeEvidence _ M)
| impl_elim a1 a2 C1 C2 L R =&gt; Apply (computeEvidence _ L) (computeEvidence _ R)
<span class="kr">end</span>.</span></span></pre><!-- For some reason, math:: directives cause prooftree to crash. The following is an alternative that works. -->
<p>Here is a <em>manual</em> translation of the above rule into Latex.</p>
<pre class="code custom-math literal-block">
\begin{prooftree}
\AxiomC{$Ps \vdash e_1^a \in C_1 \quad Ps \vdash e_2^a \in C_2$}
\RightLabel{ $and\_intro$}
\UnaryInfC{$Ps ++ Qs \vdash (e_1, e_2)^a \in (C_1 \wedge C_2)$}
\end{prooftree}
</pre>
<div class="section" id="example-actors-evidence-claims-and-judgements">
<h1>Example actors, evidence, claims and judgements</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e</span> := AtomicEvid _e_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C</span> := AtomicClaim _c_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a1</span> := Actor _a1_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e1</span> := AtomicEvid _e1_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c1</span> := AtomicClaim _c1_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a2</span> := Actor  _a2_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e2</span> := AtomicEvid _e2_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c2</span> := AtomicClaim _c2_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a3</span> := Actor _a3_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e3</span> := AtomicEvid _e3_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c3</span> := AtomicClaim _c3_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a4</span> := Actor _a4_ .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e4</span> := AtomicEvid  _e4_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c4</span> := AtomicClaim _c4_.</span></span></pre><p>We can also assume arbitrary evidence/claims exist. This currently doesn't work well with printing to Latex. An experimental alternative is demonstrated in the experimental-NamedC-and-NamedE branch.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">e4</span> : evid).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">c4</span> : claim).</span></span></pre><p>Example Single judgements:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sj1</span> := \<span class="bp">by</span> a1 \<span class="kr">in</span> c1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sj3</span> := \<span class="bp">by</span> a3 \<span class="kr">in</span> c3.</span></span></pre><p>Example Judgments:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">j1</span> :=\<span class="bp">by</span> a2 \<span class="kr">in</span> c2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">j2</span> :=\<span class="bp">by</span> a4 \<span class="kr">in</span> c4.</span></span></pre><p>Example use of notation:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk2"><span class="kn">Check</span>\<span class="bp">by</span> a1 \<span class="kr">in</span> c1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">\<span class="bp">by</span> a1 \<span class="kr">in</span> c1
     : judgementPart</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk3"><span class="kn">Check</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">\<span class="bp">by</span> a1 \<span class="kr">in</span> c1
     : judgementPart</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk4"><span class="kn">Check</span>\<span class="bp">by</span> a1 \<span class="kr">in</span> c1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">\<span class="bp">by</span> a1 \<span class="kr">in</span> c1
     : judgementPart</blockquote></div></div></small></span></pre><p>For each datatype defined earlier, we define a string representation of it.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree evid := {
  showForProofTree :=
  <span class="kr">fix</span> showForProofTreeEvid e :=
      <span class="kr">match</span> e <span class="kr">with</span>
      | AtomicEvid name =&gt; showForProofTree name
      | HoleEvid =&gt; <span class="s2">&quot;\textcolor{red}{e_{?}}&quot;</span>
      | Pair e1 e2 =&gt; <span class="s2">&quot;(&quot;</span> ++ (showForProofTreeEvid e1) ++ <span class="s2">&quot;, &quot;</span>
                          ++ (showForProofTreeEvid e2) ++ <span class="s2">&quot;)&quot;</span>
      | Left e =&gt; <span class="s2">&quot;i(&quot;</span> ++ showForProofTreeEvid e ++ <span class="s2">&quot;)&quot;</span>
      | Right e =&gt; <span class="s2">&quot;j(&quot;</span> ++ showForProofTreeEvid e ++ <span class="s2">&quot;)&quot;</span>
      | Lambda e1 e2 =&gt; <span class="s2">&quot;\lambda (&quot;</span> ++ showForProofTreeEvid e1 ++ <span class="s2">&quot;)(&quot;</span>
                          ++ showForProofTreeEvid e2 ++ <span class="s2">&quot;)&quot;</span>
      | Apply e1 e2 =&gt; showForProofTreeEvid e1 ++ <span class="s2">&quot;(&quot;</span> ++ showForProofTreeEvid e2 ++ <span class="s2">&quot;)&quot;</span>
    <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage evid := { showForNaturalLanguage := showForProofTree }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq evid := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree actor := {
  showForProofTree a :=
  <span class="kr">match</span> a <span class="kr">with</span>
    | Actor name =&gt; showForProofTree name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage actor := {
  showForNaturalLanguage a :=
  <span class="kr">match</span> a <span class="kr">with</span>
    | Actor name =&gt; showForNaturalLanguage name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq actor := {
  showForLogSeq a :=
  <span class="kr">match</span> a <span class="kr">with</span>
    | Actor name =&gt; showForLogSeq name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree claim := {
  showForProofTree :=
  <span class="kr">fix</span> showForProofTreeClaim c :=
    <span class="kr">match</span> c <span class="kr">with</span>
      | AtomicClaim name =&gt; showForProofTree name
      | Bottom =&gt; <span class="s2">&quot;\bot&quot;</span>
      | And c1 c2 =&gt; showForProofTreeClaim c1 ++ <span class="s2">&quot; \wedge &quot;</span> ++ showForProofTreeClaim c2
      | Or c1 c2 =&gt; showForProofTreeClaim c1 ++ <span class="s2">&quot; \vee &quot;</span> ++ showForProofTreeClaim c2
      | Implies a1 c1 c2 =&gt; showForProofTreeClaim c1 ++ <span class="s2">&quot; \rightarrow_{}&quot;</span> ++ showForProofTree a1 ++ <span class="s2">&quot; &quot;</span> ++ showForProofTreeClaim c2
    <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage claim := {
  showForNaturalLanguage :=
  <span class="kr">fix</span> showForNaturalLanguageClaim c :=
    <span class="kr">match</span> c <span class="kr">with</span>
      | AtomicClaim name =&gt; showForNaturalLanguage name
      | Bottom =&gt; <span class="s2">&quot;impossible&quot;</span>
      | And c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForNaturalLanguageClaim c1 ++ <span class="s2">&quot; and &quot;</span> ++ showForNaturalLanguageClaim c2  ++ <span class="s2">&quot;)&quot;</span>
      | Or c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForNaturalLanguageClaim c1 ++ <span class="s2">&quot; or &quot;</span> ++ showForNaturalLanguageClaim c2 ++ <span class="s2">&quot;)&quot;</span>
      | Implies a1 c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForNaturalLanguageClaim c1 ++ <span class="s2">&quot;, believed by &quot;</span> ++ showForNaturalLanguage a1 ++ <span class="s2">&quot;, implies &quot;</span> ++ showForNaturalLanguageClaim c2 ++ <span class="s2">&quot;)&quot;</span>
    <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq claim := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree trustRelation := {
  showForProofTree t :=
  <span class="kr">match</span> t <span class="kr">with</span>
    | Trust name =&gt; showForProofTree name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage trustRelation := {
  showForNaturalLanguage t :=
  <span class="kr">match</span> t <span class="kr">with</span>
    | Trust name =&gt; showForNaturalLanguage name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq trustRelation := {
  showForLogSeq t :=
  <span class="kr">match</span> t <span class="kr">with</span>
    | Trust name =&gt; showForLogSeq name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForProofTree_list</span> {<span class="nv">A</span>} `{ShowForProofTree A} (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;&quot;</span>
    | [h] =&gt; showForProofTree h
    | h1 :: (h2 :: tl) <span class="kr">as</span> tl&#39; =&gt; showForProofTree h1 ++ <span class="s2">&quot;, &quot;</span> ++ showForProofTree_list tl&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForProofTree_list_instance</span> (<span class="nv">A</span> : <span class="kt">Type</span>) `(ShowForProofTree A) : ShowForProofTree (list A) := {
  showForProofTree l := showForProofTree_list l
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk5"><span class="kn">Fixpoint</span> <span class="nf">showForNaturalLanguage_list</span> {<span class="nv">A</span>} `{ShowForNaturalLanguage A} (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;no items&quot;</span>
    | [h] =&gt; showForNaturalLanguage h
    | [h1;h2] =&gt; showForNaturalLanguage h1 ++ <span class="s2">&quot;, and &quot;</span> ++ showForNaturalLanguage h2
    | h1 :: (h2 :: tl) <span class="kr">as</span> tl&#39; =&gt; showForNaturalLanguage h1 ++ <span class="s2">&quot;, &quot;</span> ++ showForNaturalLanguage_list tl&#39;
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Unused variable tl might be a misspelled <span class="nb">constructor</span>.
Use _ or _tl to silence this warning.
[unused-<span class="nb">pattern</span>-matching-variable,<span class="nb">pattern</span>-matching]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForNaturalLanguage_list_instance</span> (<span class="nv">A</span> : <span class="kt">Type</span>) `(ShowForNaturalLanguage A) : ShowForNaturalLanguage (list A) := {
    showForNaturalLanguage l := showForNaturalLanguage_list l
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForLogSeq_list</span> {<span class="nv">A</span>} `{ShowForLogSeq A} (indent : string) (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;&quot;</span>
    | [h] =&gt; indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq h
    | h :: tl =&gt; indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq h ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ showForLogSeq_list indent tl
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Instance showForLogSeq_list_instance (A : Type) `(ShowForLogSeq A) (indent : string) : ShowForLogSeq (list A) := {</span>
<span class="c">    showForLogSeq l := showForLogSeq_list indent l</span>
<span class="c">  }. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showListForProofs</span> {<span class="nv">A</span>} `{ShowForProofTree A} (l : list A) :=
    <span class="kr">match</span> l <span class="kr">with</span>
      | [] =&gt; <span class="s2">&quot;&quot;</span>
      | h :: tl =&gt; <span class="s2">&quot;</span>

<span class="s2">----------------</span>

<span class="s2">&quot;</span> ++ showForProofTree h ++ showListForProofs tl
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree judgement := {
  showForProofTree j :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | Judgement e jp =&gt;
    <span class="kr">match</span> jp <span class="kr">with</span>
      | JudgementPart a c =&gt; showForProofTree e ++ <span class="s2">&quot;^{&quot;</span> ++ showForProofTree a ++ <span class="s2">&quot;} \in &quot;</span>
                                  ++ showForProofTree c
    <span class="kr">end</span>  
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage judgement := {
  showForNaturalLanguage j :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | Judgement e jp =&gt;
    <span class="kr">match</span> jp <span class="kr">with</span>
      | JudgementPart a c =&gt; showForNaturalLanguage c ++ <span class="s2">&quot; is supported by $&quot;</span> ++ showForNaturalLanguage e ++ <span class="s2">&quot;$ which &quot;</span> ++ showForNaturalLanguage a ++ <span class="s2">&quot; uses&quot;</span>
    <span class="kr">end</span>  
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq judgement := {
  showForLogSeq j :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | Judgement e jp =&gt;
    <span class="kr">match</span> jp <span class="kr">with</span>
      | JudgementPart a c =&gt; showForLogSeq c ++ <span class="s2">&quot; is held by &quot;</span> ++ showForLogSeq a ++ <span class="s2">&quot; by the evidence $&quot;</span> ++ showForLogSeq e ++ <span class="s2">&quot;$&quot;</span>
    <span class="kr">end</span>  
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForProofTree_judgement</span> (<span class="nv">Ps</span> : list judgement) (<span class="nv">Ts</span> : list trustRelation) (<span class="nv">j</span> : judgementPart) (<span class="nv">p</span> : proofTreeOf j) :=
<span class="kr">let</span> <span class="nv">computedEvidence</span> := computeEvidence j p <span class="kr">in</span>
    <span class="kr">match</span> Ps <span class="kr">with</span>
      | [] =&gt; showForProofTree (Judgement computedEvidence j)
      | (h :: tl) <span class="kr">as</span> Ps =&gt; showForProofTree Ps ++ <span class="s2">&quot; \vdash_{&quot;</span> ++ showForProofTree Ts ++ <span class="s2">&quot;} &quot;</span> ++ (showForProofTree (Judgement computedEvidence j))
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk6"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree_judgement [] [] j1 (hole j1).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\textcolor{red}{e_{?}}^{a_{2}} \in C_{2}&quot;</span>
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk7"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree_judgement [Judgement e (\<span class="bp">by</span> a1 \<span class="kr">in</span> c1)] [] (\<span class="bp">by</span> a1 \<span class="kr">in</span> c1) (assume e a1 c1).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;e^{a_{1}} \in C_{1} \vdash_{} e^{a_{1}} \in C_{1}&quot;</span>
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForNaturalLanguage_judgement</span> (<span class="nv">Ps</span> : list judgement) (<span class="nv">Ts</span> : list trustRelation) (<span class="nv">j</span> : judgementPart) (<span class="nv">p</span> : proofTreeOf j) :=
  <span class="kr">let</span> <span class="nv">computedEvidence</span> := computeEvidence j p <span class="kr">in</span>
    <span class="kr">match</span> Ps <span class="kr">with</span>
      | [] =&gt; showForNaturalLanguage (Judgement computedEvidence j)
      | (h :: tl) <span class="kr">as</span> Ps =&gt; <span class="s2">&quot;Assuming &quot;</span> ++ showForNaturalLanguage Ps ++ <span class="s2">&quot; then &quot;</span> ++ showForNaturalLanguage (Judgement computedEvidence j)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForLogSeq_judgement</span> (<span class="nv">Ps</span> : list judgement) (<span class="nv">Ts</span> : list trustRelation) (<span class="nv">indent</span> : string) (<span class="nv">j</span> : judgementPart) (<span class="nv">p</span> : proofTreeOf j) :=
  <span class="kr">let</span> <span class="nv">computedEvidence</span> := computeEvidence j p <span class="kr">in</span>  
  <span class="kr">match</span> Ps,Ts <span class="kr">with</span>
        | [],[] =&gt; showForLogSeq (Judgement computedEvidence j) ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Assumptions made: None&quot;</span> ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Trust relations used: None&quot;</span>
        | (h :: tl),[] =&gt; showForLogSeq (Judgement computedEvidence j) ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Assumptions made:&quot;</span> ++ showForLogSeq_list (<span class="s2">&quot;  &quot;</span> ++ indent) Ps ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Trust relations used: None&quot;</span>
        | [],(h :: tl) =&gt; showForLogSeq (Judgement computedEvidence j) ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Assumptions made: None&quot;</span> ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Trust relations used:&quot;</span> ++ showForLogSeq_list (<span class="s2">&quot;  &quot;</span> ++ indent) Ts
        | (h :: tl),(h2::tl2) =&gt; showForLogSeq (Judgement computedEvidence j) ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Assumptions made:&quot;</span> ++ showForLogSeq_list (<span class="s2">&quot;  &quot;</span> ++ indent) Ps ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Trust relations used:&quot;</span> ++ showForLogSeq_list (<span class="s2">&quot;  &quot;</span> ++ indent) Ts
      <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* Definition showForLogSeq_judgement (Ps : list singleJudgement) (Ts : list trustRelationInfo) (indent : string) (j : judgement) (p : proofTreeOf j) :=</span>
<span class="c">  match j with</span>
<span class="c">  | Entail s =&gt; </span>
<span class="c">      match Ps,Ts with</span>
<span class="c">        | [],[] =&gt; showForLogSeq s</span>
<span class="c">        | (h :: tl),[] =&gt; showForLogSeq s ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;collapsed:: true</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made:</span>
<span class="c">&quot; ++ indent ++ &quot;  collapsed:: true</span>
<span class="c">&quot; ++ showLong2List (&quot;  &quot; ++ indent) Ps</span>
<span class="c">        | [],(h :: tl) =&gt; showForLogSeq s ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;collapsed:: true</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used:</span>
<span class="c">&quot; ++ indent ++ &quot;  collapsed:: true</span>
<span class="c">&quot; ++ showLong2List (&quot;  &quot; ++ indent) Ts</span>
<span class="c">        | (h :: tl),(h2::tl2) =&gt; showForLogSeq s ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;collapsed:: true</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made:</span>
<span class="c">&quot; ++ indent ++ &quot;  collapsed:: true</span>
<span class="c">&quot; ++ showLong2List (&quot;  &quot; ++ indent) Ps ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used:</span>
<span class="c">&quot; ++ indent ++ &quot;  collapsed:: true</span>
<span class="c">&quot; ++ showLong2List (&quot;  &quot; ++ indent) Ts</span>
<span class="c">      end</span>
<span class="c">  | IsAVeracityClaim c =&gt; showForNaturalLanguage c ++ &quot; is a veracity claim&quot; (* ShowLong2 won&#39;t actually use this branch. *)</span>
<span class="c">  end. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAllTrustRelationsUsed</span> (<span class="nv">j</span> : judgementPart) (<span class="nv">p</span> : proofTreeOf j)
  : list trustRelation :=
<span class="kr">match</span> p <span class="kr">with</span>
| hole _ =&gt; []
| assume e a C =&gt; []
| bot_elim a C M =&gt; getAllTrustRelationsUsed _ M
| and_intro a C1 C2 L R =&gt; 
    getAllTrustRelationsUsed _ L ++ getAllTrustRelationsUsed _ R 
| and_elim1 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| and_elim2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_intro1 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_intro2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_elim1 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_elim2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| trust a1 a2 C name L =&gt; 
    name :: getAllTrustRelationsUsed _ L
| impl_intro e1 C1 a1 a2 C2 M =&gt; getAllTrustRelationsUsed _ M
| impl_elim a1 a2 C1 C2 L R =&gt; 
   getAllTrustRelationsUsed _ L ++ getAllTrustRelationsUsed _ R 
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAllEvidence</span> (<span class="nv">j</span> : judgementPart) (<span class="nv">p</span> : proofTreeOf j)
  : list evid :=
<span class="kr">match</span> p <span class="kr">with</span>
| hole _ =&gt; [HoleEvid]
| assume e a C =&gt; [e]
| bot_elim a C M =&gt; e :: (getAllEvidence _ M)
| and_intro a C1 C2 L R =&gt; 
    e1 :: e2 :: getAllEvidence _ L ++ getAllEvidence _ R 
| and_elim1 a C1 C2 M =&gt; e1 :: e2 :: getAllEvidence _ M
| and_elim2 a C1 C2 M =&gt; e1 :: e2 :: getAllEvidence _ M
| or_intro1 a C1 C2 M =&gt; e1 :: getAllEvidence _ M
| or_intro2 a C1 C2 M =&gt; e2 :: getAllEvidence _ M
| or_elim1 a C1 C2 M =&gt; e1 :: getAllEvidence _ M
| or_elim2 a C1 C2 M =&gt; e2 :: getAllEvidence _ M
| trust a1 a2 C name L =&gt; e ::  getAllEvidence _ L
| impl_intro e1 C1 a1 a2 C2 M =&gt; e1 :: e2 :: getAllEvidence _ M
| impl_elim a1 a2 C1 C2 L R =&gt; 
   e1 :: e2 :: getAllEvidence _ L ++ getAllEvidence _ R 
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isAtomicEvidence</span> (<span class="nv">e</span> : evid) : bool :=
<span class="kr">match</span> e <span class="kr">with</span>
  | AtomicEvid _ =&gt; true
  | _ =&gt; false
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAssumptions</span> (<span class="nv">j</span> : judgementPart) (<span class="nv">p</span> : proofTreeOf j) : list judgementPart := 
<span class="kr">match</span> p <span class="kr">with</span>
| hole _ =&gt; []
| assume e a C =&gt; [\<span class="bp">by</span> a \<span class="kr">in</span> C]
| bot_elim a C M =&gt; getAssumptions _ M
| and_intro a C1 C2 L R =&gt; 
    getAssumptions _ L ++ getAssumptions _ R 
| and_elim1 a C1 C2 M =&gt; getAssumptions _ M
| and_elim2 a C1 C2 M =&gt; getAssumptions _ M
| or_intro1 a C1 C2 M =&gt; getAssumptions _ M
| or_intro2 a C1 C2 M =&gt; getAssumptions _ M
| or_elim1 a C1 C2 M =&gt; getAssumptions _ M
| or_elim2 a C1 C2 M =&gt; getAssumptions _ M
| trust a1 a2 C name L =&gt; 
    getAssumptions _ L
| impl_intro e1 C1 a1 a2 C2 M =&gt; filter (judgementPart_beq (\<span class="bp">by</span> a1 \<span class="kr">in</span> C1)) (getAssumptions _ M)
| impl_elim a1 a2 C1 C2 L R =&gt; 
   getAssumptions _ L ++ getAssumptions _ R 
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAssumptionsWithEvidence</span> (<span class="nv">j</span> : judgementPart) (<span class="nv">p</span> : proofTreeOf j) : list (judgement) := 
<span class="kr">match</span> p <span class="kr">with</span>
| hole j =&gt; [(Judgement HoleEvid j)]
| assume e a C =&gt; [Judgement e (\<span class="bp">by</span> a \<span class="kr">in</span> C)]
| bot_elim a C M =&gt; getAssumptionsWithEvidence _ M
| and_intro a C1 C2 L R =&gt; 
    getAssumptionsWithEvidence _ L ++ getAssumptionsWithEvidence _ R 
| and_elim1 a C1 C2 M =&gt; getAssumptionsWithEvidence _ M
| and_elim2 a C1 C2 M =&gt; getAssumptionsWithEvidence _ M
| or_intro1 a C1 C2 M =&gt; getAssumptionsWithEvidence _ M
| or_intro2 a C1 C2 M =&gt; getAssumptionsWithEvidence _ M
| or_elim1 a C1 C2 M =&gt; getAssumptionsWithEvidence _ M
| or_elim2 a C1 C2 M =&gt; getAssumptionsWithEvidence _ M
| trust a1 a2 C name L =&gt; 
    getAssumptionsWithEvidence _ L
| impl_intro e1 C1 a1 a2 C2 M =&gt; filter (judgement_beq (Judgement e1 (\<span class="bp">by</span> a1 \<span class="kr">in</span> C1))) (getAssumptionsWithEvidence _ M)
| impl_elim a1 a2 C1 C2 L R =&gt; 
   getAssumptionsWithEvidence _ L ++ getAssumptionsWithEvidence _ R 
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">removeDups</span> {<span class="nv">A</span>} `{Beq A} (l : list A) : list A :=
<span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; []
| h :: tl =&gt; <span class="kr">if</span> existsb (beq h) tl <span class="kr">then</span> removeDups tl <span class="kr">else</span> h :: removeDups tl
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">proofTreeOf_beq</span> {<span class="nv">j1</span> <span class="nv">j2</span> : judgementPart} (<span class="nv">P1</span> : proofTreeOf j1) (<span class="nv">P2</span> : proofTreeOf j2) : bool :=
<span class="kr">match</span> P1,P2 <span class="kr">with</span>
| hole j1,hole j2 =&gt; j1 =? j2
| assume e a1 C1, assume e2 a2 C2 =&gt; (e =? e2) &amp;&amp; (a1 =? a2) &amp;&amp; (C1 =? C2)
| bot_elim a1 C1 M1, bot_elim a2 C2 M2 =&gt; (a1 =? a2) &amp;&amp; (C1 =? C2) &amp;&amp; proofTreeOf_beq M1 M2
| and_intro a C1 C2 L R, and_intro a&#39; C1&#39; C2&#39; L&#39; R&#39; =&gt; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq L L&#39; &amp;&amp; proofTreeOf_beq R R&#39;
| and_elim1 a C1 C2 M, and_elim1 a&#39; C1&#39; C2&#39; M&#39; =&gt; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;
| and_elim2 a C1 C2 M, and_elim2 a&#39; C1&#39; C2&#39; M&#39; =&gt; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;
| or_intro1 a C1 C2 M, or_intro1 a&#39; C1&#39; C2&#39; M&#39; =&gt; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;
| or_intro2 a C1 C2 M, or_intro2 a&#39; C1&#39; C2&#39; M&#39; =&gt; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;
| or_elim1 a C1 C2 M, or_elim1 a&#39; C1&#39; C2&#39; M&#39; =&gt; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;
| or_elim2 a C1 C2 M, or_elim2 a&#39; C1&#39; C2&#39; M&#39; =&gt; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;
| trust a1 a2 C T L, trust a1&#39; a2&#39; C&#39; T&#39; L&#39; =&gt; (a1 =? a1&#39;) &amp;&amp; (a2 =? a2&#39;) &amp;&amp; (C =? C&#39;) &amp;&amp; (T =? T&#39;) &amp;&amp; proofTreeOf_beq L L&#39;
| impl_intro e C1 a1 a2 C2 M, impl_intro e&#39; C1&#39; a1&#39; a2&#39; C2&#39; M&#39; =&gt; (e =? e&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (a1 =? a1&#39;) &amp;&amp; (a2 =? a2&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;
| impl_elim a1 a2 C1 C2 L R, impl_elim a1&#39; a2&#39; C1&#39; C2&#39; L&#39; R&#39; =&gt; (a1 =? a1&#39;) &amp;&amp; (a2 =? a2&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq L L&#39; &amp;&amp; proofTreeOf_beq R R&#39;
| _,_ =&gt; false
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">beq_proofTreeOf_instance</span> (<span class="nv">j</span> : judgementPart) : Beq (proofTreeOf j) := { beq := proofTreeOf_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForProofTree_proofTreeOf_helper</span> (<span class="nv">j</span> : judgementPart) (<span class="nv">p</span> : proofTreeOf j)
  : string :=
<span class="kr">let</span> <span class="nv">Ts</span> := (removeDups (getAllTrustRelationsUsed j p)) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">Ps</span> := (removeDups (getAssumptionsWithEvidence j p)) <span class="kr">in</span>
<span class="kr">match</span> p <span class="kr">with</span>
| hole j =&gt; <span class="s2">&quot;\AxiomC{$\textcolor{red}{&quot;</span> ++ (showForProofTree (Judgement HoleEvid j)) ++ <span class="s2">&quot;}$}&quot;</span>
| assume e a C =&gt; <span class="s2">&quot;\AxiomC{$ &quot;</span> 
             ++ showForProofTree C 
             ++ <span class="s2">&quot; \textit{ is a veracity claim} $}&quot;</span>
    ++ <span class="s2">&quot; \RightLabel{ $ assume $}\UnaryInfC{$ &quot;</span>
    ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
| bot_elim a C M =&gt; showForProofTree_proofTreeOf_helper _ M
    ++ <span class="s2">&quot; \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ &quot;</span>
    ++ showForProofTree_judgement Ps Ts _ p
    ++ <span class="s2">&quot; $}&quot;</span>
| and_intro a C1 C2 L R =&gt; 
    showForProofTree_proofTreeOf_helper _ L
 ++ showForProofTree_proofTreeOf_helper _ R 
 ++ <span class="s2">&quot; \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
| and_elim1 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \land^{-1} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| and_elim2 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \land^{-2} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_intro1 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{+1} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_intro2 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{+2} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_elim1 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{-1} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_elim2 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{-2} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| trust a1 a2 C name L =&gt; 
    showForProofTree_proofTreeOf_helper _ L
 ++ <span class="s2">&quot; \AxiomC{$&quot;</span> ++ showForProofTree a1 ++ showForProofTree name ++ showForProofTree a2 ++ <span class="s2">&quot;$} &quot;</span>
 ++ <span class="s2">&quot; \RightLabel{ $ trust\ &quot;</span> ++ showForProofTree name
 ++ <span class="s2">&quot;$} \BinaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
| impl_intro e1 C1 a1 a2 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| impl_elim a1 a2 C1 C2 L R =&gt; 
     showForProofTree_proofTreeOf_helper _ L
 ++ showForProofTree_proofTreeOf_helper _ R 
 ++ <span class="s2">&quot; \RightLabel{ $ \rightarrow^{-}_{&quot;</span> ++ showForProofTree a1 ++ <span class="s2">&quot;} $} \BinaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForNaturalLanguage_proofTreeOf_helper</span> (<span class="nv">indent</span> : string) (<span class="nv">j</span> : judgementPart) (<span class="nv">p</span> : proofTreeOf j)
  : string :=
<span class="kr">let</span> <span class="nv">Ts</span> := (removeDups (getAllTrustRelationsUsed j p)) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">Ps</span> := (removeDups (getAssumptionsWithEvidence j p)) <span class="kr">in</span>
<span class="kr">match</span> p <span class="kr">with</span>
| hole p =&gt; indent ++ <span class="s2">&quot;we stopped the proof at this point and assumed it was provable.&quot;</span>
| assume e a C =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ indent ++ showForNaturalLanguage C ++ <span class="s2">&quot; is a veracity claim.&quot;</span> ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by assumption.&quot;</span>
| bot_elim a C M =&gt;
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by the logical principle of explosion.&quot;</span>
| and_intro a C1 C2 L R =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ L ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ R ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;and&#39;.&quot;</span>
| and_elim1 a C1 C2 M =&gt;
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;and&#39;.&quot;</span>
| and_elim2 a C1 C2 M =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;and&#39;.&quot;</span>
| or_intro1 a C1 C2 M =&gt;
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;or&#39;.&quot;</span>
| or_intro2 a C1 C2 M =&gt;
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;or&#39;.&quot;</span>
| or_elim1 a C1 C2 M =&gt;
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;or&#39;.&quot;</span>
| or_elim2 a C1 C2 M =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;or&#39;.&quot;</span>
| trust a1 a2 C name L =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ L ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by the trust relation &quot;</span> ++ showForNaturalLanguage name ++ <span class="s2">&quot;.&quot;</span>
| impl_intro e1 C1 a1 a2 C2 M =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for implication.&quot;</span>
| impl_elim a1 a2 C1 C2 L R =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ L ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ R ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for implication.&quot;</span>
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForLogSeq_proofTreeOf_helper</span> (<span class="nv">indent</span> : string) (<span class="nv">j</span> : judgementPart) (<span class="nv">p</span> : proofTreeOf j)
  : string :=
<span class="kr">let</span> <span class="nv">Ts</span> := (removeDups (getAllTrustRelationsUsed j p)) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">Ps</span> := (removeDups (getAssumptionsWithEvidence j p)) <span class="kr">in</span>
<span class="kr">match</span> p <span class="kr">with</span>
| hole p =&gt; indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;We stopped the proof at this point and assumed it was provable.&quot;</span>
| assume e a C =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: we assume this&quot;</span>
| bot_elim a C M =&gt;
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: the principle of explosion</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| and_intro a C1 C2 L R =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: and introduction</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proofs:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ L ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ R
| and_elim1 a C1 C2 M =&gt;
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: and elimination (1)</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| and_elim2 a C1 C2 M =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: and elimination (2)</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| or_intro1 a C1 C2 M =&gt;
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: or introduction (1)</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| or_intro2 a C1 C2 M =&gt;
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: or introduction (2)</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| or_elim1 a C1 C2 M =&gt;
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: or elimination (1)</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| or_elim2 a C1 C2 M =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: or elimination (2)</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| trust a1 a2 C name L =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: trust, with relation &quot;</span> ++ showForLogSeq name ++ <span class="s2">&quot;</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ L
| impl_intro e1 C1 a1 a2 C2 M =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: implication introduction</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| impl_elim a1 a2 C1 C2 L R =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: implication elimination</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proofs:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ L ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ R
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForProofTree_proofTreeOf</span> <span class="nv">j</span> <span class="nv">p</span>
  := <span class="s2">&quot;\begin{prooftree}&quot;</span> ++ showForProofTree_proofTreeOf_helper j p
       ++ <span class="s2">&quot;\end{prooftree}&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForProofTree_proofTreeOf_instance</span> (<span class="nv">j</span> : judgementPart)
  : ShowForProofTree (proofTreeOf j) := { showForProofTree := showForProofTree_proofTreeOf j}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForNaturalLanguage_proofTreeOf</span> <span class="nv">j</span> <span class="nv">p</span> := <span class="s2">&quot;</span>

<span class="s2">&quot;</span> ++ showForNaturalLanguage_proofTreeOf_helper <span class="s2">&quot;- &quot;</span> j p ++ <span class="s2">&quot;</span>

<span class="s2">&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForNaturalLanguage_proofTreeOf_instance</span> (<span class="nv">j</span> : judgementPart)
  : ShowForNaturalLanguage (proofTreeOf j) := { showForNaturalLanguage := showForNaturalLanguage_proofTreeOf j}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">printProofTitle</span> <span class="nv">j</span> :=
<span class="kr">match</span> j <span class="kr">with</span>
| JudgementPart a c =&gt; <span class="s2">&quot;### Veracity proof that &quot;</span> ++ showForLogSeq c ++ <span class="s2">&quot; is held by &quot;</span> ++ showForLogSeq a
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForLogSeq_proofTreeOf</span> <span class="nv">j</span> <span class="nv">p</span> := <span class="s2">&quot;</span>

<span class="s2">&quot;</span> ++ printProofTitle j ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper <span class="s2">&quot;  &quot;</span> j p ++ <span class="s2">&quot;</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">&quot;</span> ++ showForLogSeq_list <span class="s2">&quot;    &quot;</span> (removeDups (filter isAtomicEvidence (getAllEvidence j p))) ++ <span class="s2">&quot;</span>

<span class="s2">&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showLong2ProofTreeOfInstance</span> (<span class="nv">j</span> : judgementPart)
  : ShowForLogSeq (proofTreeOf j) := { showForLogSeq := showForLogSeq_proofTreeOf j}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* |</span>

<span class="c">Proof Automation without Ltac</span>
<span class="c">-----------------------------</span>

<span class="c">The approach taken here is to search for proofs using Coq&#39;s functional language, rather than relying on Ltac.</span>
<span class="c">This will:</span>
<span class="c"> - Perform backwards search</span>
<span class="c"> - Use &quot;hole&quot; (which may in future be renamed &quot;hole&quot;) to fill in holes in the current proofs search.</span>
<span class="c"> - Involve a function which takes a single proof tree (potentially containing holes), and generates a list of proof trees &quot;one level deeper&quot;, potentially including holes.</span>
<span class="c"> - Include a depth limit, after which the proof search is halted.</span>
<span class="c"> - Include a function to filter out proof trees based on whether they still contain holes, (and in the future other attributes such as whether the resulting weight is above a certain value)</span>
<span class="c"> - Involve a function that takes a list of prooftrees and returns a list of prooftrees &quot;one level deeper&quot;, making use of the function which takes a single proof tree as input.</span>

<span class="c">|*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">toProofTreeWithHole</span> (<span class="nv">a</span> : actor) (<span class="nv">c</span> : claim) := hole (\<span class="bp">by</span> a \<span class="kr">in</span> c).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eB</span> := AtomicEvid _eB_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">T</span> := Trust _T_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">proofStepExample1</span> (<span class="nv">j</span> : judgementPart) : list (proofTreeOf j) :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | JudgementPart a c =&gt; 
    <span class="sd">(** Assumptions: *)</span>
    (<span class="kr">if</span> (a =? a1) &amp;&amp; (c =? C) <span class="kr">then</span> [assume e a c] <span class="kr">else</span> [])
    ++
    (<span class="kr">if</span> (a =? a2) &amp;&amp; (c =? C) <span class="kr">then</span> [assume e a c] <span class="kr">else</span> [])
    ++
    (<span class="kr">if</span> (a =? a1) &amp;&amp; (c =? (C /\&#39; C)) <span class="kr">then</span> [assume e a c] <span class="kr">else</span> [])
    ++
    <span class="sd">(** Trust relations: *)</span>
    (<span class="kr">if</span> (a =? a1) <span class="kr">then</span> [trust a a2 c T (hole _); trust a a3 c T (hole _)] <span class="kr">else</span> [])
    ++
    (<span class="kr">if</span> (a =? a2) <span class="kr">then</span> [trust a a3 c T (hole _)] <span class="kr">else</span> [])
    ++
    <span class="sd">(** Rules for specific claim patterns: *)</span>
    <span class="kr">match</span> c <span class="kr">with</span>
      | And C1 C2 =&gt; [and_intro a C1 C2 (hole _) (hole _)] 
      | Or C1 C2 =&gt; [or_intro1 a C1 C2 (hole _); or_intro2 a C1 C2 (hole _)]
      <span class="sd">(** The rules for Implies should echo the rules for assumptions, ideally. Or else involve eQ. *)</span>
      | Implies a&#39; C1 C2 =&gt;
          (<span class="kr">if</span> (a =? a1) &amp;&amp; (C1 =? _|_) <span class="kr">then</span> [impl_intro e C1 a&#39; a C2 (hole _)] <span class="kr">else</span> [])
          ++
          (<span class="kr">if</span> (a =? a1) &amp;&amp; (C1 =? C) <span class="kr">then</span> [impl_intro e C1 a&#39; a C2 (hole _)] <span class="kr">else</span> [])
          ++
          (<span class="kr">if</span> (a =? a2) &amp;&amp; (C1 =? C) <span class="kr">then</span> [impl_intro e C1 a&#39; a C2 (hole _)] <span class="kr">else</span> [])
          ++
          (<span class="kr">if</span> (a =? a1) &amp;&amp; (C1 =? (C /\&#39; C)) <span class="kr">then</span> [impl_intro e C1 a&#39; a C2 (hole _)] <span class="kr">else</span> [])
      | _ =&gt; []
      <span class="kr">end</span>
    ++
    <span class="sd">(** Rules that can be applied to any claim, use with caution, can cause performance issues. *)</span>
    [
      (bot_elim a c (assume eB a _|_))
      <span class="c">(* ; (or_elim1 a c c1 (hole _))</span>
<span class="c">      ; (or_elim1 a c c2 (hole _))</span>
<span class="c">      ; (or_elim1 a c c3 (hole _))</span>
<span class="c">      ; (or_elim2 a c1 c (hole _))</span>
<span class="c">      ; (or_elim2 a c2 c (hole _))</span>
<span class="c">      ; (or_elim2 a c3 c (hole _))</span>
<span class="c">      ; (and_elim1 a c c1 (hole _))</span>
<span class="c">      ; (and_elim1 a c c2 (hole _))</span>
<span class="c">      ; (and_elim1 a c c3 (hole _))</span>
<span class="c">      ; (and_elim2 a c1 c (hole _))</span>
<span class="c">      ; (and_elim2 a c2 c (hole _))</span>
<span class="c">      ; (and_elim2 a c3 c (hole _)) *)</span>
      ; (impl_elim a a _|_ c (hole _) (hole _))
      <span class="c">(* ; (impl_elim a c1 c (hole _) (hole _))</span>
<span class="c">      ; (impl_elim a c2 c (hole _) (hole _))</span>
<span class="c">      ; (impl_elim a c3 c (hole _) (hole _)) *)</span>
    ]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk8"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> proofStepExample1 (\<span class="bp">by</span> a1 \<span class="kr">in</span> (C /\&#39; C)).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= [assume (AtomicEvid _e_) (Actor _a1_)
     (AtomicClaim _c_ /\&#39; AtomicClaim _c_);
   trust (Actor _a1_) (Actor _a2_)
     (AtomicClaim _c_ /\&#39; AtomicClaim _c_)
     (Trust _T_)
     (hole
        \<span class="bp">by</span> Actor _a2_ \<span class="kr">in</span>
        (AtomicClaim _c_ /\&#39; AtomicClaim _c_));
   trust (Actor _a1_) (Actor _a3_)
     (AtomicClaim _c_ /\&#39; AtomicClaim _c_)
     (Trust _T_)
     (hole
        \<span class="bp">by</span> Actor _a3_ \<span class="kr">in</span>
        (AtomicClaim _c_ /\&#39; AtomicClaim _c_));
   and_intro (Actor _a1_) (AtomicClaim _c_)
     (AtomicClaim _c_)
     (hole \<span class="bp">by</span> Actor _a1_ \<span class="kr">in</span> (AtomicClaim _c_))
     (hole \<span class="bp">by</span> Actor _a1_ \<span class="kr">in</span> (AtomicClaim _c_));
   bot_elim (Actor _a1_)
     (AtomicClaim _c_ /\&#39; AtomicClaim _c_)
     (assume (AtomicEvid _eB_) (Actor _a1_) _|_);
   impl_elim (Actor _a1_) (Actor _a1_) _|_
     (AtomicClaim _c_ /\&#39; AtomicClaim _c_)
     (hole
        \<span class="bp">by</span> Actor _a1_ \<span class="kr">in</span>
        (Implies (Actor _a1_) _|_
           (AtomicClaim _c_ /\&#39; AtomicClaim _c_)))
     (hole \<span class="bp">by</span> Actor _a1_ \<span class="kr">in</span> _|_)]
: list (proofTreeOf \<span class="bp">by</span> a1 \<span class="kr">in</span> (C /\&#39; C))</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">oneLevelDeeper</span> (<span class="nv">step</span> : <span class="kr">forall</span> <span class="nv">j</span> : judgementPart, list (proofTreeOf j)) (<span class="nv">j</span> : judgementPart) (<span class="nv">p</span> : proofTreeOf j) : list (proofTreeOf j) :=
  <span class="kr">match</span> p <span class="kr">with</span>
| hole j =&gt; step j
| assume e a c =&gt; [(assume e a c)]
| bot_elim a C M =&gt; map (bot_elim a C) (oneLevelDeeper step _ M)
| and_intro a C1 C2 L R =&gt; map (<span class="kr">fun</span> <span class="nv">L2</span> =&gt; and_intro a C1 C2 L2 R) (oneLevelDeeper step _ L)
                        ++ map (and_intro a C1 C2 L) (oneLevelDeeper step _ R)
| and_elim1 a C1 C2 M =&gt; map (and_elim1 a C1 C2) (oneLevelDeeper step _ M)
| and_elim2 a C1 C2 M =&gt; map (and_elim2 a C1 C2) (oneLevelDeeper step _ M)
| or_intro1 a C1 C2 M =&gt; map (or_intro1 a C1 C2) (oneLevelDeeper step _ M)
| or_intro2 a C1 C2 M =&gt; map (or_intro2 a C1 C2) (oneLevelDeeper step _ M)
| or_elim1 a C1 C2 M =&gt; map (or_elim1 a C1 C2) (oneLevelDeeper step _ M)
| or_elim2 a C1 C2 M =&gt; map (or_elim2 a C1 C2) (oneLevelDeeper step _ M)
| trust a1 a2 C name L =&gt; map (trust a1 a2 C name) (oneLevelDeeper step _ L)
| impl_intro e1 C1 a1 a2 C2 M =&gt; map (impl_intro e1 C1 a1 a2 C2) (oneLevelDeeper step _ M)
| impl_elim a1 a2 C1 C2 L R =&gt; map (<span class="kr">fun</span> <span class="nv">L2</span> =&gt; impl_elim a1 a2 C1 C2 L2 R) (oneLevelDeeper step _ L)
                        ++ map (impl_elim a1 a2 C1 C2 L) (oneLevelDeeper step _ R)
<span class="kr">end</span>
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Eval compute in oneLevelDeeper _ (toProofTreeWithHole a1 (C /\&#39; C)). *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">oneLevelDeeperOfList</span> <span class="nv">step</span> <span class="nv">j</span> (<span class="nv">l</span> : list (proofTreeOf j)) : list (proofTreeOf j) :=
 removeDups (flat_map (oneLevelDeeper step j) l).</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* Eval compute in  showForProofTree (oneLevelDeeperOfList _ (oneLevelDeeperOfList _ (oneLevelDeeper _ (toProofTreeWithHole a1 (C /\&#39; C /\&#39; C))))). *)</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">repeatFn</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">f</span> : A -&gt; A) :=
<span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; id
  | <span class="mi">1</span> =&gt; f
  | S n&#39; =&gt; <span class="kr">fun</span> <span class="nv">a</span> =&gt; f (repeatFn n&#39; f a)
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> list_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">repeatListFnAndKeepPartials</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{Beq A} (n : nat) (f : list A -&gt; list A) (l : list A) :=
<span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; []
  | <span class="mi">1</span> =&gt; removeDups (f l)
  | S n&#39; =&gt; removeDups ((f l) ++ f (repeatListFnAndKeepPartials n&#39; f l))
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">generateProofsWithDepthLimit</span> <span class="nv">step</span> <span class="nv">j</span> <span class="nv">d</span> := repeatListFnAndKeepPartials d (oneLevelDeeperOfList step j).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">noHoles</span> {<span class="nv">j</span> : judgementPart} (<span class="nv">p</span> : proofTreeOf j) : bool :=
  <span class="kr">match</span> p <span class="kr">with</span>
| hole j =&gt; false
| assume e a C =&gt; true
| bot_elim a C M =&gt; noHoles M
| and_intro a C1 C2 L R =&gt; noHoles L &amp;&amp; noHoles R
| and_elim1 a C1 C2 M =&gt; noHoles M
| and_elim2 a C1 C2 M =&gt; noHoles M
| or_intro1 a C1 C2 M =&gt; noHoles M
| or_intro2 a C1 C2 M =&gt; noHoles M
| or_elim1 a C1 C2 M =&gt; noHoles M
| or_elim2 a C1 C2 M =&gt; noHoles M
| trust a1 a2 C name L =&gt; noHoles L
| impl_intro e1 C1 a1 a2 C2 M =&gt; noHoles M
| impl_elim a1 a2 C1 C2 L R =&gt; noHoles L &amp;&amp; noHoles R
<span class="kr">end</span>
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">proofSearch</span> <span class="nv">step</span> (<span class="nv">j</span> : judgementPart) (<span class="nv">l</span> : list (proofTreeOf j)) (<span class="nv">d</span> : nat) : list (proofTreeOf j) := 
  <span class="kr">match</span> d <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; []
  | S d&#39; =&gt; <span class="kr">let</span> <span class="nv">newL</span> := removeDups (oneLevelDeeperOfList step j l) <span class="kr">in</span> (filter noHoles newL) ++ proofSearch step j (filter (<span class="kr">fun</span> <span class="nv">p</span> =&gt; negb (noHoles p)) newL) d&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** TODO: Try removing string comparison and replacing it with more native comparison, might cause speedup. *)</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk9"><span class="kn">Timeout</span> <span class="mi">20</span> <span class="kn">Eval</span> <span class="nb">vm_compute</span> <span class="kr">in</span> (showListForProofs (( (proofSearch proofStepExample1 _  [toProofTreeWithHole a1 ((Implies a1 _|_ C))] <span class="mi">4</span>)))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}^{a_{2}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}^{a_{2}} \in \bot \rightarrow_{}a_{1} C $} \AxiomC{$a_{1}Ta_{2}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{T} e_{\bot}^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot \rightarrow_{}a_{1} C $} \AxiomC{$a_{1}Ta_{3}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{T} e_{\bot}^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda (e)(e)^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in C $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda (e)(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot \rightarrow_{}a_{1} C $} \AxiomC{$a_{2}Ta_{3}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{T} e_{\bot}^{a_{2}} \in \bot \rightarrow_{}a_{1} C $} \AxiomC{$a_{1}Ta_{2}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{T} e_{\bot}^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{2}} \in C \vdash_{} e^{a_{2}} \in C $} \AxiomC{$a_{1}Ta_{2}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e^{a_{2}} \in C \vdash_{T} e^{a_{1}} \in C $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda (e)(e)^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}^{a_{2}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}^{a_{2}} \in C $} \AxiomC{$a_{1}Ta_{2}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{T} e_{\bot}^{a_{1}} \in C $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda (e)(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in C $} \AxiomC{$a_{1}Ta_{3}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{T} e_{\bot}^{a_{1}} \in C $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda (e)(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot \rightarrow_{}a_{1} \bot \rightarrow_{}a_{1} C $}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \rightarrow^{-}_{a_{1}} $} \BinaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}^{a_{2}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}^{a_{2}} \in \bot \rightarrow_{}a_{2} \bot \rightarrow_{}a_{1} C $}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}^{a_{2}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}^{a_{2}} \in \bot $} \RightLabel{ $ \rightarrow^{-}_{a_{2}} $} \BinaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}(e_{\bot})^{a_{2}} \in \bot \rightarrow_{}a_{1} C $} \AxiomC{$a_{1}Ta_{2}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{T} e_{\bot}(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot \rightarrow_{}a_{3} \bot \rightarrow_{}a_{1} C $}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot $} \RightLabel{ $ \rightarrow^{-}_{a_{3}} $} \BinaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}(e_{\bot})^{a_{3}} \in \bot \rightarrow_{}a_{1} C $} \AxiomC{$a_{1}Ta_{3}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{T} e_{\bot}(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in C $} \AxiomC{$a_{2}Ta_{3}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{T} e_{\bot}^{a_{2}} \in C $} \AxiomC{$a_{1}Ta_{2}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{T} e_{\bot}^{a_{1}} \in C $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda (e)(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \rightarrow^{-}_{a_{1}} $} \BinaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}(e_{\bot})^{a_{1}} \in C $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda (e)(e_{\bot}(e_{\bot}))^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot \rightarrow_{}a_{1} \bot \rightarrow_{}a_{1} C $}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}^{a_{2}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}^{a_{2}} \in \bot $} \AxiomC{$a_{1}Ta_{2}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{T} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \rightarrow^{-}_{a_{1}} $} \BinaryInfC{$ e_{\bot}^{a_{1}} \in \bot, e_{\bot}^{a_{2}} \in \bot \vdash_{T} e_{\bot}(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot \rightarrow_{}a_{1} \bot \rightarrow_{}a_{1} C $}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot $} \AxiomC{$a_{1}Ta_{3}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{T} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \rightarrow^{-}_{a_{1}} $} \BinaryInfC{$ e_{\bot}^{a_{1}} \in \bot, e_{\bot}^{a_{3}} \in \bot \vdash_{T} e_{\bot}(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}^{a_{2}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{} e_{\bot}^{a_{2}} \in \bot \rightarrow_{}a_{1} \bot \rightarrow_{}a_{1} C $} \AxiomC{$a_{1}Ta_{2}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{2}} \in \bot \vdash_{T} e_{\bot}^{a_{1}} \in \bot \rightarrow_{}a_{1} \bot \rightarrow_{}a_{1} C $}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \rightarrow^{-}_{a_{1}} $} \BinaryInfC{$ e_{\bot}^{a_{2}} \in \bot, e_{\bot}^{a_{1}} \in \bot \vdash_{T} e_{\bot}(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{} e_{\bot}^{a_{3}} \in \bot \rightarrow_{}a_{1} \bot \rightarrow_{}a_{1} C $} \AxiomC{$a_{1}Ta_{3}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e_{\bot}^{a_{3}} \in \bot \vdash_{T} e_{\bot}^{a_{1}} \in \bot \rightarrow_{}a_{1} \bot \rightarrow_{}a_{1} C $}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \rightarrow^{-}_{a_{1}} $} \BinaryInfC{$ e_{\bot}^{a_{3}} \in \bot, e_{\bot}^{a_{1}} \in \bot \vdash_{T} e_{\bot}(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot \rightarrow_{}a_{1} C $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda (e)(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} \bot \rightarrow_{}a_{1} C $}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \rightarrow^{-}_{a_{1}} $} \BinaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} \lambda (e)(e_{\bot})(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot \rightarrow_{}a_{1} \bot \rightarrow_{}a_{1} C $}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \rightarrow^{-}_{a_{1}} $} \BinaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}(e_{\bot})^{a_{1}} \in \bot \rightarrow_{}a_{1} C $}\end{prooftree}&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">proofStepExample2</span> (<span class="nv">j</span> : judgementPart) : list (proofTreeOf j) :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | JudgementPart a c =&gt; 
    <span class="sd">(** Assumptions: *)</span>
    (<span class="kr">if</span> (a =? a1) &amp;&amp; (c =? C) <span class="kr">then</span> [assume e a c] <span class="kr">else</span> [])
    ++
    (<span class="kr">if</span> (a =? a1) &amp;&amp; (c =? (C /\&#39; C)) <span class="kr">then</span> [assume e a c] <span class="kr">else</span> [])
    ++
    <span class="sd">(** Rules for specific claim patterns: *)</span>
    <span class="kr">match</span> c <span class="kr">with</span>
      | And C1 C2 =&gt; [and_intro a C1 C2 (hole _) (hole _)] 
      | _ =&gt; []
      <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chka"><span class="kn">Timeout</span> <span class="mi">20</span> <span class="kn">Eval</span> <span class="nb">vm_compute</span> <span class="kr">in</span> (showListForProofs (( (proofSearch proofStepExample2 _  [toProofTreeWithHole a1 ((C /\&#39; C) /\&#39; (C /\&#39; C))] <span class="mi">10</span>)))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (e, (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (e, (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ((e, e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (e, (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ((e, e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (e, (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ((e, e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (e, (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ((e, e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (e, (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Time Eval compute in (showListForProofs (( (proofSearch _  [toProofTreeWithHole a1 ((C /\&#39; C) /\&#39; (C /\&#39; C) /\&#39; (C /\&#39; C) /\&#39; (C /\&#39; C))] 20)))). *)</span>
<span class="c">(* Time Eval compute in (showListForProofs ( filter noHoles (( (generateProofsWithDepthLimit _ 7  [toProofTreeWithHole a1 ((C /\&#39; C) /\&#39; (C /\&#39; C))]))))). *)</span></span></pre></div>
<div class="section" id="an-example-from-the-paper">
<h1>An example from the paper</h1>
<p>This example is the top half of the proof tree on p13 (Section 4.2) of the draft paper.</p>
<p>The proof trees visualised in this section are <strong>automatically generated</strong> by Coq.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">l</span> := AtomicEvid _l_ .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">s</span> := AtomicEvid _s_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c</span> := AtomicEvid _c_evid_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">P</span> := Actor _P_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Q</span> := Actor _Q_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C1</span> := AtomicClaim _c1_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C2</span> := AtomicClaim _c2_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C3</span> := AtomicClaim _c3_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C4</span> := AtomicClaim _c4_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C5</span> := AtomicClaim _c5_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trustT</span> := Trust _T_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trustU</span> := Trust _U_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trustV</span> := Trust _V_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkb"><span class="kn">Definition</span> <span class="nf">concreteProofTreeExampleWith2Conjuncts</span> : 
proofTreeOf (\<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkc"><span class="nb">epose proof</span> (and_intro _ C1 C2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> <span class="nl">?a</span> \<span class="kr">in</span> C1 -&gt;
proofTreeOf \<span class="bp">by</span> <span class="nl">?a</span> \<span class="kr">in</span> C2 -&gt;
proofTreeOf \<span class="bp">by</span> <span class="nl">?a</span> \<span class="kr">in</span> (C1 /\&#39; C2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkd"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> <span class="nl">?a</span> \<span class="kr">in</span> C1 -&gt;
proofTreeOf \<span class="bp">by</span> <span class="nl">?a</span> \<span class="kr">in</span> C2 -&gt;
proofTreeOf \<span class="bp">by</span> <span class="nl">?a</span> \<span class="kr">in</span> (C1 /\&#39; C2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chke"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C1 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C2 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C1 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C2 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkf"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk10"><span class="nb">apply</span> (assume l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C1 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C2 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume s).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk11"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith2Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in C_{1} \wedge C_{2} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk12"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith2Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $l$ which Penelope uses, and claim 2 is supported by $s$ which Penelope uses then (claim 1 and claim 2) is supported by $(l, s)$ which Penelope uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $l$ which Penelope uses then claim 1 is supported by $l$ which Penelope uses, because</span>
<span class="s2">  - claim 1 is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">  - Assuming claim 2 is supported by $s$ which Penelope uses then claim 2 is supported by $s$ which Penelope uses, because</span>
<span class="s2">  - claim 2 is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">- by a logical rule for &#39;and&#39;.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk13"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith2Conjuncts.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that (claim 1 and claim 2) is held by Penelope</span>
<span class="s2">  - (claim 1 and claim 2) is held by Penelope by the evidence $(l, s)$</span>
<span class="s2">    - Assumptions made:      - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">      - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">    - Trust relations used: None</span>
<span class="s2">    - Logical rule used: and introduction</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">          - Assumptions made:            - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">        - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">          - Assumptions made:            - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{1}</span>
<span class="s2">    - e_{2}</span>
<span class="s2">    - l</span>
<span class="s2">    - s</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk14"><span class="kn">Definition</span> <span class="nf">concreteProofTreeExampleWith3Conjuncts</span> : 
proofTreeOf (\<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk15"><span class="nb">epose proof</span> (and_intro) P (C1 /\&#39; C2) C3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk16"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk17"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk18"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk19"><span class="nb">epose proof</span> (and_intro) _ C1 C2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> <span class="nl">?a</span> \<span class="kr">in</span> C1 -&gt;
proofTreeOf \<span class="bp">by</span> <span class="nl">?a</span> \<span class="kr">in</span> C2 -&gt;
proofTreeOf \<span class="bp">by</span> <span class="nl">?a</span> \<span class="kr">in</span> (C1 /\&#39; C2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk1a"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk1b"><span class="nb">simpl</span> <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> <span class="nl">?a</span> \<span class="kr">in</span> C1 -&gt;
proofTreeOf \<span class="bp">by</span> <span class="nl">?a</span> \<span class="kr">in</span> C2 -&gt;
proofTreeOf \<span class="bp">by</span> <span class="nl">?a</span> \<span class="kr">in</span> (C1 /\&#39; C2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk1c"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk1d"><span class="nb">apply</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C1 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C2 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C1 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C2 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk1e"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C2</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk1f"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk20"><span class="nb">apply</span> (assume l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C1 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C2 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk21" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk21"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk22"><span class="nb">apply</span> (assume s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume c).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk23"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith3Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in C_{1} \wedge C_{2} $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in C_{1} \wedge C_{2} \wedge C_{3} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk24"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith3Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Penelope uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $l$ which Penelope uses, and claim 2 is supported by $s$ which Penelope uses then (claim 1 and claim 2) is supported by $(l, s)$ which Penelope uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $l$ which Penelope uses then claim 1 is supported by $l$ which Penelope uses, because</span>
<span class="s2">    - claim 1 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">    - Assuming claim 2 is supported by $s$ which Penelope uses then claim 2 is supported by $s$ which Penelope uses, because</span>
<span class="s2">    - claim 2 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for &#39;and&#39;.</span>
<span class="s2">  - Assuming claim 3 is supported by $c$ which Penelope uses then claim 3 is supported by $c$ which Penelope uses, because</span>
<span class="s2">  - claim 3 is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">- by a logical rule for &#39;and&#39;.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk25"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith3Conjuncts.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that ((claim 1 and claim 2) and claim 3) is held by Penelope</span>
<span class="s2">  - ((claim 1 and claim 2) and claim 3) is held by Penelope by the evidence $((l, s), c)$</span>
<span class="s2">    - Assumptions made:      - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">      - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">      - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">    - Trust relations used: None</span>
<span class="s2">    - Logical rule used: and introduction</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - (claim 1 and claim 2) is held by Penelope by the evidence $(l, s)$</span>
<span class="s2">          - Assumptions made:            - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">            - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: and introduction</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                - Assumptions made:                  - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                - Trust relations used: None</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">              - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                - Assumptions made:                  - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                - Trust relations used: None</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">        - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          - Assumptions made:            - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{1}</span>
<span class="s2">    - e_{2}</span>
<span class="s2">    - l</span>
<span class="s2">    - s</span>
<span class="s2">    - c</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small></span></pre><p>We can also combine existing trees into new trees, when appropriate. For example:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk26"><span class="kn">Definition</span> <span class="nf">concreteProofTreeExampleWith3ConjunctsUsingExistingTree</span> : 
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk27"><span class="nb">epose proof</span> (and_intro) P (C1 /\&#39; C2) C3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk28"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk29"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk2a"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk2b"><span class="bp">exact</span> concreteProofTreeExampleWith2Conjuncts.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk2c"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="kr">let</span> <span class="nv">H</span> := and_intro P (C1 /\&#39; C2) C3 <span class="kr">in</span>
 H concreteProofTreeExampleWith2Conjuncts <span class="nl">?Goal</span>)</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2) -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3 -&gt;
proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume c).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk2d"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith3Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in C_{1} \wedge C_{2} $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in C_{1} \wedge C_{2} \wedge C_{3} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk2e"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith3Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Penelope uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $l$ which Penelope uses, and claim 2 is supported by $s$ which Penelope uses then (claim 1 and claim 2) is supported by $(l, s)$ which Penelope uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $l$ which Penelope uses then claim 1 is supported by $l$ which Penelope uses, because</span>
<span class="s2">    - claim 1 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">    - Assuming claim 2 is supported by $s$ which Penelope uses then claim 2 is supported by $s$ which Penelope uses, because</span>
<span class="s2">    - claim 2 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for &#39;and&#39;.</span>
<span class="s2">  - Assuming claim 3 is supported by $c$ which Penelope uses then claim 3 is supported by $c$ which Penelope uses, because</span>
<span class="s2">  - claim 3 is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">- by a logical rule for &#39;and&#39;.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk2f"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith3Conjuncts.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that ((claim 1 and claim 2) and claim 3) is held by Penelope</span>
<span class="s2">  - ((claim 1 and claim 2) and claim 3) is held by Penelope by the evidence $((l, s), c)$</span>
<span class="s2">    - Assumptions made:      - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">      - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">      - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">    - Trust relations used: None</span>
<span class="s2">    - Logical rule used: and introduction</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - (claim 1 and claim 2) is held by Penelope by the evidence $(l, s)$</span>
<span class="s2">          - Assumptions made:            - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">            - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: and introduction</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                - Assumptions made:                  - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                - Trust relations used: None</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">              - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                - Assumptions made:                  - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                - Trust relations used: None</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">        - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          - Assumptions made:            - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{1}</span>
<span class="s2">    - e_{2}</span>
<span class="s2">    - l</span>
<span class="s2">    - s</span>
<span class="s2">    - c</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk30"><span class="kn">Definition</span> <span class="nf">concreteProofTreeExampleTrust</span> : 
proofTreeOf\<span class="bp">by</span> a1 \<span class="kr">in</span> (C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> a1 \<span class="kr">in</span> C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk31"><span class="nb">apply</span> (trust a1 a2 C trustT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> a2 \<span class="kr">in</span> C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume e).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk32"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleTrust).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{2}} \in C \vdash_{} e^{a_{2}} \in C $} \AxiomC{$a_{1}Ta_{2}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e^{a_{2}} \in C \vdash_{T} e^{a_{1}} \in C $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk33"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleTrust).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim c is supported by $e$ which actor 2 uses then claim c is supported by $e$ which actor 1 uses, because</span>
<span class="s2">  - Assuming claim c is supported by $e$ which actor 2 uses then claim c is supported by $e$ which actor 2 uses, because</span>
<span class="s2">  - claim c is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">- by the trust relation trust relation T.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk34"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleTrust.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that claim c is held by actor 1</span>
<span class="s2">  - claim c is held by actor 1 by the evidence $e$</span>
<span class="s2">    - Assumptions made:      - claim c is held by actor 2 by the evidence $e$</span>
<span class="s2">    - Trust relations used:      - trust relation T</span>
<span class="s2">    - Logical rule used: trust, with relation trust relation T</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - claim c is held by actor 2 by the evidence $e$</span>
<span class="s2">          - Assumptions made:            - claim c is held by actor 2 by the evidence $e$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk35"><span class="kn">Definition</span> <span class="nf">concreteProofTreeExampleWith3ConjunctsWithTrust</span> : 
proofTreeOf\<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk36"><span class="nb">eapply</span> (trust _ _ _ trustU).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?a2</span> \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concreteProofTreeExampleWith3ConjunctsUsingExistingTree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk37"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith3ConjunctsWithTrust).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in C_{1} \wedge C_{2} $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in C_{1} \wedge C_{2} \wedge C_{3} $} \AxiomC{$QUP$}  \RightLabel{ $ trust\ U$} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{U} ((l, s), c)^{Q} \in C_{1} \wedge C_{2} \wedge C_{3} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small><span class="alectryon-wsp"> </span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk38"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith3ConjunctsWithTrust).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Quintin uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Penelope uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $l$ which Penelope uses, and claim 2 is supported by $s$ which Penelope uses then (claim 1 and claim 2) is supported by $(l, s)$ which Penelope uses, because</span>
<span class="s2">      - Assuming claim 1 is supported by $l$ which Penelope uses then claim 1 is supported by $l$ which Penelope uses, because</span>
<span class="s2">      - claim 1 is a veracity claim.</span>
<span class="s2">      - by assumption.</span>
<span class="s2">      - Assuming claim 2 is supported by $s$ which Penelope uses then claim 2 is supported by $s$ which Penelope uses, because</span>
<span class="s2">      - claim 2 is a veracity claim.</span>
<span class="s2">      - by assumption.</span>
<span class="s2">    - by a logical rule for &#39;and&#39;.</span>
<span class="s2">    - Assuming claim 3 is supported by $c$ which Penelope uses then claim 3 is supported by $c$ which Penelope uses, because</span>
<span class="s2">    - claim 3 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for &#39;and&#39;.</span>
<span class="s2">- by the trust relation trust relation U.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk39"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith3ConjunctsWithTrust.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that ((claim 1 and claim 2) and claim 3) is held by Quintin</span>
<span class="s2">  - ((claim 1 and claim 2) and claim 3) is held by Quintin by the evidence $((l, s), c)$</span>
<span class="s2">    - Assumptions made:      - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">      - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">      - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">    - Trust relations used:      - trust relation U</span>
<span class="s2">    - Logical rule used: trust, with relation trust relation U</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - ((claim 1 and claim 2) and claim 3) is held by Penelope by the evidence $((l, s), c)$</span>
<span class="s2">          - Assumptions made:            - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">            - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">            - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: and introduction</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - (claim 1 and claim 2) is held by Penelope by the evidence $(l, s)$</span>
<span class="s2">                - Assumptions made:                  - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                  - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                - Trust relations used: None</span>
<span class="s2">                - Logical rule used: and introduction</span>
<span class="s2">                  - Sub-proofs:</span>
<span class="s2">                    - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                      - Assumptions made:                        - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                      - Trust relations used: None</span>
<span class="s2">                      - Logical rule used: we assume this</span>
<span class="s2">                    - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                      - Assumptions made:                        - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                      - Trust relations used: None</span>
<span class="s2">                      - Logical rule used: we assume this</span>
<span class="s2">              - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">                - Assumptions made:                  - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">                - Trust relations used: None</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e</span>
<span class="s2">    - e_{1}</span>
<span class="s2">    - e_{2}</span>
<span class="s2">    - l</span>
<span class="s2">    - s</span>
<span class="s2">    - c</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk3a"><span class="kn">Definition</span> <span class="nf">concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras</span> : 
proofTreeOf\<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk3b"><span class="nb">eapply</span> (trust Q Q _ trustU).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk3c"><span class="nb">eapply</span> (trust Q Q _ trustV).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk3d"><span class="nb">eapply</span> (trust _ _ _ trustU).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?a2</span> \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concreteProofTreeExampleWith3ConjunctsUsingExistingTree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk3e"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(trust Q Q (C1 /\&#39; C2 /\&#39; C3) trustU
   (trust Q Q (C1 /\&#39; C2 /\&#39; C3) trustV
      (trust Q P (C1 /\&#39; C2 /\&#39; C3) trustU
         concreteProofTreeExampleWith3ConjunctsUsingExistingTree)))</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk3f"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in C_{1} \wedge C_{2} $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in C_{1} \wedge C_{2} \wedge C_{3} $} \AxiomC{$QUP$}  \RightLabel{ $ trust\ U$} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{U} ((l, s), c)^{Q} \in C_{1} \wedge C_{2} \wedge C_{3} $} \AxiomC{$QVQ$}  \RightLabel{ $ trust\ V$} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{V, U} ((l, s), c)^{Q} \in C_{1} \wedge C_{2} \wedge C_{3} $} \AxiomC{$QUQ$}  \RightLabel{ $ trust\ U$} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{V, U} ((l, s), c)^{Q} \in C_{1} \wedge C_{2} \wedge C_{3} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small><span class="alectryon-wsp"> </span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk40"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Quintin uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Quintin uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Quintin uses, because</span>
<span class="s2">      - Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Penelope uses, because</span>
<span class="s2">        - Assuming claim 1 is supported by $l$ which Penelope uses, and claim 2 is supported by $s$ which Penelope uses then (claim 1 and claim 2) is supported by $(l, s)$ which Penelope uses, because</span>
<span class="s2">          - Assuming claim 1 is supported by $l$ which Penelope uses then claim 1 is supported by $l$ which Penelope uses, because</span>
<span class="s2">          - claim 1 is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">          - Assuming claim 2 is supported by $s$ which Penelope uses then claim 2 is supported by $s$ which Penelope uses, because</span>
<span class="s2">          - claim 2 is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">        - by a logical rule for &#39;and&#39;.</span>
<span class="s2">        - Assuming claim 3 is supported by $c$ which Penelope uses then claim 3 is supported by $c$ which Penelope uses, because</span>
<span class="s2">        - claim 3 is a veracity claim.</span>
<span class="s2">        - by assumption.</span>
<span class="s2">      - by a logical rule for &#39;and&#39;.</span>
<span class="s2">    - by the trust relation trust relation U.</span>
<span class="s2">  - by the trust relation trust relation V.</span>
<span class="s2">- by the trust relation trust relation U.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk41"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that ((claim 1 and claim 2) and claim 3) is held by Quintin</span>
<span class="s2">  - ((claim 1 and claim 2) and claim 3) is held by Quintin by the evidence $((l, s), c)$</span>
<span class="s2">    - Assumptions made:      - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">      - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">      - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">    - Trust relations used:      - trust relation V</span>
<span class="s2">      - trust relation U</span>
<span class="s2">    - Logical rule used: trust, with relation trust relation U</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - ((claim 1 and claim 2) and claim 3) is held by Quintin by the evidence $((l, s), c)$</span>
<span class="s2">          - Assumptions made:            - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">            - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">            - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          - Trust relations used:            - trust relation V</span>
<span class="s2">            - trust relation U</span>
<span class="s2">          - Logical rule used: trust, with relation trust relation V</span>
<span class="s2">            - Sub-proof:</span>
<span class="s2">              - ((claim 1 and claim 2) and claim 3) is held by Quintin by the evidence $((l, s), c)$</span>
<span class="s2">                - Assumptions made:                  - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                  - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                  - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">                - Trust relations used:                  - trust relation U</span>
<span class="s2">                - Logical rule used: trust, with relation trust relation U</span>
<span class="s2">                  - Sub-proof:</span>
<span class="s2">                    - ((claim 1 and claim 2) and claim 3) is held by Penelope by the evidence $((l, s), c)$</span>
<span class="s2">                      - Assumptions made:                        - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                        - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                        - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">                      - Trust relations used: None</span>
<span class="s2">                      - Logical rule used: and introduction</span>
<span class="s2">                        - Sub-proofs:</span>
<span class="s2">                          - (claim 1 and claim 2) is held by Penelope by the evidence $(l, s)$</span>
<span class="s2">                            - Assumptions made:                              - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                              - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                            - Trust relations used: None</span>
<span class="s2">                            - Logical rule used: and introduction</span>
<span class="s2">                              - Sub-proofs:</span>
<span class="s2">                                - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                                  - Assumptions made:                                    - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                                  - Trust relations used: None</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">                                - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                                  - Assumptions made:                                    - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                                  - Trust relations used: None</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">                          - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">                            - Assumptions made:                              - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">                            - Trust relations used: None</span>
<span class="s2">                            - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e</span>
<span class="s2">    - e_{1}</span>
<span class="s2">    - e_{2}</span>
<span class="s2">    - l</span>
<span class="s2">    - s</span>
<span class="s2">    - c</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">proofTreeOfClaim</span> (<span class="nv">c</span> : claim) := {
  _a : actor;
  _p : proofTreeOf(\<span class="bp">by</span> _a \<span class="kr">in</span> c)
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForProofTree_proofTreeOfClaim_instance</span> (<span class="nv">c</span> : claim) : ShowForProofTree (proofTreeOfClaim c) := { showForProofTree p := showForProofTree (_p c p) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForNaturalLanguage_proofTreeOfClaim_instance</span> (<span class="nv">c</span> : claim) : ShowForNaturalLanguage (proofTreeOfClaim c) := { showForNaturalLanguage p := showForNaturalLanguage (_p c p) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForLogSeq_proofTreeOfClaim_instance</span> (<span class="nv">c</span> : claim) : ShowForLogSeq (proofTreeOfClaim c) := { showForLogSeq p := showForLogSeq (_p c p) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk42"><span class="kn">Definition</span> <span class="nf">exampleWithProofOf</span> : proofTreeOfClaim C1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOfClaim C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk43"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOfClaim C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk44"><span class="nb">eexists</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume e1 a1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk45"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree exampleWithProofOf.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk46"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForNaturalLanguage exampleWithProofOf.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $e_{1}$ which actor 1 uses then claim 1 is supported by $e_{1}$ which actor 1 uses, because</span>
<span class="s2">- claim 1 is a veracity claim.</span>
<span class="s2">- by assumption.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk47"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq exampleWithProofOf.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that claim 1 is held by actor 1</span>
<span class="s2">  - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">    - Assumptions made:      - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">    - Trust relations used: None</span>
<span class="s2">    - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{1}</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">CQ</span> := AtomicClaim _cQ_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">aQ</span> := Actor _aQ_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eQ</span> := AtomicEvid _eQ_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk48"><span class="kn">Definition</span> <span class="nf">usingAll</span> : <span class="kr">forall</span> <span class="nv">a</span>, proofTreeOfClaim (Implies a _|_ C1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : actor, proofTreeOfClaim (Implies a _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : actor, proofTreeOfClaim (Implies a _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk4a"><span class="nb">eexists</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> (Implies a _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk4b"><span class="nb">eapply</span> (or_elim1 _ _ C2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> (Implies a _|_ C1 \/&#39; C2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk4c"><span class="nb">eapply</span> or_intro1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> (Implies a _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk4d"><span class="nb">eapply</span> (or_elim2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> (<span class="nl">?C1</span> \/&#39; Implies a _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk4e"><span class="nb">eapply</span> or_intro2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> (Implies a _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk4f"><span class="nb">eapply</span> and_elim1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> (Implies a _|_ C1 /\&#39; <span class="nl">?C2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk50"><span class="nb">eapply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> (Implies a _|_ C1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk51"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> <span class="nl">?C2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk52"><span class="nb">eapply</span> and_elim2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> (<span class="nl">?C10</span> /\&#39; Implies a _|_ C1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk53"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> <span class="nl">?C2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk54"><span class="nb">eapply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> <span class="nl">?C10</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk55" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk55"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> (Implies a _|_ C1)</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk56"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> <span class="nl">?C2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk57"><span class="nb">apply</span> (assume e2 a1); <span class="nb">apply</span> leaf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies a _|_ C1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk58"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> a1 \<span class="kr">in</span> <span class="nl">?C2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk59"><span class="mi">2</span>: <span class="nb">apply</span> (assume e2 a1); <span class="nb">apply</span> leaf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies a _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk5a"><span class="nb">eapply</span> (trust _ _ _ trustT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?a2</span> \<span class="kr">in</span> (Implies a _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk5b"><span class="nb">eapply</span> (impl_intro e2 _|_ a a1 C1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> a1 \<span class="kr">in</span> C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk5c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> a1 \<span class="kr">in</span> C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk5d"><span class="nb">eapply</span> bot_elim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> a1 \<span class="kr">in</span> _|_</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume e2 a1 _|_).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk5e"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">claim</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk5f"><hr></label><div class="goal-conclusion">claim</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk60"><hr></label><div class="goal-conclusion">claim</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk61"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="kr">fun</span> <span class="nv">a</span> : actor =&gt;
 {|
   _a := a1;
   _p :=
     or_elim1 a1 (Implies a _|_ C1) C2
       (or_intro1 a1 (Implies a _|_ C1) C2
          (or_elim2 a1 <span class="nl">?C1</span> (Implies a _|_ C1)
             (or_intro2 a1 <span class="nl">?C1</span> (Implies a _|_ C1)
                (and_elim1 a1 (Implies a _|_ C1) <span class="nl">?C2</span>
                   (and_intro a1 (Implies a _|_ C1)
                      <span class="nl">?C2</span>
                      (and_elim2 a1 <span class="nl">?C10</span>
                         (Implies a _|_ C1)
                         (and_intro a1 <span class="nl">?C10</span>
                            (Implies a _|_ C1)
                            (assume e2 a1 <span class="nl">?C10</span>)
                            (trust a1 a1
                               (Implies a _|_ C1)
                               trustT
                               (impl_intro e2 _|_ a a1
                                  C1
                                  (bot_elim a1 C1 ...
                                   :
                                   proofTreeOf ...)))))
                      (assume e2 a1 <span class="nl">?C2</span>))))))
 |})</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">claim</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk62" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk62"><hr></label><div class="goal-conclusion">claim</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>actor</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk63"><hr></label><div class="goal-conclusion">claim</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">apply</span> C2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk64"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree (usingAll aQ).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{} e_{2}^{a_{1}} \in C_{2} $}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{2}^{a_{1}} \in \bot \vdash_{} e_{2}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{2}^{a_{1}} \in \bot \vdash_{} e_{2}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda (e_{2})(e_{2})^{a_{1}} \in \bot \rightarrow_{}a_{?} C_{1} $} \AxiomC{$a_{1}Ta_{1}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ \lambda (e_{2})(e_{2})^{a_{1}} \in \bot \rightarrow_{}a_{?} C_{1} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{T} (e_{2}, \lambda (e_{2})(e_{2}))^{a_{1}} \in C_{2} \wedge \bot \rightarrow_{}a_{?} C_{1} $} \RightLabel{ $ \land^{-2} $} \UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{T} \lambda (e_{2})(e_{2})^{a_{1}} \in \bot \rightarrow_{}a_{?} C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{} e_{2}^{a_{1}} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{T} (\lambda (e_{2})(e_{2}), e_{2})^{a_{1}} \in \bot \rightarrow_{}a_{?} C_{1} \wedge C_{2} $} \RightLabel{ $ \land^{-1} $} \UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{T} \lambda (e_{2})(e_{2})^{a_{1}} \in \bot \rightarrow_{}a_{?} C_{1} $} \RightLabel{ $ \lor^{+2} $} \UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{T} j(\lambda (e_{2})(e_{2}))^{a_{1}} \in C_{2} \vee \bot \rightarrow_{}a_{?} C_{1} $} \RightLabel{ $ \lor^{-2} $} \UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{T} \lambda (e_{2})(e_{2})^{a_{1}} \in \bot \rightarrow_{}a_{?} C_{1} $} \RightLabel{ $ \lor^{+1} $} \UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{T} i(\lambda (e_{2})(e_{2}))^{a_{1}} \in \bot \rightarrow_{}a_{?} C_{1} \vee C_{2} $} \RightLabel{ $ \lor^{-1} $} \UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{T} \lambda (e_{2})(e_{2})^{a_{1}} \in \bot \rightarrow_{}a_{?} C_{1} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk65"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForNaturalLanguage usingAll.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForNaturalLanguage</span>) :=
     <span class="nl">?ShowForNaturalLanguage</span> <span class="kr">in</span>
   showForNaturalLanguage)
    (<span class="kr">fun</span> <span class="nv">a</span> : actor =&gt;
     {|
       _a := Actor _a1_;
       _p :=
         or_elim1 (Actor _a1_)
           (Implies a _|_ (AtomicClaim _c1_))
           (AtomicClaim _c2_)
           (or_intro1 (Actor _a1_)
              (Implies a _|_ (AtomicClaim _c1_))
              (AtomicClaim _c2_)
              (or_elim2 (Actor _a1_)
                 (AtomicClaim _c2_)
                 (Implies a _|_
                    (AtomicClaim _c1_))
                 (or_intro2 (Actor _a1_)
                    (AtomicClaim _c2_)
                    (Implies a _|_
                       (AtomicClaim _c1_))
                    (and_elim1 (Actor _a1_)
                       (Implies a _|_
                          (AtomicClaim _c1_))
                       (AtomicClaim _c2_)
                       (and_intro (Actor _a1_)
                          (Implies a _|_
                             (AtomicClaim _c1_))
                          (AtomicClaim _c2_)
                          (and_elim2 (Actor _a1_)
                             (AtomicClaim _c2_)
                             (Implies a _|_
                                (AtomicClaim _c1_))
                             (and_intro
                                (Actor _a1_)
                                (AtomicClaim _c2_)
                                (Implies a _|_
                                   (AtomicClaim
                                      _c1_))
                                (assume
                                   (AtomicEvid
                                      _e2_)
                                   (Actor _a1_)
                                   (AtomicClaim
                                      _c2_))
                                (trust
                                   (Actor _a1_)
                                   (Actor _a1_)
                                   (Implies a _|_
                                      (AtomicClaim
                                         _c1_))
                                   (Trust _T_)
                                   (impl_intro
                                      (AtomicEvid
                                         _e2_)
                                      _|_ a
                                      (Actor _a1_)
                                      (AtomicClaim
                                         _c1_)
                                      (bot_elim
                                         ... ...
                                         ...)))))
                          (assume
                             (AtomicEvid _e2_)
                             (Actor _a1_)
                             (AtomicClaim _c2_)))))))
     |})
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk66"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq usingAll.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForLogSeq</span>) := <span class="nl">?ShowForLogSeq</span> <span class="kr">in</span>
   showForLogSeq)
    (<span class="kr">fun</span> <span class="nv">a</span> : actor =&gt;
     {|
       _a := Actor _a1_;
       _p :=
         or_elim1 (Actor _a1_)
           (Implies a _|_ (AtomicClaim _c1_))
           (AtomicClaim _c2_)
           (or_intro1 (Actor _a1_)
              (Implies a _|_ (AtomicClaim _c1_))
              (AtomicClaim _c2_)
              (or_elim2 (Actor _a1_)
                 (AtomicClaim _c2_)
                 (Implies a _|_
                    (AtomicClaim _c1_))
                 (or_intro2 (Actor _a1_)
                    (AtomicClaim _c2_)
                    (Implies a _|_
                       (AtomicClaim _c1_))
                    (and_elim1 (Actor _a1_)
                       (Implies a _|_
                          (AtomicClaim _c1_))
                       (AtomicClaim _c2_)
                       (and_intro (Actor _a1_)
                          (Implies a _|_
                             (AtomicClaim _c1_))
                          (AtomicClaim _c2_)
                          (and_elim2 (Actor _a1_)
                             (AtomicClaim _c2_)
                             (Implies a _|_
                                (AtomicClaim _c1_))
                             (and_intro
                                (Actor _a1_)
                                (AtomicClaim _c2_)
                                (Implies a _|_
                                   (AtomicClaim
                                      _c1_))
                                (assume
                                   (AtomicEvid
                                      _e2_)
                                   (Actor _a1_)
                                   (AtomicClaim
                                      _c2_))
                                (trust
                                   (Actor _a1_)
                                   (Actor _a1_)
                                   (Implies a _|_
                                      (AtomicClaim
                                         _c1_))
                                   (Trust _T_)
                                   (impl_intro
                                      (AtomicEvid
                                         _e2_)
                                      _|_ a
                                      (Actor _a1_)
                                      (AtomicClaim
                                         _c1_)
                                      (bot_elim
                                         ... ...
                                         ...)))))
                          (assume
                             (AtomicEvid _e2_)
                             (Actor _a1_)
                             (AtomicClaim _c2_)))))))
     |})
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">proveClaim</span> := 
<span class="c">(* unshelve eexists _ _ _; *)</span>
(<span class="kp">repeat</span> ( 
<span class="kp">idtac</span>
<span class="c">(* + unshelve eapply or_elim1 *)</span>
<span class="c">(* + unshelve eapply hole *)</span>
+ <span class="nb">unshelve</span> <span class="nb">eapply</span> or_intro1
<span class="c">(* + unshelve eapply or_elim2 *)</span>
+ <span class="nb">unshelve</span> <span class="nb">eapply</span> or_intro2
<span class="c">(* + unshelve eapply and_elim1 *)</span>
+ <span class="nb">unshelve</span> <span class="nb">eapply</span> and_intro
<span class="c">(* + unshelve eapply and_elim2 *)</span>
+ <span class="nb">unshelve</span> <span class="nb">eapply</span> and_intro; <span class="nb">simpl</span>
+ <span class="nb">unshelve</span> <span class="nb">apply</span> assume
<span class="c">(* + unshelve eapply (trust _ _ _ _ _ (Trust &quot;T&quot;)) *)</span>
+ <span class="nb">unshelve</span> <span class="nb">eapply</span> (impl_intro)
+ <span class="nb">simpl</span>
+ <span class="nb">unshelve</span> <span class="nb">eapply</span> bot_elim));
<span class="kp">repeat</span> (<span class="nb">apply</span> a1
+ <span class="nb">apply</span> C2
+ <span class="nb">apply</span> e2
+ <span class="nb">apply</span> [])
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk67"><span class="kn">From</span> <span class="kn">Ltac2</span> <span class="kn">Require Import</span> <span class="kn">Ltac2</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Use of ‚Äú<span class="kn">Require</span>‚Äù <span class="kn">inside</span> a section <span class="kr">is</span> fragile. It <span class="kr">is</span>
not recommended to use this functionality <span class="kr">in</span> finished
proof scripts. [require-<span class="kr">in</span>-section,fragile]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Ltac2 maybePrintMessage1 s := Message.print (Message.of_string s). *)</span>
<span class="c">(* Ltac2 maybePrintMessage2 s := Message.print (Message.of_string s). *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2</span> maybePrintMessage1 s := ().</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2</span> maybePrintMessage2 s := ().</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2 Type</span> exn ::= [ VeracityProofSearchException(string) ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2</span> tryAssumeWitha1 etc :=
(maybePrintMessage1 <span class="s2">&quot;Trying assume&quot;</span>);
<span class="kr">match! goal with</span>
   | [ |- proofTreeOf _ ] =&gt; (maybePrintMessage2 <span class="s2">&quot;Applying assume&quot;</span>); <span class="nb">eapply</span> (assume _ a1); etc
   | [ |- _ ] =&gt; Control.zero (VeracityProofSearchException <span class="s2">&quot;Didn&#39;t match&quot;</span>)
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2</span> tryAndIntro etc :=
(maybePrintMessage1 <span class="s2">&quot;Trying and_intro&quot;</span>);
<span class="kr">match! goal with</span>
   | [ |- (proofTreeOf _ \<span class="bp">by</span> _ \<span class="kr">in</span> (_ /\&#39; _)) ] =&gt; (maybePrintMessage2 <span class="s2">&quot;Applying and_intro&quot;</span>); <span class="nb">eapply</span> and_intro; Control.enter (<span class="kr">fun</span> <span class="nv">_</span> =&gt; etc)
   | [ |- _ ] =&gt; Control.zero (VeracityProofSearchException <span class="s2">&quot;Didn&#39;t match&quot;</span>)
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2</span> tryTrust etc :=
(maybePrintMessage1 <span class="s2">&quot;Trying trust&quot;</span>);
<span class="kr">match! goal with</span>
   | [ |- proofTreeOf _ ] =&gt; (maybePrintMessage2 <span class="s2">&quot;Applying trust&quot;</span>); (<span class="nb">eapply</span> (trust _ _ _ _ _ _)); etc
   | [ |- _ ] =&gt; Control.zero (VeracityProofSearchException <span class="s2">&quot;Didn&#39;t match&quot;</span>)
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2</span> fillConstant () :=
<span class="kp">solve</span> [ <span class="nb">apply</span> CQ | <span class="nb">apply</span> aQ | <span class="nb">apply</span> eQ | <span class="nb">apply</span> ([] : list judgement) | <span class="nb">apply</span> (Trust T) ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kt">Set</span> Default <span class="kn">Proof</span> Mode <span class="s2">&quot;Ltac2&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Set Ltac2 Backtrace. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2 rec</span> autoProveMain max_depth :=
<span class="kr">match</span> Int.equal <span class="mi">0</span> max_depth <span class="kr">with</span>
  | true =&gt; Control.zero (VeracityProofSearchException (<span class="s2">&quot;Ran out of depth.&quot;</span>))
  <span class="c">(* | true =&gt; () *)</span>
  | false =&gt; <span class="kp">solve</span> [
      <span class="nb">eapply</span> and_intro; autoProveMain (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume eQ a1); autoProveMain (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (trust _ _ _); autoProveMain (Int.sub max_depth <span class="mi">1</span>)
    | fillConstant (); autoProveMain (Int.sub max_depth <span class="mi">1</span>)
  ]
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2 rec</span> autoProveHelper d :=
 Message.print (Message.of_string <span class="s2">&quot;Depth:&quot;</span>);
 Message.print (Message.of_int d);
 <span class="kp">solve</span> [ autoProveMain d | autoProveHelper (Int.add d <span class="mi">1</span>) ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2</span> autoProve () := autoProveHelper <span class="mi">1</span>.</span></span></pre><p>The following demonstrates a constraing that the claim must be believed by actor 2, and we have constrained only assuming claims for actor 1 in the tactic.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk68"><span class="kn">Definition</span> <span class="nf">exampleC1</span> : proofTreeOfClaim (C2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOfClaim C2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOfClaim C2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk6a"><span class="nb">eexists</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> C2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk6b">autoProve ().</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">1</span></blockquote><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">2</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk6c"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{| _a := a1; _p := assume eQ a1 C2 |}</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk6d"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree exampleC1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{?}^{a_{1}} \in C_{2} \vdash_{} e_{?}^{a_{1}} \in C_{2} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk6e"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForNaturalLanguage exampleC1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 2 is supported by $e_{?}$ which actor 1 uses then claim 2 is supported by $e_{?}$ which actor 1 uses, because</span>
<span class="s2">- claim 2 is a veracity claim.</span>
<span class="s2">- by assumption.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk6f"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq exampleC1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that claim 2 is held by actor 1</span>
<span class="s2">  - claim 2 is held by actor 1 by the evidence $e_{?}$</span>
<span class="s2">    - Assumptions made:      - claim 2 is held by actor 1 by the evidence $e_{?}$</span>
<span class="s2">    - Trust relations used: None</span>
<span class="s2">    - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{?}</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kt">Set</span> Default <span class="kn">Proof</span> Mode <span class="s2">&quot;Ltac2&quot;</span>.</span></span></pre><p>The following demonstrates automatically proving a larger claim.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(*  *)</span>
<span class="c">(* Set Default Goal Selector &quot;!&quot;. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk70"><span class="kn">Definition</span> <span class="nf">automatedProof</span> : proofTreeOfClaim (C1 /\&#39; C2 /\&#39; C3 /\&#39; C4 /\&#39; C5).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOfClaim (C1 /\&#39; C2 /\&#39; C3 /\&#39; C4 /\&#39; C5)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk71"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOfClaim (C1 /\&#39; C2 /\&#39; C3 /\&#39; C4 /\&#39; C5)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk72"><span class="nb">eexists</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3 /\&#39; C4 /\&#39; C5)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk73"><span class="kn">Time</span> autoProve ().  <span class="c">(* Finished transaction in 0.1 secs (0.099u,0.s) (successful) *)</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">1</span></blockquote><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">2</span></blockquote><blockquote class="alectryon-message">Finished transaction <span class="kr">in</span> <span class="mi">0</span>.<span class="mi">001</span> secs (<span class="mi">0</span>.<span class="mi">001</span>u,<span class="mi">0</span>.s) (successful)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Time autoProve (). Using match statements Finished transaction in 0.188 secs (0.181u,0.004s) (successful) *)</span>
<span class="c">(* Time autoProveMain 7. Finished transaction in 0.002 secs (0.002u,0.s) (successful) *)</span>
<span class="c">(* Time autoProveMain ().  Finished transaction in 1.503 secs (1.475u,0.s) (successful) *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk74"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{|
  _a := a1;
  _p := assume eQ a1 (C1 /\&#39; C2 /\&#39; C3 /\&#39; C4 /\&#39; C5)
|}</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk75"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree automatedProof.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{4} \wedge C_{5} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{?}^{a_{1}} \in C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{4} \wedge C_{5} \vdash_{} e_{?}^{a_{1}} \in C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{4} \wedge C_{5} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk76"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForNaturalLanguage automatedProof.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming ((((claim 1 and claim 2) and claim 3) and claim 4) and claim 5) is supported by $e_{?}$ which actor 1 uses then ((((claim 1 and claim 2) and claim 3) and claim 4) and claim 5) is supported by $e_{?}$ which actor 1 uses, because</span>
<span class="s2">- ((((claim 1 and claim 2) and claim 3) and claim 4) and claim 5) is a veracity claim.</span>
<span class="s2">- by assumption.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk77"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq automatedProof.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that ((((claim 1 and claim 2) and claim 3) and claim 4) and claim 5) is held by actor 1</span>
<span class="s2">  - ((((claim 1 and claim 2) and claim 3) and claim 4) and claim 5) is held by actor 1 by the evidence $e_{?}$</span>
<span class="s2">    - Assumptions made:      - ((((claim 1 and claim 2) and claim 3) and claim 4) and claim 5) is held by actor 1 by the evidence $e_{?}$</span>
<span class="s2">    - Trust relations used: None</span>
<span class="s2">    - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{?}</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2 rec</span> autoProveMain1 max_depth :=
<span class="kr">match</span> Int.equal <span class="mi">0</span> max_depth <span class="kr">with</span>
  | true =&gt; Control.zero (VeracityProofSearchException (<span class="s2">&quot;Ran out of depth.&quot;</span>))
  <span class="c">(* | true =&gt; () *)</span>
  | false =&gt; <span class="kp">solve</span> [
      <span class="nb">eapply</span> and_intro; autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (impl_intro); autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume l P C1); autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume s P C2); autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume c P C3); autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">simpl</span>; autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    <span class="c">(* | eapply (trust _ _ _ _ _ _); autoProveMain1 (Int.sub max_depth 1) *)</span>
    | fillConstant (); autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
  ]
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2 rec</span> autoProveHelper1 d :=
 Message.print (Message.of_string <span class="s2">&quot;Depth:&quot;</span>);
 Message.print (Message.of_int d);
 <span class="kp">solve</span> [ autoProveMain1 d | autoProveHelper1 (Int.add d <span class="mi">1</span>) ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2</span> autoProve1 () := autoProveHelper1 <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk78"><span class="kn">Definition</span> <span class="nf">fromPaper1</span> : proofTreeOfClaim (C1 /\&#39; C2 /\&#39; C3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOfClaim (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk79"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOfClaim (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk7a"><span class="nb">eexists</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?Goal</span> \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk7b">autoProve1 ().</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">1</span></blockquote><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">2</span></blockquote><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">3</span></blockquote><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">4</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk7c"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{|
  _a := P;
  _p :=
    and_intro P (C1 /\&#39; C2) C3
      (and_intro P C1 C2 (assume l P C1)
         (assume s P C2)) (assume c P C3)
|}</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk7d"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree fromPaper1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in C_{1} \wedge C_{2} $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in C_{1} \wedge C_{2} \wedge C_{3} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk7e"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForNaturalLanguage fromPaper1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Penelope uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $l$ which Penelope uses, and claim 2 is supported by $s$ which Penelope uses then (claim 1 and claim 2) is supported by $(l, s)$ which Penelope uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $l$ which Penelope uses then claim 1 is supported by $l$ which Penelope uses, because</span>
<span class="s2">    - claim 1 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">    - Assuming claim 2 is supported by $s$ which Penelope uses then claim 2 is supported by $s$ which Penelope uses, because</span>
<span class="s2">    - claim 2 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for &#39;and&#39;.</span>
<span class="s2">  - Assuming claim 3 is supported by $c$ which Penelope uses then claim 3 is supported by $c$ which Penelope uses, because</span>
<span class="s2">  - claim 3 is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">- by a logical rule for &#39;and&#39;.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk7f"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq fromPaper1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that ((claim 1 and claim 2) and claim 3) is held by Penelope</span>
<span class="s2">  - ((claim 1 and claim 2) and claim 3) is held by Penelope by the evidence $((l, s), c)$</span>
<span class="s2">    - Assumptions made:      - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">      - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">      - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">    - Trust relations used: None</span>
<span class="s2">    - Logical rule used: and introduction</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - (claim 1 and claim 2) is held by Penelope by the evidence $(l, s)$</span>
<span class="s2">          - Assumptions made:            - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">            - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: and introduction</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                - Assumptions made:                  - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                - Trust relations used: None</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">              - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                - Assumptions made:                  - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                - Trust relations used: None</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">        - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          - Assumptions made:            - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{1}</span>
<span class="s2">    - e_{2}</span>
<span class="s2">    - l</span>
<span class="s2">    - s</span>
<span class="s2">    - c</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">healthy</span> := AtomicClaim _healthy_ .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">nonToxic</span> := AtomicClaim _nonToxic_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">organic</span> := AtomicClaim _organic_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">belief</span> := AtomicEvid _belief_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">testing</span> := AtomicEvid _testing_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">audit</span> := AtomicEvid _audit_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">retailer</span> := Actor _retailer_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">vineyard</span> := Actor _vineyard_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">winery</span> := Actor _winery_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk80"><span class="kn">Definition</span> <span class="nf">exampleFromJosh</span> : proofTreeOfClaim healthy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOfClaim healthy</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk81"><span class="nb">eexists</span> retailer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> retailer \<span class="kr">in</span> healthy</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk82"><span class="nb">eapply</span> (impl_elim _ _ (nonToxic /\&#39; organic)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> retailer \<span class="kr">in</span>
  (Implies <span class="nl">?a1</span> (nonToxic /\&#39; organic) healthy)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk83"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?a1</span> \<span class="kr">in</span> (nonToxic /\&#39; organic)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk84"><span class="kp">try</span> (<span class="nb">eapply</span> (assume belief retailer (Implies _ (nonToxic /\&#39; organic) healthy))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?a1</span> \<span class="kr">in</span> (nonToxic /\&#39; organic)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk85"><span class="kp">try</span> (<span class="nb">apply</span> (assume testing vineyard nonToxic)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?a1</span> \<span class="kr">in</span> (nonToxic /\&#39; organic)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk86"><span class="kp">try</span> (<span class="nb">apply</span> (assume audit winery organic)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?a1</span> \<span class="kr">in</span> (nonToxic /\&#39; organic)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk87"><span class="nb">eapply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?a1</span> \<span class="kr">in</span> nonToxic</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk88" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk88"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?a1</span> \<span class="kr">in</span> organic</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk89"><span class="nb">eapply</span> (trust retailer vineyard _ trustT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> vineyard \<span class="kr">in</span> nonToxic</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk8a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk8a"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> retailer \<span class="kr">in</span> organic</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk8b"><span class="kp">try</span> (<span class="nb">apply</span> (assume belief retailer (Implies (nonToxic /\&#39; organic) healthy))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> vineyard \<span class="kr">in</span> nonToxic</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chk8c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chk8c"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> retailer \<span class="kr">in</span> organic</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk8d"><span class="kp">try</span> (<span class="nb">apply</span> (assume testing vineyard nonToxic)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> retailer \<span class="kr">in</span> organic</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk8e"><span class="kp">try</span> (<span class="nb">apply</span> (assume audit winery organic)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> retailer \<span class="kr">in</span> organic</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk8f"><span class="nb">eapply</span> (trust retailer winery _ trustT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> winery \<span class="kr">in</span> organic</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk90"><span class="kp">try</span> (<span class="nb">apply</span> (assume belief retailer (Implies (nonToxic /\&#39; organic) healthy))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> winery \<span class="kr">in</span> organic</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk91"><span class="kp">try</span> (<span class="nb">apply</span> (assume testing vineyard nonToxic)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> winery \<span class="kr">in</span> organic</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">try</span> (<span class="nb">apply</span> (assume audit winery organic)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk92"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{|
  _a := retailer;
  _p :=
    impl_elim retailer retailer (nonToxic /\&#39; organic)
      healthy
      (assume belief retailer
         (Implies retailer (nonToxic /\&#39; organic)
            healthy))
      (and_intro retailer nonToxic organic
         (trust retailer vineyard nonToxic trustT
            (assume testing vineyard nonToxic))
         (trust retailer winery organic trustT
            (assume audit winery organic)))
|}</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk93"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree exampleFromJosh.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ N \wedge O \rightarrow_{}r H \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ b^{r} \in N \wedge O \rightarrow_{}r H \vdash_{} b^{r} \in N \wedge O \rightarrow_{}r H $}\AxiomC{$ N \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ t^{v} \in N \vdash_{} t^{v} \in N $} \AxiomC{$rTv$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ t^{v} \in N \vdash_{T} t^{r} \in N $}\AxiomC{$ O \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ a^{w} \in O \vdash_{} a^{w} \in O $} \AxiomC{$rTw$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ a^{w} \in O \vdash_{T} a^{r} \in O $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ t^{v} \in N, a^{w} \in O \vdash_{T} (t, a)^{r} \in N \wedge O $} \RightLabel{ $ \rightarrow^{-}_{r} $} \BinaryInfC{$ b^{r} \in N \wedge O \rightarrow_{}r H, t^{v} \in N, a^{w} \in O \vdash_{T} b((t, a))^{r} \in H $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk94"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForNaturalLanguage exampleFromJosh.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming ((non-toxic and organic), believed by retailer, implies healthy) is supported by $b$ which retailer uses, non-toxic is supported by $t$ which vineyard uses, and organic is supported by $a$ which winery uses then healthy is supported by $b((t, a))$ which retailer uses, because</span>
<span class="s2">  - Assuming ((non-toxic and organic), believed by retailer, implies healthy) is supported by $b$ which retailer uses then ((non-toxic and organic), believed by retailer, implies healthy) is supported by $b$ which retailer uses, because</span>
<span class="s2">  - ((non-toxic and organic), believed by retailer, implies healthy) is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">  - Assuming non-toxic is supported by $t$ which vineyard uses, and organic is supported by $a$ which winery uses then (non-toxic and organic) is supported by $(t, a)$ which retailer uses, because</span>
<span class="s2">    - Assuming non-toxic is supported by $t$ which vineyard uses then non-toxic is supported by $t$ which retailer uses, because</span>
<span class="s2">      - Assuming non-toxic is supported by $t$ which vineyard uses then non-toxic is supported by $t$ which vineyard uses, because</span>
<span class="s2">      - non-toxic is a veracity claim.</span>
<span class="s2">      - by assumption.</span>
<span class="s2">    - by the trust relation trust relation T.</span>
<span class="s2">    - Assuming organic is supported by $a$ which winery uses then organic is supported by $a$ which retailer uses, because</span>
<span class="s2">      - Assuming organic is supported by $a$ which winery uses then organic is supported by $a$ which winery uses, because</span>
<span class="s2">      - organic is a veracity claim.</span>
<span class="s2">      - by assumption.</span>
<span class="s2">    - by the trust relation trust relation T.</span>
<span class="s2">  - by a logical rule for &#39;and&#39;.</span>
<span class="s2">- by a logical rule for implication.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk95"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq exampleFromJosh.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that healthy is held by retailer</span>
<span class="s2">  - healthy is held by retailer by the evidence $b((t, a))$</span>
<span class="s2">    - Assumptions made:      - ((non-toxic and organic), believed by retailer, implies healthy) is held by retailer by the evidence $b$</span>
<span class="s2">      - non-toxic is held by vineyard by the evidence $t$</span>
<span class="s2">      - organic is held by winery by the evidence $a$</span>
<span class="s2">    - Trust relations used:      - trust relation T</span>
<span class="s2">    - Logical rule used: implication elimination</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - ((non-toxic and organic), believed by retailer, implies healthy) is held by retailer by the evidence $b$</span>
<span class="s2">          - Assumptions made:            - ((non-toxic and organic), believed by retailer, implies healthy) is held by retailer by the evidence $b$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">        - (non-toxic and organic) is held by retailer by the evidence $(t, a)$</span>
<span class="s2">          - Assumptions made:            - non-toxic is held by vineyard by the evidence $t$</span>
<span class="s2">            - organic is held by winery by the evidence $a$</span>
<span class="s2">          - Trust relations used:            - trust relation T</span>
<span class="s2">          - Logical rule used: and introduction</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - non-toxic is held by retailer by the evidence $t$</span>
<span class="s2">                - Assumptions made:                  - non-toxic is held by vineyard by the evidence $t$</span>
<span class="s2">                - Trust relations used:                  - trust relation T</span>
<span class="s2">                - Logical rule used: trust, with relation trust relation T</span>
<span class="s2">                  - Sub-proof:</span>
<span class="s2">                    - non-toxic is held by vineyard by the evidence $t$</span>
<span class="s2">                      - Assumptions made:                        - non-toxic is held by vineyard by the evidence $t$</span>
<span class="s2">                      - Trust relations used: None</span>
<span class="s2">                      - Logical rule used: we assume this</span>
<span class="s2">              - organic is held by retailer by the evidence $a$</span>
<span class="s2">                - Assumptions made:                  - organic is held by winery by the evidence $a$</span>
<span class="s2">                - Trust relations used:                  - trust relation T</span>
<span class="s2">                - Logical rule used: trust, with relation trust relation T</span>
<span class="s2">                  - Sub-proof:</span>
<span class="s2">                    - organic is held by winery by the evidence $a$</span>
<span class="s2">                      - Assumptions made:                        - organic is held by winery by the evidence $a$</span>
<span class="s2">                      - Trust relations used: None</span>
<span class="s2">                      - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - b</span>
<span class="s2">    - e_{1}</span>
<span class="s2">    - e_{2}</span>
<span class="s2">    - t</span>
<span class="s2">    - e</span>
<span class="s2">    - a</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2 rec</span> autoProveMain2 max_depth :=
<span class="kr">match</span> Int.equal <span class="mi">0</span> max_depth <span class="kr">with</span>
  | true =&gt; Control.zero (VeracityProofSearchException (<span class="s2">&quot;Ran out of depth.&quot;</span>))
  <span class="c">(* | true =&gt; () *)</span>
  | false =&gt; <span class="kp">solve</span> [
      <span class="nb">eapply</span> and_intro; autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (impl_elim); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (trust retailer vineyard _ trustT); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (trust retailer winery _ trustT); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume testing vineyard nonToxic); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume belief retailer (Implies _ (nonToxic /\&#39; organic) healthy)); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume audit winery organic); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    <span class="c">(* | simpl; autoProveMain2 (Int.sub max_depth 1) *)</span>
    <span class="c">(* | eapply (trust _ _ _ _ _ _); autoProveMain2 (Int.sub max_depth 1) *)</span>
    | fillConstant (); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
  ]
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2 rec</span> autoProveHelper2 d max_depth :=
 Message.print (Message.of_string <span class="s2">&quot;Depth:&quot;</span>);
 Message.print (Message.of_int d);
 <span class="kr">match</span> Int.lt d max_depth <span class="kr">with</span>
 | true =&gt; <span class="kp">solve</span> [ autoProveMain2 d | autoProveHelper2 (Int.add d <span class="mi">1</span>) max_depth ]
 | false =&gt; Message.print(Message.of_string <span class="s2">&quot;Reached max depth, possibly unprovable by these tactics.&quot;</span>)
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac2</span> autoProve2 () := autoProveHelper2 <span class="mi">1</span> <span class="mi">20</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk96"><span class="kn">Definition</span> <span class="nf">exampleFromJoshAuto</span> : proofTreeOfClaim healthy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOfClaim healthy</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk97"><span class="nb">eexists</span> retailer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> retailer \<span class="kr">in</span> healthy</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk98"><span class="kn">Time</span> autoProve2 ().</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">1</span></blockquote><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">2</span></blockquote><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">3</span></blockquote><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">4</span></blockquote><blockquote class="alectryon-message">Depth:</blockquote><blockquote class="alectryon-message"><span class="mi">5</span></blockquote><blockquote class="alectryon-message">Finished transaction <span class="kr">in</span> <span class="mi">0</span>.<span class="mi">039</span> secs (<span class="mi">0</span>.<span class="mi">039</span>u,<span class="mi">0</span>.s) (successful)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk99"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{|
  _a := retailer;
  _p :=
    impl_elim retailer retailer (nonToxic /\&#39; organic)
      healthy
      (assume belief retailer
         (Implies retailer (nonToxic /\&#39; organic)
            healthy))
      (and_intro retailer nonToxic organic
         (trust retailer vineyard nonToxic trustT
            (assume testing vineyard nonToxic))
         (trust retailer winery organic trustT
            (assume audit winery organic)))
|}</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk9a"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree exampleFromJoshAuto.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ N \wedge O \rightarrow_{}r H \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ b^{r} \in N \wedge O \rightarrow_{}r H \vdash_{} b^{r} \in N \wedge O \rightarrow_{}r H $}\AxiomC{$ N \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ t^{v} \in N \vdash_{} t^{v} \in N $} \AxiomC{$rTv$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ t^{v} \in N \vdash_{T} t^{r} \in N $}\AxiomC{$ O \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ a^{w} \in O \vdash_{} a^{w} \in O $} \AxiomC{$rTw$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ a^{w} \in O \vdash_{T} a^{r} \in O $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ t^{v} \in N, a^{w} \in O \vdash_{T} (t, a)^{r} \in N \wedge O $} \RightLabel{ $ \rightarrow^{-}_{r} $} \BinaryInfC{$ b^{r} \in N \wedge O \rightarrow_{}r H, t^{v} \in N, a^{w} \in O \vdash_{T} b((t, a))^{r} \in H $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** Ltac-less proof automation of Josh&#39;s example *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">exampleFromJoshProofStep</span> (<span class="nv">j</span> : judgementPart) : list (proofTreeOf j) :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | JudgementPart a c =&gt; 
    <span class="sd">(** Assumptions: *)</span>
    (<span class="kr">if</span> (a =? vineyard) &amp;&amp; (c =? nonToxic) <span class="kr">then</span> [assume testing a c] <span class="kr">else</span> [])
    ++
    (<span class="kr">if</span> (a =? retailer) &amp;&amp; (c =? (Implies a (nonToxic /\&#39; organic) healthy)) <span class="kr">then</span> [assume belief a c] <span class="kr">else</span> [])
    ++
    (<span class="kr">if</span> (a =? winery) &amp;&amp; (c =? organic) <span class="kr">then</span> [assume audit a c] <span class="kr">else</span> [])
    ++
    <span class="sd">(** Trust relations: *)</span>
    (<span class="kr">if</span> (a =? retailer) <span class="kr">then</span> [trust a vineyard c trustT (hole _); trust a winery c T (hole _)] <span class="kr">else</span> [])
    ++
    <span class="sd">(** Implication elimination: *)</span>
    (<span class="kr">if</span> (a =? retailer) &amp;&amp; (c =? healthy) <span class="kr">then</span> [impl_elim a a (nonToxic /\&#39; organic) c (hole _) (hole _)] <span class="kr">else</span> [])
    ++
    <span class="sd">(** Rules for specific claim patterns: *)</span>
    <span class="kr">match</span> c <span class="kr">with</span>
      <span class="sd">(** The rules for And and Or can usually be left in. *)</span>
      | And C1 C2 =&gt; [and_intro a C1 C2 (hole _) (hole _)] 
      | Or C1 C2 =&gt; [or_intro1 a C1 C2 (hole _); or_intro2 a C1 C2 (hole _)]
      <span class="sd">(** The rules for Implies should echo the rules for assumptions, ideally. Or else involve eQ. *)</span>
      | Implies a1 C1 C2 =&gt;
          []
      | _ =&gt; []
      <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> beq_scope.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk9b"><span class="kn">Time</span> <span class="kn">Timeout</span> <span class="mi">5</span> <span class="kn">Eval</span> <span class="nb">vm_compute</span> <span class="kr">in</span> (showListForProofs (( (proofSearch exampleFromJoshProofStep _  [toProofTreeWithHole retailer healthy] <span class="mi">10</span>)))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ N \wedge O \rightarrow_{}r H \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ b^{r} \in N \wedge O \rightarrow_{}r H \vdash_{} b^{r} \in N \wedge O \rightarrow_{}r H $}\AxiomC{$ N \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ t^{v} \in N \vdash_{} t^{v} \in N $} \AxiomC{$rTv$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ t^{v} \in N \vdash_{T} t^{r} \in N $}\AxiomC{$ O \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ a^{w} \in O \vdash_{} a^{w} \in O $} \AxiomC{$rTw$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ a^{w} \in O \vdash_{T} a^{r} \in O $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ t^{v} \in N, a^{w} \in O \vdash_{T} (t, a)^{r} \in N \wedge O $} \RightLabel{ $ \rightarrow^{-}_{r} $} \BinaryInfC{$ b^{r} \in N \wedge O \rightarrow_{}r H, t^{v} \in N, a^{w} \in O \vdash_{T} b((t, a))^{r} \in H $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ N \wedge O \rightarrow_{}r H \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ b^{r} \in N \wedge O \rightarrow_{}r H \vdash_{} b^{r} \in N \wedge O \rightarrow_{}r H $}\AxiomC{$ N \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ t^{v} \in N \vdash_{} t^{v} \in N $} \AxiomC{$rTv$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ t^{v} \in N \vdash_{T} t^{r} \in N $}\AxiomC{$ O \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ a^{w} \in O \vdash_{} a^{w} \in O $} \AxiomC{$rTw$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ a^{w} \in O \vdash_{T} a^{r} \in O $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ t^{v} \in N, a^{w} \in O \vdash_{T} (t, a)^{r} \in N \wedge O $} \RightLabel{ $ \rightarrow^{-}_{r} $} \BinaryInfC{$ b^{r} \in N \wedge O \rightarrow_{}r H, t^{v} \in N, a^{w} \in O \vdash_{T} b((t, a))^{r} \in H $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ N \wedge O \rightarrow_{}r H \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ b^{r} \in N \wedge O \rightarrow_{}r H \vdash_{} b^{r} \in N \wedge O \rightarrow_{}r H $}\AxiomC{$ N \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ t^{v} \in N \vdash_{} t^{v} \in N $} \AxiomC{$rTv$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ t^{v} \in N \vdash_{T} t^{r} \in N $}\AxiomC{$ O \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ a^{w} \in O \vdash_{} a^{w} \in O $} \AxiomC{$rTw$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ a^{w} \in O \vdash_{T} a^{r} \in O $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ t^{v} \in N, a^{w} \in O \vdash_{T} (t, a)^{r} \in N \wedge O $} \RightLabel{ $ \rightarrow^{-}_{r} $} \BinaryInfC{$ b^{r} \in N \wedge O \rightarrow_{}r H, t^{v} \in N, a^{w} \in O \vdash_{T} b((t, a))^{r} \in H $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ N \wedge O \rightarrow_{}r H \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ b^{r} \in N \wedge O \rightarrow_{}r H \vdash_{} b^{r} \in N \wedge O \rightarrow_{}r H $}\AxiomC{$ N \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ t^{v} \in N \vdash_{} t^{v} \in N $} \AxiomC{$rTv$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ t^{v} \in N \vdash_{T} t^{r} \in N $}\AxiomC{$ O \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ a^{w} \in O \vdash_{} a^{w} \in O $} \AxiomC{$rTw$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ a^{w} \in O \vdash_{T} a^{r} \in O $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ t^{v} \in N, a^{w} \in O \vdash_{T} (t, a)^{r} \in N \wedge O $} \RightLabel{ $ \rightarrow^{-}_{r} $} \BinaryInfC{$ b^{r} \in N \wedge O \rightarrow_{}r H, t^{v} \in N, a^{w} \in O \vdash_{T} b((t, a))^{r} \in H $}\end{prooftree}&quot;</span>
     : string</blockquote><blockquote class="alectryon-message">Finished transaction <span class="kr">in</span> <span class="mi">0</span>.<span class="mi">212</span> secs (<span class="mi">0</span>.<span class="mi">212</span>u,<span class="mi">0</span>.s) (successful)</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk9c"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage exampleFromJoshAuto).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming ((non-toxic and organic), believed by retailer, implies healthy) is supported by $b$ which retailer uses, non-toxic is supported by $t$ which vineyard uses, and organic is supported by $a$ which winery uses then healthy is supported by $b((t, a))$ which retailer uses, because</span>
<span class="s2">  - Assuming ((non-toxic and organic), believed by retailer, implies healthy) is supported by $b$ which retailer uses then ((non-toxic and organic), believed by retailer, implies healthy) is supported by $b$ which retailer uses, because</span>
<span class="s2">  - ((non-toxic and organic), believed by retailer, implies healthy) is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">  - Assuming non-toxic is supported by $t$ which vineyard uses, and organic is supported by $a$ which winery uses then (non-toxic and organic) is supported by $(t, a)$ which retailer uses, because</span>
<span class="s2">    - Assuming non-toxic is supported by $t$ which vineyard uses then non-toxic is supported by $t$ which retailer uses, because</span>
<span class="s2">      - Assuming non-toxic is supported by $t$ which vineyard uses then non-toxic is supported by $t$ which vineyard uses, because</span>
<span class="s2">      - non-toxic is a veracity claim.</span>
<span class="s2">      - by assumption.</span>
<span class="s2">    - by the trust relation trust relation T.</span>
<span class="s2">    - Assuming organic is supported by $a$ which winery uses then organic is supported by $a$ which retailer uses, because</span>
<span class="s2">      - Assuming organic is supported by $a$ which winery uses then organic is supported by $a$ which winery uses, because</span>
<span class="s2">      - organic is a veracity claim.</span>
<span class="s2">      - by assumption.</span>
<span class="s2">    - by the trust relation trust relation T.</span>
<span class="s2">  - by a logical rule for &#39;and&#39;.</span>
<span class="s2">- by a logical rule for implication.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk9d"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq exampleFromJoshAuto.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that healthy is held by retailer</span>
<span class="s2">  - healthy is held by retailer by the evidence $b((t, a))$</span>
<span class="s2">    - Assumptions made:      - ((non-toxic and organic), believed by retailer, implies healthy) is held by retailer by the evidence $b$</span>
<span class="s2">      - non-toxic is held by vineyard by the evidence $t$</span>
<span class="s2">      - organic is held by winery by the evidence $a$</span>
<span class="s2">    - Trust relations used:      - trust relation T</span>
<span class="s2">    - Logical rule used: implication elimination</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - ((non-toxic and organic), believed by retailer, implies healthy) is held by retailer by the evidence $b$</span>
<span class="s2">          - Assumptions made:            - ((non-toxic and organic), believed by retailer, implies healthy) is held by retailer by the evidence $b$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">        - (non-toxic and organic) is held by retailer by the evidence $(t, a)$</span>
<span class="s2">          - Assumptions made:            - non-toxic is held by vineyard by the evidence $t$</span>
<span class="s2">            - organic is held by winery by the evidence $a$</span>
<span class="s2">          - Trust relations used:            - trust relation T</span>
<span class="s2">          - Logical rule used: and introduction</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - non-toxic is held by retailer by the evidence $t$</span>
<span class="s2">                - Assumptions made:                  - non-toxic is held by vineyard by the evidence $t$</span>
<span class="s2">                - Trust relations used:                  - trust relation T</span>
<span class="s2">                - Logical rule used: trust, with relation trust relation T</span>
<span class="s2">                  - Sub-proof:</span>
<span class="s2">                    - non-toxic is held by vineyard by the evidence $t$</span>
<span class="s2">                      - Assumptions made:                        - non-toxic is held by vineyard by the evidence $t$</span>
<span class="s2">                      - Trust relations used: None</span>
<span class="s2">                      - Logical rule used: we assume this</span>
<span class="s2">              - organic is held by retailer by the evidence $a$</span>
<span class="s2">                - Assumptions made:                  - organic is held by winery by the evidence $a$</span>
<span class="s2">                - Trust relations used:                  - trust relation T</span>
<span class="s2">                - Logical rule used: trust, with relation trust relation T</span>
<span class="s2">                  - Sub-proof:</span>
<span class="s2">                    - organic is held by winery by the evidence $a$</span>
<span class="s2">                      - Assumptions made:                        - organic is held by winery by the evidence $a$</span>
<span class="s2">                      - Trust relations used: None</span>
<span class="s2">                      - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - b</span>
<span class="s2">    - e_{1}</span>
<span class="s2">    - e_{2}</span>
<span class="s2">    - t</span>
<span class="s2">    - e</span>
<span class="s2">    - a</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk9e"><span class="kn">Definition</span> <span class="nf">whiteboardExample</span> : proofTreeOfClaim (Implies a2 C1 C2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOfClaim (Implies a2 C1 C2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chk9f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOfClaim (Implies a2 C1 C2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chka0"><span class="nb">eexists</span> a2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> a2 \<span class="kr">in</span> (Implies a2 C1 C2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chka1"><span class="nb">eapply</span> (impl_intro e1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> a2 \<span class="kr">in</span> C2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chka2"><span class="nb">eapply</span> (trust a2 _ _ trustT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> <span class="nl">?a2</span> \<span class="kr">in</span> C2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> hole.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chka3"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">actor</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> a2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chka4"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree whiteboardExample.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$\textcolor{red}{\textcolor{red}{e_{?}}^{a_{2}} \in C_{2}}$} \AxiomC{$a_{2}Ta_{2}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ \textcolor{red}{e_{?}}^{a_{2}} \in C_{2} \vdash_{T} \textcolor{red}{e_{?}}^{a_{2}} \in C_{2} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda (e_{1})(\textcolor{red}{e_{?}})^{a_{2}} \in C_{1} \rightarrow_{}a_{2} C_{2} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chka5"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage whiteboardExample).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- (claim 1, believed by actor 2, implies claim 2) is supported by $\lambda (e_{1})(\textcolor{red}{e_{?}})$ which actor 2 uses, because</span>
<span class="s2">  - Assuming claim 2 is supported by $\textcolor{red}{e_{?}}$ which actor 2 uses then claim 2 is supported by $\textcolor{red}{e_{?}}$ which actor 2 uses, because</span>
<span class="s2">    - we stopped the proof at this point and assumed it was provable.</span>
<span class="s2">  - by the trust relation trust relation T.</span>
<span class="s2">- by a logical rule for implication.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chka6"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq whiteboardExample.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that (claim 1, believed by actor 2, implies claim 2) is held by actor 2</span>
<span class="s2">  - (claim 1, believed by actor 2, implies claim 2) is held by actor 2 by the evidence $\lambda (e_{1})(\textcolor{red}{e_{?}})$</span>
<span class="s2">    - Assumptions made: None</span>
<span class="s2">    - Trust relations used:      - trust relation T</span>
<span class="s2">    - Logical rule used: implication introduction</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - claim 2 is held by actor 2 by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">          - Assumptions made:            - claim 2 is held by actor 2 by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">          - Trust relations used:            - trust relation T</span>
<span class="s2">          - Logical rule used: trust, with relation trust relation T</span>
<span class="s2">            - Sub-proof:</span>
<span class="s2">              - We stopped the proof at this point and assumed it was provable.</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{1}</span>
<span class="s2">    - e_{2}</span>
<span class="s2">    - e</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">certifier</span> := Actor _certifier_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">applicant</span> := Actor _applicant_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ingredients_valid</span> := AtomicClaim _ingredients_valid_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">recipe_valid</span> := AtomicClaim _recipe_valid_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">percentage_ingredients_valid</span> := AtomicClaim _ingredients_valid_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">breakdown_of_formulations_valid</span> := AtomicClaim _breakdown_of_formulations_valid_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">successful_market_compliance_assessment</span> := AtomicClaim _successful_market_compliance_assessment_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">compile</span> := AtomicEvid _compile_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">review</span> := AtomicEvid _review_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">assess</span> := AtomicEvid _assess_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">percentage_ingredients_list</span> := AtomicEvid _ingredients_percentage_list_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">breakdown_of_formulations_list</span> := AtomicEvid _breakdown_of_formulations_list_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chka7"><span class="kn">Definition</span> <span class="nf">preAssessmentRequirements</span> : proofTreeOf (JudgementPart certifier recipe_valid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> certifier \<span class="kr">in</span> recipe_valid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chka8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> certifier \<span class="kr">in</span> recipe_valid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chka9"><span class="nb">eapply</span> (impl_elim applicant _ recipe_valid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> certifier \<span class="kr">in</span>
  (Implies applicant recipe_valid recipe_valid)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkaa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkaa"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> applicant \<span class="kr">in</span> recipe_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkab"><span class="nb">eapply</span> (assume review).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> applicant \<span class="kr">in</span> recipe_valid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkac"><span class="nb">eapply</span> (impl_elim applicant _ breakdown_of_formulations_valid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span>
  (Implies applicant breakdown_of_formulations_valid
     recipe_valid)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkad"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkae"><span class="nb">eapply</span> (impl_elim certifier _ ingredients_valid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span>
  (Implies certifier ingredients_valid
     (Implies applicant
        breakdown_of_formulations_valid recipe_valid))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkaf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkaf"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> certifier \<span class="kr">in</span> ingredients_valid</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkb0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkb0"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkb1"><span class="nb">eapply</span> (assume compile).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> certifier \<span class="kr">in</span> ingredients_valid</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkb2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkb2"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkb3"><span class="nb">eapply</span> (impl_elim applicant _ (ingredients_valid)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> certifier \<span class="kr">in</span>
  (Implies applicant ingredients_valid
     ingredients_valid)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkb4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkb4"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> applicant \<span class="kr">in</span> ingredients_valid</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkb5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkb5"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkb6"><span class="nb">eapply</span> (impl_elim _ _ successful_market_compliance_assessment).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> certifier \<span class="kr">in</span>
  (Implies <span class="nl">?a1</span> successful_market_compliance_assessment
     (Implies applicant ingredients_valid
        ingredients_valid))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkb7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkb7"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> <span class="nl">?a1</span> \<span class="kr">in</span> successful_market_compliance_assessment</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkb8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkb8"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> applicant \<span class="kr">in</span> ingredients_valid</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkb9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkb9"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkba"><span class="nb">eapply</span> (assume review).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> <span class="nl">?a1</span> \<span class="kr">in</span> successful_market_compliance_assessment</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkbb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkbb"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> applicant \<span class="kr">in</span> ingredients_valid</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkbc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkbc"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkbd"><span class="nb">eapply</span> (assume assess certifier).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> applicant \<span class="kr">in</span> ingredients_valid</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkbe" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkbe"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkbf"><span class="nb">eapply</span> (impl_elim applicant _ percentage_ingredients_valid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span>
  (Implies applicant percentage_ingredients_valid
     ingredients_valid)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkc0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkc0"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> percentage_ingredients_valid</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkc1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkc1"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkc2"><span class="nb">eapply</span> (assume compile).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> percentage_ingredients_valid</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkc3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkc3"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkc4"><span class="nb">eapply</span> (assume percentage_ingredients_list).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume breakdown_of_formulations_list).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkc5"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree preAssessmentRequirements.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ RV \rightarrow_{}A RV \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ r^{C} \in RV \rightarrow_{}A RV \vdash_{} r^{C} \in RV \rightarrow_{}A RV $}\AxiomC{$ IV \rightarrow_{}C BFV \rightarrow_{}A RV \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{A} \in IV \rightarrow_{}C BFV \rightarrow_{}A RV \vdash_{} c^{A} \in IV \rightarrow_{}C BFV \rightarrow_{}A RV $}\AxiomC{$ SMCA \rightarrow_{}C IV \rightarrow_{}A IV \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV \vdash_{} r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV $}\AxiomC{$ SMCA \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ a^{C} \in SMCA \vdash_{} a^{C} \in SMCA $} \RightLabel{ $ \rightarrow^{-}_{C} $} \BinaryInfC{$ r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV, a^{C} \in SMCA \vdash_{} r(a)^{C} \in IV \rightarrow_{}A IV $}\AxiomC{$ IV \rightarrow_{}A IV \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{A} \in IV \rightarrow_{}A IV \vdash_{} c^{A} \in IV \rightarrow_{}A IV $}\AxiomC{$ IV \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{PI}^{A} \in IV \vdash_{} e_{PI}^{A} \in IV $} \RightLabel{ $ \rightarrow^{-}_{A} $} \BinaryInfC{$ c^{A} \in IV \rightarrow_{}A IV, e_{PI}^{A} \in IV \vdash_{} c(e_{PI})^{A} \in IV $} \RightLabel{ $ \rightarrow^{-}_{A} $} \BinaryInfC{$ r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV, a^{C} \in SMCA, c^{A} \in IV \rightarrow_{}A IV, e_{PI}^{A} \in IV \vdash_{} r(a)(c(e_{PI}))^{C} \in IV $} \RightLabel{ $ \rightarrow^{-}_{C} $} \BinaryInfC{$ c^{A} \in IV \rightarrow_{}C BFV \rightarrow_{}A RV, r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV, a^{C} \in SMCA, c^{A} \in IV \rightarrow_{}A IV, e_{PI}^{A} \in IV \vdash_{} c(r(a)(c(e_{PI})))^{A} \in BFV \rightarrow_{}A RV $}\AxiomC{$ BFV \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{BF}^{A} \in BFV \vdash_{} e_{BF}^{A} \in BFV $} \RightLabel{ $ \rightarrow^{-}_{A} $} \BinaryInfC{$ c^{A} \in IV \rightarrow_{}C BFV \rightarrow_{}A RV, r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV, a^{C} \in SMCA, c^{A} \in IV \rightarrow_{}A IV, e_{PI}^{A} \in IV, e_{BF}^{A} \in BFV \vdash_{} c(r(a)(c(e_{PI})))(e_{BF})^{A} \in RV $} \RightLabel{ $ \rightarrow^{-}_{A} $} \BinaryInfC{$ r^{C} \in RV \rightarrow_{}A RV, c^{A} \in IV \rightarrow_{}C BFV \rightarrow_{}A RV, r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV, a^{C} \in SMCA, c^{A} \in IV \rightarrow_{}A IV, e_{PI}^{A} \in IV, e_{BF}^{A} \in BFV \vdash_{} r(c(r(a)(c(e_{PI})))(e_{BF}))^{C} \in RV $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkc6"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage preAssessmentRequirements).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming (recipe-valid, believed by applicant, implies recipe-valid) is supported by $r$ which certifier uses, (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is supported by $c$ which applicant uses, (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses, successful-market-compliance-assessment is supported by $a$ which certifier uses, (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $c$ which applicant uses, ingredients-valid is supported by $e_{PI}$ which applicant uses, and breakdown-of-formulations-valid is supported by $e_{BF}$ which applicant uses then recipe-valid is supported by $r(c(r(a)(c(e_{PI})))(e_{BF}))$ which certifier uses, because</span>
<span class="s2">  - Assuming (recipe-valid, believed by applicant, implies recipe-valid) is supported by $r$ which certifier uses then (recipe-valid, believed by applicant, implies recipe-valid) is supported by $r$ which certifier uses, because</span>
<span class="s2">  - (recipe-valid, believed by applicant, implies recipe-valid) is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">  - Assuming (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is supported by $c$ which applicant uses, (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses, successful-market-compliance-assessment is supported by $a$ which certifier uses, (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $c$ which applicant uses, ingredients-valid is supported by $e_{PI}$ which applicant uses, and breakdown-of-formulations-valid is supported by $e_{BF}$ which applicant uses then recipe-valid is supported by $c(r(a)(c(e_{PI})))(e_{BF})$ which applicant uses, because</span>
<span class="s2">    - Assuming (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is supported by $c$ which applicant uses, (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses, successful-market-compliance-assessment is supported by $a$ which certifier uses, (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $c$ which applicant uses, and ingredients-valid is supported by $e_{PI}$ which applicant uses then (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid) is supported by $c(r(a)(c(e_{PI})))$ which applicant uses, because</span>
<span class="s2">      - Assuming (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is supported by $c$ which applicant uses then (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is supported by $c$ which applicant uses, because</span>
<span class="s2">      - (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is a veracity claim.</span>
<span class="s2">      - by assumption.</span>
<span class="s2">      - Assuming (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses, successful-market-compliance-assessment is supported by $a$ which certifier uses, (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $c$ which applicant uses, and ingredients-valid is supported by $e_{PI}$ which applicant uses then ingredients-valid is supported by $r(a)(c(e_{PI}))$ which certifier uses, because</span>
<span class="s2">        - Assuming (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses, and successful-market-compliance-assessment is supported by $a$ which certifier uses then (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $r(a)$ which certifier uses, because</span>
<span class="s2">          - Assuming (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses then (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses, because</span>
<span class="s2">          - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">          - Assuming successful-market-compliance-assessment is supported by $a$ which certifier uses then successful-market-compliance-assessment is supported by $a$ which certifier uses, because</span>
<span class="s2">          - successful-market-compliance-assessment is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">        - by a logical rule for implication.</span>
<span class="s2">        - Assuming (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $c$ which applicant uses, and ingredients-valid is supported by $e_{PI}$ which applicant uses then ingredients-valid is supported by $c(e_{PI})$ which applicant uses, because</span>
<span class="s2">          - Assuming (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $c$ which applicant uses then (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $c$ which applicant uses, because</span>
<span class="s2">          - (ingredients-valid, believed by applicant, implies ingredients-valid) is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">          - Assuming ingredients-valid is supported by $e_{PI}$ which applicant uses then ingredients-valid is supported by $e_{PI}$ which applicant uses, because</span>
<span class="s2">          - ingredients-valid is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">        - by a logical rule for implication.</span>
<span class="s2">      - by a logical rule for implication.</span>
<span class="s2">    - by a logical rule for implication.</span>
<span class="s2">    - Assuming breakdown-of-formulations-valid is supported by $e_{BF}$ which applicant uses then breakdown-of-formulations-valid is supported by $e_{BF}$ which applicant uses, because</span>
<span class="s2">    - breakdown-of-formulations-valid is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for implication.</span>
<span class="s2">- by a logical rule for implication.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkc7"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq preAssessmentRequirements.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that recipe-valid is held by certifier</span>
<span class="s2">  - recipe-valid is held by certifier by the evidence $r(c(r(a)(c(e_{PI})))(e_{BF}))$</span>
<span class="s2">    - Assumptions made:      - (recipe-valid, believed by applicant, implies recipe-valid) is held by certifier by the evidence $r$</span>
<span class="s2">      - (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is held by applicant by the evidence $c$</span>
<span class="s2">      - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">      - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">      - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $c$</span>
<span class="s2">      - ingredients-valid is held by applicant by the evidence $e_{PI}$</span>
<span class="s2">      - breakdown-of-formulations-valid is held by applicant by the evidence $e_{BF}$</span>
<span class="s2">    - Trust relations used: None</span>
<span class="s2">    - Logical rule used: implication elimination</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - (recipe-valid, believed by applicant, implies recipe-valid) is held by certifier by the evidence $r$</span>
<span class="s2">          - Assumptions made:            - (recipe-valid, believed by applicant, implies recipe-valid) is held by certifier by the evidence $r$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">        - recipe-valid is held by applicant by the evidence $c(r(a)(c(e_{PI})))(e_{BF})$</span>
<span class="s2">          - Assumptions made:            - (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is held by applicant by the evidence $c$</span>
<span class="s2">            - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">            - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">            - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $c$</span>
<span class="s2">            - ingredients-valid is held by applicant by the evidence $e_{PI}$</span>
<span class="s2">            - breakdown-of-formulations-valid is held by applicant by the evidence $e_{BF}$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: implication elimination</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid) is held by applicant by the evidence $c(r(a)(c(e_{PI})))$</span>
<span class="s2">                - Assumptions made:                  - (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is held by applicant by the evidence $c$</span>
<span class="s2">                  - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">                  - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">                  - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $c$</span>
<span class="s2">                  - ingredients-valid is held by applicant by the evidence $e_{PI}$</span>
<span class="s2">                - Trust relations used: None</span>
<span class="s2">                - Logical rule used: implication elimination</span>
<span class="s2">                  - Sub-proofs:</span>
<span class="s2">                    - (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is held by applicant by the evidence $c$</span>
<span class="s2">                      - Assumptions made:                        - (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is held by applicant by the evidence $c$</span>
<span class="s2">                      - Trust relations used: None</span>
<span class="s2">                      - Logical rule used: we assume this</span>
<span class="s2">                    - ingredients-valid is held by certifier by the evidence $r(a)(c(e_{PI}))$</span>
<span class="s2">                      - Assumptions made:                        - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">                        - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">                        - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $c$</span>
<span class="s2">                        - ingredients-valid is held by applicant by the evidence $e_{PI}$</span>
<span class="s2">                      - Trust relations used: None</span>
<span class="s2">                      - Logical rule used: implication elimination</span>
<span class="s2">                        - Sub-proofs:</span>
<span class="s2">                          - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by certifier by the evidence $r(a)$</span>
<span class="s2">                            - Assumptions made:                              - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">                              - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">                            - Trust relations used: None</span>
<span class="s2">                            - Logical rule used: implication elimination</span>
<span class="s2">                              - Sub-proofs:</span>
<span class="s2">                                - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">                                  - Assumptions made:                                    - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">                                  - Trust relations used: None</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">                                - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">                                  - Assumptions made:                                    - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">                                  - Trust relations used: None</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">                          - ingredients-valid is held by applicant by the evidence $c(e_{PI})$</span>
<span class="s2">                            - Assumptions made:                              - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $c$</span>
<span class="s2">                              - ingredients-valid is held by applicant by the evidence $e_{PI}$</span>
<span class="s2">                            - Trust relations used: None</span>
<span class="s2">                            - Logical rule used: implication elimination</span>
<span class="s2">                              - Sub-proofs:</span>
<span class="s2">                                - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $c$</span>
<span class="s2">                                  - Assumptions made:                                    - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $c$</span>
<span class="s2">                                  - Trust relations used: None</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">                                - ingredients-valid is held by applicant by the evidence $e_{PI}$</span>
<span class="s2">                                  - Assumptions made:                                    - ingredients-valid is held by applicant by the evidence $e_{PI}$</span>
<span class="s2">                                  - Trust relations used: None</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">              - breakdown-of-formulations-valid is held by applicant by the evidence $e_{BF}$</span>
<span class="s2">                - Assumptions made:                  - breakdown-of-formulations-valid is held by applicant by the evidence $e_{BF}$</span>
<span class="s2">                - Trust relations used: None</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - r</span>
<span class="s2">    - a</span>
<span class="s2">    - e_{1}</span>
<span class="s2">    - e_{2}</span>
<span class="s2">    - c</span>
<span class="s2">    - e_{PI}</span>
<span class="s2">    - e_{BF}</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkc8"><span class="kn">Definition</span> <span class="nf">preAssessmentRequirementsWithEvidHoles</span> : proofTreeOf (JudgementPart certifier recipe_valid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> certifier \<span class="kr">in</span> recipe_valid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkc9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> certifier \<span class="kr">in</span> recipe_valid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkca"><span class="nb">eapply</span> (impl_elim applicant _ recipe_valid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> certifier \<span class="kr">in</span>
  (Implies applicant recipe_valid recipe_valid)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkcb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkcb"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> applicant \<span class="kr">in</span> recipe_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkcc"><span class="nb">eapply</span> (assume review).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> applicant \<span class="kr">in</span> recipe_valid</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkcd"><span class="nb">eapply</span> (impl_elim applicant _ breakdown_of_formulations_valid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span>
  (Implies applicant breakdown_of_formulations_valid
     recipe_valid)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkce"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkcf"><span class="nb">eapply</span> (impl_elim certifier _ ingredients_valid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span>
  (Implies certifier ingredients_valid
     (Implies applicant
        breakdown_of_formulations_valid recipe_valid))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkd0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkd0"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> certifier \<span class="kr">in</span> ingredients_valid</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkd1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkd1"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkd2"><span class="nb">eapply</span> (assume HoleEvid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> certifier \<span class="kr">in</span> ingredients_valid</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkd3"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkd4"><span class="nb">eapply</span> (impl_elim applicant _ (ingredients_valid)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> certifier \<span class="kr">in</span>
  (Implies applicant ingredients_valid
     ingredients_valid)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkd5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkd5"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> applicant \<span class="kr">in</span> ingredients_valid</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkd6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkd6"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkd7"><span class="nb">eapply</span> (impl_elim _ _ successful_market_compliance_assessment).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> certifier \<span class="kr">in</span>
  (Implies <span class="nl">?a1</span> successful_market_compliance_assessment
     (Implies applicant ingredients_valid
        ingredients_valid))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkd8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkd8"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> <span class="nl">?a1</span> \<span class="kr">in</span> successful_market_compliance_assessment</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkd9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkd9"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> applicant \<span class="kr">in</span> ingredients_valid</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkda" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkda"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkdb"><span class="nb">eapply</span> (assume review).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> <span class="nl">?a1</span> \<span class="kr">in</span> successful_market_compliance_assessment</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkdc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkdc"><hr></label><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> applicant \<span class="kr">in</span> ingredients_valid</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkdd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkdd"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chkde"><span class="nb">eapply</span> (assume assess certifier).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf \<span class="bp">by</span> applicant \<span class="kr">in</span> ingredients_valid</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chkdf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chkdf"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chke0"><span class="nb">eapply</span> (impl_elim applicant _ percentage_ingredients_valid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span>
  (Implies applicant percentage_ingredients_valid
     ingredients_valid)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chke1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chke1"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> percentage_ingredients_valid</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chke2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chke2"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chke3"><span class="nb">eapply</span> (assume HoleEvid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> percentage_ingredients_valid</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogicv4-v-chke4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><label class="goal-separator" for="veracitylogicv4-v-chke4"><hr></label><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chke5"><span class="nb">eapply</span> (assume HoleEvid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e4</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>c4</var><span class="hyp-type"><b>: </b><span>claim</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  \<span class="bp">by</span> applicant \<span class="kr">in</span> breakdown_of_formulations_valid</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume HoleEvid).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv4-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chke6"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree preAssessmentRequirementsWithEvidHoles.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ RV \rightarrow_{}A RV \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ r^{C} \in RV \rightarrow_{}A RV \vdash_{} r^{C} \in RV \rightarrow_{}A RV $}\AxiomC{$ IV \rightarrow_{}C BFV \rightarrow_{}A RV \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ \textcolor{red}{e_{?}}^{A} \in IV \rightarrow_{}C BFV \rightarrow_{}A RV \vdash_{} \textcolor{red}{e_{?}}^{A} \in IV \rightarrow_{}C BFV \rightarrow_{}A RV $}\AxiomC{$ SMCA \rightarrow_{}C IV \rightarrow_{}A IV \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV \vdash_{} r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV $}\AxiomC{$ SMCA \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ a^{C} \in SMCA \vdash_{} a^{C} \in SMCA $} \RightLabel{ $ \rightarrow^{-}_{C} $} \BinaryInfC{$ r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV, a^{C} \in SMCA \vdash_{} r(a)^{C} \in IV \rightarrow_{}A IV $}\AxiomC{$ IV \rightarrow_{}A IV \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ \textcolor{red}{e_{?}}^{A} \in IV \rightarrow_{}A IV \vdash_{} \textcolor{red}{e_{?}}^{A} \in IV \rightarrow_{}A IV $}\AxiomC{$ IV \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ \textcolor{red}{e_{?}}^{A} \in IV \vdash_{} \textcolor{red}{e_{?}}^{A} \in IV $} \RightLabel{ $ \rightarrow^{-}_{A} $} \BinaryInfC{$ \textcolor{red}{e_{?}}^{A} \in IV \rightarrow_{}A IV, \textcolor{red}{e_{?}}^{A} \in IV \vdash_{} \textcolor{red}{e_{?}}(\textcolor{red}{e_{?}})^{A} \in IV $} \RightLabel{ $ \rightarrow^{-}_{A} $} \BinaryInfC{$ r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV, a^{C} \in SMCA, \textcolor{red}{e_{?}}^{A} \in IV \rightarrow_{}A IV, \textcolor{red}{e_{?}}^{A} \in IV \vdash_{} r(a)(\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}}))^{C} \in IV $} \RightLabel{ $ \rightarrow^{-}_{C} $} \BinaryInfC{$ \textcolor{red}{e_{?}}^{A} \in IV \rightarrow_{}C BFV \rightarrow_{}A RV, r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV, a^{C} \in SMCA, \textcolor{red}{e_{?}}^{A} \in IV \rightarrow_{}A IV, \textcolor{red}{e_{?}}^{A} \in IV \vdash_{} \textcolor{red}{e_{?}}(r(a)(\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}})))^{A} \in BFV \rightarrow_{}A RV $}\AxiomC{$ BFV \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ \textcolor{red}{e_{?}}^{A} \in BFV \vdash_{} \textcolor{red}{e_{?}}^{A} \in BFV $} \RightLabel{ $ \rightarrow^{-}_{A} $} \BinaryInfC{$ \textcolor{red}{e_{?}}^{A} \in IV \rightarrow_{}C BFV \rightarrow_{}A RV, r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV, a^{C} \in SMCA, \textcolor{red}{e_{?}}^{A} \in IV \rightarrow_{}A IV, \textcolor{red}{e_{?}}^{A} \in IV, \textcolor{red}{e_{?}}^{A} \in BFV \vdash_{} \textcolor{red}{e_{?}}(r(a)(\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}})))(\textcolor{red}{e_{?}})^{A} \in RV $} \RightLabel{ $ \rightarrow^{-}_{A} $} \BinaryInfC{$ r^{C} \in RV \rightarrow_{}A RV, \textcolor{red}{e_{?}}^{A} \in IV \rightarrow_{}C BFV \rightarrow_{}A RV, r^{C} \in SMCA \rightarrow_{}C IV \rightarrow_{}A IV, a^{C} \in SMCA, \textcolor{red}{e_{?}}^{A} \in IV \rightarrow_{}A IV, \textcolor{red}{e_{?}}^{A} \in IV, \textcolor{red}{e_{?}}^{A} \in BFV \vdash_{} r(\textcolor{red}{e_{?}}(r(a)(\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}})))(\textcolor{red}{e_{?}}))^{C} \in RV $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chke7"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage preAssessmentRequirementsWithEvidHoles).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming (recipe-valid, believed by applicant, implies recipe-valid) is supported by $r$ which certifier uses, (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is supported by $\textcolor{red}{e_{?}}$ which applicant uses, (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses, successful-market-compliance-assessment is supported by $a$ which certifier uses, (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $\textcolor{red}{e_{?}}$ which applicant uses, ingredients-valid is supported by $\textcolor{red}{e_{?}}$ which applicant uses, and breakdown-of-formulations-valid is supported by $\textcolor{red}{e_{?}}$ which applicant uses then recipe-valid is supported by $r(\textcolor{red}{e_{?}}(r(a)(\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}})))(\textcolor{red}{e_{?}}))$ which certifier uses, because</span>
<span class="s2">  - Assuming (recipe-valid, believed by applicant, implies recipe-valid) is supported by $r$ which certifier uses then (recipe-valid, believed by applicant, implies recipe-valid) is supported by $r$ which certifier uses, because</span>
<span class="s2">  - (recipe-valid, believed by applicant, implies recipe-valid) is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">  - Assuming (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is supported by $\textcolor{red}{e_{?}}$ which applicant uses, (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses, successful-market-compliance-assessment is supported by $a$ which certifier uses, (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $\textcolor{red}{e_{?}}$ which applicant uses, ingredients-valid is supported by $\textcolor{red}{e_{?}}$ which applicant uses, and breakdown-of-formulations-valid is supported by $\textcolor{red}{e_{?}}$ which applicant uses then recipe-valid is supported by $\textcolor{red}{e_{?}}(r(a)(\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}})))(\textcolor{red}{e_{?}})$ which applicant uses, because</span>
<span class="s2">    - Assuming (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is supported by $\textcolor{red}{e_{?}}$ which applicant uses, (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses, successful-market-compliance-assessment is supported by $a$ which certifier uses, (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $\textcolor{red}{e_{?}}$ which applicant uses, and ingredients-valid is supported by $\textcolor{red}{e_{?}}$ which applicant uses then (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid) is supported by $\textcolor{red}{e_{?}}(r(a)(\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}})))$ which applicant uses, because</span>
<span class="s2">      - Assuming (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is supported by $\textcolor{red}{e_{?}}$ which applicant uses then (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is supported by $\textcolor{red}{e_{?}}$ which applicant uses, because</span>
<span class="s2">      - (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is a veracity claim.</span>
<span class="s2">      - by assumption.</span>
<span class="s2">      - Assuming (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses, successful-market-compliance-assessment is supported by $a$ which certifier uses, (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $\textcolor{red}{e_{?}}$ which applicant uses, and ingredients-valid is supported by $\textcolor{red}{e_{?}}$ which applicant uses then ingredients-valid is supported by $r(a)(\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}}))$ which certifier uses, because</span>
<span class="s2">        - Assuming (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses, and successful-market-compliance-assessment is supported by $a$ which certifier uses then (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $r(a)$ which certifier uses, because</span>
<span class="s2">          - Assuming (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses then (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is supported by $r$ which certifier uses, because</span>
<span class="s2">          - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">          - Assuming successful-market-compliance-assessment is supported by $a$ which certifier uses then successful-market-compliance-assessment is supported by $a$ which certifier uses, because</span>
<span class="s2">          - successful-market-compliance-assessment is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">        - by a logical rule for implication.</span>
<span class="s2">        - Assuming (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $\textcolor{red}{e_{?}}$ which applicant uses, and ingredients-valid is supported by $\textcolor{red}{e_{?}}$ which applicant uses then ingredients-valid is supported by $\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}})$ which applicant uses, because</span>
<span class="s2">          - Assuming (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $\textcolor{red}{e_{?}}$ which applicant uses then (ingredients-valid, believed by applicant, implies ingredients-valid) is supported by $\textcolor{red}{e_{?}}$ which applicant uses, because</span>
<span class="s2">          - (ingredients-valid, believed by applicant, implies ingredients-valid) is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">          - Assuming ingredients-valid is supported by $\textcolor{red}{e_{?}}$ which applicant uses then ingredients-valid is supported by $\textcolor{red}{e_{?}}$ which applicant uses, because</span>
<span class="s2">          - ingredients-valid is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">        - by a logical rule for implication.</span>
<span class="s2">      - by a logical rule for implication.</span>
<span class="s2">    - by a logical rule for implication.</span>
<span class="s2">    - Assuming breakdown-of-formulations-valid is supported by $\textcolor{red}{e_{?}}$ which applicant uses then breakdown-of-formulations-valid is supported by $\textcolor{red}{e_{?}}$ which applicant uses, because</span>
<span class="s2">    - breakdown-of-formulations-valid is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for implication.</span>
<span class="s2">- by a logical rule for implication.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv4-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv4-v-chke8"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq preAssessmentRequirementsWithEvidHoles.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that recipe-valid is held by certifier</span>
<span class="s2">  - recipe-valid is held by certifier by the evidence $r(\textcolor{red}{e_{?}}(r(a)(\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}})))(\textcolor{red}{e_{?}}))$</span>
<span class="s2">    - Assumptions made:      - (recipe-valid, believed by applicant, implies recipe-valid) is held by certifier by the evidence $r$</span>
<span class="s2">      - (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">      - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">      - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">      - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">      - ingredients-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">      - breakdown-of-formulations-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">    - Trust relations used: None</span>
<span class="s2">    - Logical rule used: implication elimination</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - (recipe-valid, believed by applicant, implies recipe-valid) is held by certifier by the evidence $r$</span>
<span class="s2">          - Assumptions made:            - (recipe-valid, believed by applicant, implies recipe-valid) is held by certifier by the evidence $r$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">        - recipe-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}(r(a)(\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}})))(\textcolor{red}{e_{?}})$</span>
<span class="s2">          - Assumptions made:            - (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">            - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">            - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">            - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">            - ingredients-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">            - breakdown-of-formulations-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">          - Trust relations used: None</span>
<span class="s2">          - Logical rule used: implication elimination</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid) is held by applicant by the evidence $\textcolor{red}{e_{?}}(r(a)(\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}})))$</span>
<span class="s2">                - Assumptions made:                  - (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                  - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">                  - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">                  - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                  - ingredients-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                - Trust relations used: None</span>
<span class="s2">                - Logical rule used: implication elimination</span>
<span class="s2">                  - Sub-proofs:</span>
<span class="s2">                    - (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                      - Assumptions made:                        - (ingredients-valid, believed by certifier, implies (breakdown-of-formulations-valid, believed by applicant, implies recipe-valid)) is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                      - Trust relations used: None</span>
<span class="s2">                      - Logical rule used: we assume this</span>
<span class="s2">                    - ingredients-valid is held by certifier by the evidence $r(a)(\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}}))$</span>
<span class="s2">                      - Assumptions made:                        - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">                        - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">                        - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                        - ingredients-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                      - Trust relations used: None</span>
<span class="s2">                      - Logical rule used: implication elimination</span>
<span class="s2">                        - Sub-proofs:</span>
<span class="s2">                          - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by certifier by the evidence $r(a)$</span>
<span class="s2">                            - Assumptions made:                              - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">                              - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">                            - Trust relations used: None</span>
<span class="s2">                            - Logical rule used: implication elimination</span>
<span class="s2">                              - Sub-proofs:</span>
<span class="s2">                                - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">                                  - Assumptions made:                                    - (successful-market-compliance-assessment, believed by certifier, implies (ingredients-valid, believed by applicant, implies ingredients-valid)) is held by certifier by the evidence $r$</span>
<span class="s2">                                  - Trust relations used: None</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">                                - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">                                  - Assumptions made:                                    - successful-market-compliance-assessment is held by certifier by the evidence $a$</span>
<span class="s2">                                  - Trust relations used: None</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">                          - ingredients-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}(\textcolor{red}{e_{?}})$</span>
<span class="s2">                            - Assumptions made:                              - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                              - ingredients-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                            - Trust relations used: None</span>
<span class="s2">                            - Logical rule used: implication elimination</span>
<span class="s2">                              - Sub-proofs:</span>
<span class="s2">                                - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                                  - Assumptions made:                                    - (ingredients-valid, believed by applicant, implies ingredients-valid) is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                                  - Trust relations used: None</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">                                - ingredients-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                                  - Assumptions made:                                    - ingredients-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                                  - Trust relations used: None</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">              - breakdown-of-formulations-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                - Assumptions made:                  - breakdown-of-formulations-valid is held by applicant by the evidence $\textcolor{red}{e_{?}}$</span>
<span class="s2">                - Trust relations used: None</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - r</span>
<span class="s2">    - a</span>
<span class="s2">    - e_{1}</span>
<span class="s2">    - e_{2}</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">allProofsAsString</span> := 
    showForProofTree concreteProofTreeExampleWith2Conjuncts
 ++ showForProofTree concreteProofTreeExampleWith3Conjuncts
 ++ showForProofTree concreteProofTreeExampleTrust
 ++ showForProofTree concreteProofTreeExampleWith3ConjunctsWithTrust
 ++ showForProofTree concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras
 ++ showForProofTree exampleWithProofOf
 ++ showForProofTree (usingAll aQ)
 ++ showForProofTree exampleC1
 ++ showForProofTree automatedProof
 ++ showForProofTree fromPaper1
 ++ showForProofTree exampleFromJosh
 ++ showForProofTree exampleFromJoshAuto
 ++ showForProofTree whiteboardExample
 ++ showForProofTree preAssessmentRequirements.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Definition allProofsAsString := </span>
<span class="c">    showForLogSeq concreteProofTreeExampleWith2Conjuncts</span>
<span class="c"> ++ showForLogSeq concreteProofTreeExampleWith3Conjuncts</span>
<span class="c"> ++ showForLogSeq concreteProofTreeExampleTrust</span>
<span class="c"> ++ showForLogSeq concreteProofTreeExampleWith3ConjunctsWithTrust</span>
<span class="c"> ++ showForLogSeq concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras</span>
<span class="c"> ++ showForLogSeq exampleWithProofOf</span>
<span class="c"> ++ showForLogSeq usingAll</span>
<span class="c"> ++ showForLogSeq exampleC1</span>
<span class="c"> ++ showForLogSeq automatedProof</span>
<span class="c"> ++ showForLogSeq fromPaper1</span>
<span class="c"> ++ showForLogSeq exampleFromJosh</span>
<span class="c"> ++ showForLogSeq exampleFromJoshAuto</span>
<span class="c"> ++ showForLogSeq whiteboardExample. *)</span>


<span class="c">(* Eval compute in allProofsAsString. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">VeracityLogic</span>.</span></span></pre></div>
</div>
</div></body>
</html>
