<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Veracity Logic Mechanised in Coq V3</title>
<script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js?config=TeX-AMS_CHTML"></script>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="veracity-logic-mechanised-in-coq-v3">
<h1 class="title">Veracity Logic Mechanised in Coq V3</h1>

<p>This version aims to more closely align with the draft paper.
It also features a LaTeX/MathJax visualisation of completed proofs.</p>
<p>This is possible due to not using <code class="highlight coq"><span class="kt">Prop</span></code> at all. &quot;<em>In fact in my logic there are no propositions</em>&quot; - Steve.
Instead, this aims to model the process of constructing proof trees, just like they are done on paper.</p>
<p>A correct proof tree is a datatype with similarities to a tree datatype, which makes it possible to write a function that prints a proof out.</p>
<p>Coq is useful here because we can construct correct proof trees in &quot;proof mode&quot;. In fact, we are just defining particular proof trees, but it is convenient to use &quot;proof mode&quot;.</p>
<p>Lastly, we use Coq's dependent types to enforce that it's not just any proof tree that we build, but it is a correct proof tree for the given judgement.
The type <code class="highlight coq"><span class="n">proofTreeOf</span></code> depends on the value, <code class="highlight coq"><span class="n">j</span></code>, of type <code class="highlight coq"><span class="n">judgement</span></code> which constrains what a <code class="highlight coq"><span class="n">proofTreeOf</span> <span class="n">j</span></code> is.
This is similar to a type such as <code class="highlight coq"><span class="n">vector</span></code> depending on a value, <code class="highlight coq"><span class="n">n</span></code>, (the vector's length) of type <code class="highlight coq"><span class="n">nat</span></code> which constrains what a <code class="highlight coq"><span class="n">vector</span> <span class="n">n</span></code> is.</p>
<p>Handling a trust relation and weights are future work (2024).</p>
<!-- The following is required to get MathJax to process the outputs marked with the class coq-math. -->
<link rel="stylesheet" href="overrides.css">

<script type="text/javascript">
  document.addEventListener("DOMContentLoaded", () => {
     // 1. Find all relevant Alectryon tags
     var spans = document.querySelectorAll(".coq-math > * > * > * > * > * > .s2, .custom-math");

     // 2. Wrap the contents of each in \(\) math delimiters, add mathjax class
     spans.forEach(function (e) {
         e.innerText = '\\[' + e.innerText + '\\]';
         e.classList.add("mathjax_process");
     });

     // 3. If MathJax has already loaded, force reprocessing
     window.MathJax && MathJax.typesetPromise(spans);
  });
</script>

<style type="text/css"> /* Override MathJax margins */
    .coq-math .goal-conclusion > *,
    .coq-math .hyp-body span > *,
    .coq-math .hyp-type span > * {
        margin: 0 !important;
    }
</style><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> String.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Strings.Ascii.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Bool.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">VeracityLogic</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">name</span> :=
  | _eQ_
  | _e_
  | _C_
  | _a1_
  | _e1_
  | _c1_
  | _a2_
  | _e2_
  | _c2_
  | _a3_
  | _e3_
  | _c3_
  | _a4_
  | _e4_
  | _c4_
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">namePair</span> :=
  | NamePair (id : name) (short long : string).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">evid</span> :=
  | AtomicEvid (name : namePair)
  | Pair (e1 e2: evid)
  | Left (e1 : evid)
  | Right (e1 : evid)
  | Lambda (e1 e2: evid)
  | Apply (e1 e2: evid).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">claim</span> :=
  | AtomicClaim (name : namePair)
  | Bottom
  | And (c1 c2 : claim)
  | Or  (c1 c2 : claim)
  | Implies  (c1 c2 : claim).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">actor</span> :=
  | Actor (s : namePair).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">singleJudgement</span> :=
  | SingleJudgement (a : actor) (c: claim).</span></span></pre><p>Judgements are a list of <strong>single</strong> judgements entailing some single judgement, or state that some claim <code class="highlight coq"><span class="n">c</span></code> is a veracity claim.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">judgement</span> :=
  | Entail (s : singleJudgement)
  | IsAVeracityClaim (c : claim).</span></span></pre><p>Next, we introduce some notation for Coq.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;||- S&quot;</span> := (Entail S) (<span class="kn">at level</span> <span class="mi">3</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;\by A \in C&quot;</span> := (SingleJudgement A C) (<span class="kn">at level</span> <span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;/\&#39;&quot;</span> := And (<span class="kn">at level</span> <span class="mi">81</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;\/&#39;&quot;</span> := Or (<span class="kn">at level</span> <span class="mi">86</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;_|_&quot;</span> := (Bottom) (<span class="kn">at level</span> <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{{ x , y , .. , z }}&quot;</span> := (Pair .. (Pair x y) .. z).</span></span></pre><p>We define a tagged type representing a trust relation.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">trustRelationInfo</span> :=
  | Trust (name : namePair).</span></span></pre><p>And we define equality for the tagged type.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Beq</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    beq : A -&gt; A -&gt; bool
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">beqNamePair</span> (<span class="nv">n1</span> <span class="nv">n2</span> : namePair) : bool :=
<span class="kr">match</span> n1,n2 <span class="kr">with</span>
| NamePair id1 _ _,NamePair id2 _ _ =&gt; name_beq id1 id2
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq namePair := { beq := beqNamePair }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">beqTrust</span> (<span class="nv">t1</span> <span class="nv">t2</span> : trustRelationInfo) : bool :=
<span class="kr">match</span> t1,t2 <span class="kr">with</span>
| Trust name1,Trust name2 =&gt; beq name1 name2
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq trustRelationInfo := { beq := beqTrust }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">beqActor</span> (<span class="nv">a1</span> <span class="nv">a2</span> : actor) : bool :=
<span class="kr">match</span> a1,a2 <span class="kr">with</span>
| Actor name1,Actor name2 =&gt; beq name1 name2
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq actor := { beq := beqActor }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Inductive evid :=</span>
<span class="c">  | AtomicEvid (name : string)</span>
<span class="c">  | Pair (: evid)</span>
<span class="c">  | Left (e1 : evid)</span>
<span class="c">  | Right (e1 : evid)</span>
<span class="c">  | Lambda (: evid). *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">beqEvid</span> (<span class="nv">e1</span> <span class="nv">e2</span>: evid) : bool :=
<span class="kr">match</span> e1,e2 <span class="kr">with</span>
| AtomicEvid name1,AtomicEvid name2 =&gt; beq name1 name2
| AtomicEvid name1,_ =&gt; false
| Pair e11 e12,Pair e21 e22 =&gt; beqEvid e11 e21 &amp;&amp; beqEvid e12 e22
| Pair e11 e12,_ =&gt; false
| Left e11,Left e21 =&gt; beqEvid e11 e21
| Left e11,_ =&gt; false
| Right e11,Right e21 =&gt; beqEvid e11 e21
| Right e11,_ =&gt; false
| Lambda e11 e12,Lambda e21 e22 =&gt; beqEvid e11 e21 &amp;&amp; beqEvid e12 e22
| Lambda e11 e12,_ =&gt; false
| Apply e11 e12,Apply e21 e22 =&gt; beqEvid e11 e21 &amp;&amp; beqEvid e12 e22
| Apply e11 e12,_ =&gt; false
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq evid := { beq := beqEvid }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Inductive claim :=</span>
<span class="c">  | AtomicClaim (name : string)</span>
<span class="c">  | Bottom</span>
<span class="c">  | And (c1 c2 : claim)</span>
<span class="c">  | Or  (c1 c2 : claim)</span>
<span class="c">  | Implies  (c1 c2 : claim). *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">beqClaim</span> (<span class="nv">c1</span> <span class="nv">c2</span> : claim) : bool :=
<span class="kr">match</span> c1,c2 <span class="kr">with</span>
| AtomicClaim name1,AtomicClaim name2 =&gt; beq name1 name2
| AtomicClaim name1,_ =&gt; false
| Bottom,Bottom =&gt; true
| Bottom,_ =&gt; false
| And c11 c12,And c21 c22 =&gt; beqClaim c11 c21 &amp;&amp; beqClaim c12 c22
| And c11 c12,_ =&gt; false
| Or c11 c12,Or c21 c22 =&gt; beqClaim c11 c21 &amp;&amp; beqClaim c12 c22
| Or c11 c12,_ =&gt; false
| Implies c11 c12,Implies c21 c22 =&gt; beqClaim c11 c21 &amp;&amp; beqClaim c12 c22
| Implies c11 c12,_ =&gt; false
<span class="kr">end</span>
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq claim := { beq := beqClaim }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Inductive singleJudgement :=</span>
<span class="c">  | SingleJudgement (e : evid) (a : actor) (c: claim). *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">beqSingleJudgement</span> (<span class="nv">j1</span> <span class="nv">j2</span> : singleJudgement) : bool :=
<span class="kr">match</span> j1,j2 <span class="kr">with</span>
SingleJudgement a1 c1,SingleJudgement a2 c2 =&gt; beq a1 a2 &amp;&amp; beq c1 c2
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq singleJudgement := { beq := beqSingleJudgement }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">beqEvidJudgementPair</span> (<span class="nv">es</span> <span class="nv">es&#39;</span> : (evid * singleJudgement)) : bool :=
<span class="kr">let</span> (<span class="nv">e</span>,s) := es <span class="kr">in</span>
  <span class="kr">let</span> (<span class="nv">e&#39;</span>,s&#39;) := es&#39; <span class="kr">in</span>
    (beq e e&#39;) &amp;&amp; (beq s s&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq (evid * singleJudgement) := { beq := beqEvidJudgementPair }.</span></span></pre><p>For now, I have only implemented one inference rule, <code class="highlight coq"><span class="n">and_intro</span></code>, as well as the <code class="highlight coq"><span class="n">assume</span></code> rule and a rule <code class="highlight coq"><span class="n">leaf</span></code> that declares that it is correct for a proof tree to stop on a statement such as <span class="math">\(C_1 \textit{ is a claim}\)</span>.</p>
<p><code class="highlight coq"><span class="n">proofTreeOf</span></code> is a data type, a tree, which depends on a judgement. The type <code class="highlight coq"><span class="n">tree</span> <span class="n">j</span></code> describes a tree which correctly proves <code class="highlight coq"><span class="n">j</span></code>.</p>
<p>But this is not a proposition. This is best thought of as the datatype for (correct) proof trees.</p>
<p>The remaining rules will be easy to add, this will be done in 2024.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">proofTreeOf</span> : judgement -&gt; <span class="kt">Type</span> :=
| <span class="nb">admit</span> p : proofTreeOf p
| leaf c : proofTreeOf (IsAVeracityClaim c)
| assume (e : evid) a C

       (M : proofTreeOf (IsAVeracityClaim C)) 
                         :
  proofTreeOf ( ||- \<span class="bp">by</span> a \<span class="kr">in</span> C)
| bot_elim a C

        (M : proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> _|_)))
                           :
           proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> C))

| and_intro a C1 C2

(L: proofTreeOf ( ||- \<span class="bp">by</span> a \<span class="kr">in</span> C1))
                           (R: proofTreeOf ( ||- \<span class="bp">by</span> a \<span class="kr">in</span> C2))
                        :
    proofTreeOf ( ||- \<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2))

| and_elim1 a C1 C2

    (M : proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2))))
                           :
             proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> C1))

| and_elim2 a C1 C2

    (M : proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2))))
                          :
        proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> C2))

| or_intro1 a C1 C2

           (M: proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> C1)))
                          :
    proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2)))

| or_intro2 a C1 C2

           (M: proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> C2)))
                          :
    proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2)))

| or_elim1 a C1 C2

      (M: proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2))))
                          :
        proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> C1))

| or_elim2 a C1 C2

      (M : proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2))))
                            :
          proofTreeOf ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> C2))

| trust a1 a2 C (name : trustRelationInfo)

(L: proofTreeOf ( ||- (\<span class="bp">by</span> a2 \<span class="kr">in</span> C)))
                          :
            proofTreeOf ( ||- (\<span class="bp">by</span> a1 \<span class="kr">in</span> C))

| impl_intro (e1 : evid) (C1 : claim) a C2

(M: proofTreeOf
                      ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> C2)))
                              :
proofTreeOf
              ( ||- (\<span class="bp">by</span> a \<span class="kr">in</span> (Implies C1 C2)))

| impl_elim a C1 C2

(L: proofTreeOf ( ||- \<span class="bp">by</span> a \<span class="kr">in</span> (Implies C1 C2)))
                           (R: proofTreeOf ( ||- \<span class="bp">by</span> a \<span class="kr">in</span> C1))
                        :
    proofTreeOf ( ||- \<span class="bp">by</span> a \<span class="kr">in</span> C2)
.</span></span></pre><p>This is the <code class="highlight coq"><span class="n">and_intro</span></code> rule as Coq sees it:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv3-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chk0"><span class="kn">Check</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">and_intro
     : <span class="kr">forall</span> (<span class="nv">a</span> : actor) (<span class="nv">C1</span> <span class="nv">C2</span> : claim),
       proofTreeOf ||- \<span class="bp">by</span> a \<span class="kr">in</span> C1 -&gt;
       proofTreeOf ||- \<span class="bp">by</span> a \<span class="kr">in</span> C2 -&gt;
       proofTreeOf ||- \<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">computeEvidence</span> (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j) : option evid := 
<span class="kr">match</span> p <span class="kr">with</span>
| <span class="nb">admit</span> _ =&gt; None
| leaf c =&gt; None
| assume e a name M =&gt; Some e
| bot_elim a C M =&gt; computeEvidence _ M
| and_intro a C1 C2 L R =&gt; <span class="kr">match</span> computeEvidence _ L, computeEvidence _ R <span class="kr">with</span>
                           | Some e1,Some e2 =&gt; Some {{e1,e2}}
                           | _,_ =&gt; None
                           <span class="kr">end</span>
| and_elim1 a C1 C2 M =&gt; <span class="kr">match</span> computeEvidence _ M <span class="kr">with</span>
                          | Some {{e1,e2}} =&gt; Some e1
                          | _ =&gt; None
                          <span class="kr">end</span>
| and_elim2 a C1 C2 M =&gt; <span class="kr">match</span> computeEvidence _ M <span class="kr">with</span>
                          | Some {{e1,e2}} =&gt; Some e2
                          | _ =&gt; None
                          <span class="kr">end</span>
| or_intro1 a C1 C2 M =&gt; <span class="kr">match</span> computeEvidence _ M <span class="kr">with</span>
                          | Some e1 =&gt; Some (Left e1)
                          | _ =&gt; None
                          <span class="kr">end</span>
| or_intro2 a C1 C2 M =&gt; <span class="kr">match</span> computeEvidence _ M <span class="kr">with</span>
                          | Some e1 =&gt; Some (Right e1)
                          | _ =&gt; None
                          <span class="kr">end</span>
| or_elim1 a C1 C2 M =&gt; <span class="kr">match</span> computeEvidence _ M <span class="kr">with</span>
                          | Some (Left e1) =&gt; Some e1
                          | _ =&gt; None
                          <span class="kr">end</span>
| or_elim2 a C1 C2 M =&gt; <span class="kr">match</span> computeEvidence _ M <span class="kr">with</span>
                          | Some (Right e2) =&gt; Some e2
                          | _ =&gt; None
                          <span class="kr">end</span>
| trust a1 a2 C name L =&gt; computeEvidence _ L
| impl_intro e1 C1 a C2 M =&gt; <span class="kr">match</span> computeEvidence _ M <span class="kr">with</span>
                              | Some e2 =&gt; Some (Lambda e1 e2)
                              | _ =&gt; None
                              <span class="kr">end</span>
| impl_elim a C1 C2 L R =&gt; <span class="kr">match</span> computeEvidence _ L, computeEvidence _ R <span class="kr">with</span>
                            | Some e1,Some e2 =&gt; Some (Apply e1 e2)
                            | _,_ =&gt; None
                            <span class="kr">end</span>
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">computeEvidenceSimple</span> <span class="nv">j</span> <span class="nv">p</span> :=
  <span class="kr">match</span> computeEvidence j p <span class="kr">with</span>
  | Some e =&gt; e
  | None =&gt; AtomicEvid (NamePair _eQ_ <span class="s2">&quot;?&quot;</span> <span class="s2">&quot;Unknown evidence (possibly from an incomplete proof)&quot;</span>)
<span class="kr">end</span>.</span></span></pre><!-- For some reason, math:: directives cause prooftree to crash. The following is an alternative that works. -->
<p>Here is a <em>manual</em> translation of the above rule into Latex.</p>
<pre class="code custom-math literal-block">
\begin{prooftree}
\AxiomC{$Ps \vdash e_1^a \in C_1 \quad Ps \vdash e_2^a \in C_2$}
\RightLabel{ $and\_intro$}
\UnaryInfC{$Ps ++ Qs \vdash (e_1, e_2)^a \in (C_1 \wedge C_2)$}
\end{prooftree}
</pre>
<div class="section" id="example-actors-evidence-claims-and-judgements">
<h1>Example actors, evidence, claims and judgements</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e</span> := AtomicEvid (NamePair _e_ <span class="s2">&quot;e&quot;</span> <span class="s2">&quot;example evidence e&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C</span> := AtomicClaim (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a1</span> := Actor (NamePair _a1_ <span class="s2">&quot;a_{1}&quot;</span> <span class="s2">&quot;actor 1&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e1</span> := AtomicEvid (NamePair _e1_ <span class="s2">&quot;e_{1}&quot;</span> <span class="s2">&quot;example evidence 1&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c1</span> := AtomicClaim (NamePair _c1_ <span class="s2">&quot;c_{1}&quot;</span> <span class="s2">&quot;example claim 1&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a2</span> := Actor (NamePair _a2_ <span class="s2">&quot;a_{2}&quot;</span> <span class="s2">&quot;actor 2&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e2</span> := AtomicEvid (NamePair _e2_ <span class="s2">&quot;e_{2}&quot;</span> <span class="s2">&quot;example evidence 2&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c2</span> := AtomicClaim (NamePair _c2_ <span class="s2">&quot;c_{2}&quot;</span> <span class="s2">&quot;example claim 2&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a3</span> := Actor (NamePair _a3_ <span class="s2">&quot;a_{3}&quot;</span> <span class="s2">&quot;actor 3&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e3</span> := AtomicEvid (NamePair _e3_ <span class="s2">&quot;e_{3}&quot;</span> <span class="s2">&quot;example evidence 3&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c3</span> := AtomicClaim (NamePair _c3_ <span class="s2">&quot;c_{3}&quot;</span> <span class="s2">&quot;example claim 3&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a4</span> := Actor (NamePair _a4_ <span class="s2">&quot;a_{4}&quot;</span> <span class="s2">&quot;actor 4&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e4</span> := AtomicEvid (NamePair _e4_ <span class="s2">&quot;e_{4}&quot;</span> <span class="s2">&quot;example evidence 4&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c4</span> := AtomicClaim (NamePair _c4_ <span class="s2">&quot;c_{4}&quot;</span> <span class="s2">&quot;example claim 4&quot;</span>).</span></span></pre><p>We can also assume arbitrary evidence/claims exist. This currently doesn't work well with printing to Latex. An experimental alternative is demonstrated in the experimental-NamedC-and-NamedE branch.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">e4</span> : evid).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">c4</span> : claim).</span></span></pre><p>Example Single judgements:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sj1</span> := \<span class="bp">by</span> a1 \<span class="kr">in</span> c1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sj3</span> := \<span class="bp">by</span> a3 \<span class="kr">in</span> c3.</span></span></pre><p>Example Judgments:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">j1</span> := ||- \<span class="bp">by</span> a2 \<span class="kr">in</span> c2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">j2</span> := ||- \<span class="bp">by</span> a4 \<span class="kr">in</span> c4.</span></span></pre><p>Example use of notation:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv3-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chk1"><span class="kn">Check</span> ||- \<span class="bp">by</span> a1 \<span class="kr">in</span> c1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">||- \<span class="bp">by</span> a1 \<span class="kr">in</span> c1
     : judgement</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv3-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chk2"><span class="kn">Check</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">\<span class="bp">by</span> a1 \<span class="kr">in</span> c1
     : singleJudgement</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv3-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chk3"><span class="kn">Check</span> ||- \<span class="bp">by</span> a1 \<span class="kr">in</span> c1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">||- \<span class="bp">by</span> a1 \<span class="kr">in</span> c1
     : judgement</blockquote></div></div></small></span></pre></div>
<div class="section" id="machinery-for-printing-to-latex">
<h1>Machinery for printing to LaTeX</h1>
<p>We define and make use of the <code class="highlight coq"><span class="n">show</span></code> typeclass, for simplicity.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Show</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    show : A -&gt; string
  }.</span></span></pre><p>We also define a typeclass for showing longer versions, used for the english-language output.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ShowLong</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    showLong : A -&gt; string
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ShowLong2</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    showLong2 : A -&gt; string
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowLong2 string := { showLong2 s := s }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> char_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">natToDigit</span> (<span class="nv">n</span> : nat) : ascii :=
  <span class="kr">match</span> n <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; <span class="s2">&quot;0&quot;</span>
    | <span class="mi">1</span> =&gt; <span class="s2">&quot;1&quot;</span>
    | <span class="mi">2</span> =&gt; <span class="s2">&quot;2&quot;</span>
    | <span class="mi">3</span> =&gt; <span class="s2">&quot;3&quot;</span>
    | <span class="mi">4</span> =&gt; <span class="s2">&quot;4&quot;</span>
    | <span class="mi">5</span> =&gt; <span class="s2">&quot;5&quot;</span>
    | <span class="mi">6</span> =&gt; <span class="s2">&quot;6&quot;</span>
    | <span class="mi">7</span> =&gt; <span class="s2">&quot;7&quot;</span>
    | <span class="mi">8</span> =&gt; <span class="s2">&quot;8&quot;</span>
    | _ =&gt; <span class="s2">&quot;9&quot;</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv3-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chk4"><span class="kn">Require Import</span> Coq.Numbers.Natural.Peano.NPeano.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Use of ‚Äú<span class="kn">Require</span>‚Äù <span class="kn">inside</span> a section <span class="kr">is</span> fragile. It <span class="kr">is</span>
not recommended to use this functionality <span class="kr">in</span> finished
proof scripts. [require-<span class="kr">in</span>-section,fragile]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">writeNatAux</span> (<span class="nv">time</span> <span class="nv">n</span> : nat) (<span class="nv">acc</span> : string) : string :=
  <span class="kr">let</span> <span class="nv">acc&#39;</span> := String (natToDigit (n mod <span class="mi">10</span>)) acc <span class="kr">in</span>
  <span class="kr">match</span> <span class="kp">time</span> <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; acc&#39;
    | S time&#39; =&gt;
      <span class="kr">match</span> n / <span class="mi">10</span> <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; acc&#39;
        | n&#39; =&gt; writeNatAux time&#39; n&#39; acc&#39;
      <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">writeNat</span> (<span class="nv">n</span> : nat) : string :=
  writeNatAux n n <span class="s2">&quot;&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv3-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chk5"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> writeNat <span class="mi">42</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;42&quot;</span>%string
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : <span class="kn">Show</span> nat := { show := writeNat }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string_scope.</span></span></pre><p>For each datatype defined earlier, we define a string representation of it.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showEvid</span> (<span class="nv">e</span> : evid) :=
<span class="kr">match</span> e <span class="kr">with</span>
  | AtomicEvid (NamePair _ name _) =&gt; name
  | Pair e1 e2 =&gt; <span class="s2">&quot;(&quot;</span> ++ (showEvid e1) ++ <span class="s2">&quot;, &quot;</span>
                      ++ (showEvid e2) ++ <span class="s2">&quot;)&quot;</span>
  | Left e =&gt; <span class="s2">&quot;i(&quot;</span> ++ showEvid e ++ <span class="s2">&quot;)&quot;</span>
  | Right e =&gt; <span class="s2">&quot;j(&quot;</span> ++ showEvid e ++ <span class="s2">&quot;)&quot;</span>
  | Lambda e1 e2 =&gt; <span class="s2">&quot;(\lambda &quot;</span> ++ showEvid e1 ++ <span class="s2">&quot; \rightarrow &quot;</span>
                       ++ showEvid e2 ++ <span class="s2">&quot;)&quot;</span>
  | Apply e1 e2 =&gt; showEvid e1 ++ <span class="s2">&quot;(&quot;</span> ++ showEvid e2 ++ <span class="s2">&quot;)&quot;</span>
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : <span class="kn">Show</span> evid := { show := showEvid }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowLong evid := { showLong := showEvid }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowLong2 evid := { showLong2 := showEvid }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showEvidNamePair</span> (<span class="nv">e</span> : evid) :=
<span class="kr">match</span> e <span class="kr">with</span>
  | AtomicEvid (NamePair _ short long) =&gt; <span class="s2">&quot;$&quot;</span> ++ short ++ <span class="s2">&quot;$ = &quot;</span> ++ long
  | _ =&gt; <span class="s2">&quot;&quot;</span>
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showClaim</span> (<span class="nv">c</span> : claim) :=
<span class="kr">match</span> c <span class="kr">with</span>
  | AtomicClaim (NamePair _ name _) =&gt; name
  | Bottom =&gt; <span class="s2">&quot;\bot&quot;</span>
  | And c1 c2 =&gt; showClaim c1 ++ <span class="s2">&quot; \wedge &quot;</span> ++ showClaim c2
  | Or c1 c2 =&gt; showClaim c1 ++ <span class="s2">&quot; \vee &quot;</span> ++ showClaim c2
  | Implies c1 c2 =&gt; showClaim c1 ++ <span class="s2">&quot; \rightarrow &quot;</span> ++ showClaim c2
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : <span class="kn">Show</span> claim := { show := showClaim }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showLongClaim</span> (<span class="nv">c</span> : claim) :=
<span class="kr">match</span> c <span class="kr">with</span>
  | AtomicClaim (NamePair _ _ name) =&gt; name
  | Bottom =&gt; <span class="s2">&quot;impossible&quot;</span>
  | And c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showLongClaim c1 ++ <span class="s2">&quot; and &quot;</span> ++ showLongClaim c2  ++ <span class="s2">&quot;)&quot;</span>
  | Or c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showLongClaim c1 ++ <span class="s2">&quot; or &quot;</span> ++ showLongClaim c2 ++ <span class="s2">&quot;)&quot;</span>
  | Implies c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showLongClaim c1 ++ <span class="s2">&quot; implies &quot;</span> ++ showLongClaim c2 ++ <span class="s2">&quot;)&quot;</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowLong claim := { showLong := showLongClaim }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowLong2 claim := { showLong2 := showLongClaim }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showActor</span> (<span class="nv">a</span> : actor) := 
  <span class="kr">match</span> a <span class="kr">with</span>
    | Actor (NamePair _ s _) =&gt; s 
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : <span class="kn">Show</span> actor := { show := showActor }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showLongActor</span> (<span class="nv">a</span> : actor) := 
  <span class="kr">match</span> a <span class="kr">with</span>
    | Actor (NamePair _ _ s) =&gt; s 
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowLong actor := { showLong := showLongActor }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowLong2 actor := { showLong2 := showLongActor }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showTrustRelationInfo</span> (<span class="nv">t</span> : trustRelationInfo) := 
  <span class="kr">match</span> t <span class="kr">with</span>
    | Trust (NamePair _ name _) =&gt; name
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : <span class="kn">Show</span> trustRelationInfo := { show := showTrustRelationInfo }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showLongTrustRelationInfo</span> (<span class="nv">t</span> : trustRelationInfo) := 
  <span class="kr">match</span> t <span class="kr">with</span>
    | Trust (NamePair _ _ name) =&gt; name
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowLong trustRelationInfo := { showLong := showLongTrustRelationInfo }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowLong2 trustRelationInfo := { showLong2 := showLongTrustRelationInfo }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showList</span> {<span class="nv">A</span>} `{<span class="kn">Show</span> A} (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;&quot;</span>
    | [h] =&gt; show h
    | h1 :: (h2 :: tl) <span class="kr">as</span> tl&#39; =&gt; show h1 ++ <span class="s2">&quot;, &quot;</span> ++ showList tl&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showListInstance</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{<span class="kn">Show</span> A} : <span class="kn">Show</span> (list A) 
  := { show l := showList l}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv3-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chk6"><span class="kn">Fixpoint</span> <span class="nf">showLongList</span> {<span class="nv">A</span>} `{ShowLong A} (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;no items&quot;</span>
    | [h] =&gt; showLong h
    | [h1;h2] =&gt; showLong h1 ++ <span class="s2">&quot;, and &quot;</span> ++ showLong h2
    | h1 :: (h2 :: tl) <span class="kr">as</span> tl&#39; =&gt; showLong h1 ++ <span class="s2">&quot;, &quot;</span> ++ showLongList tl&#39;
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Unused variable tl might be a misspelled <span class="nb">constructor</span>.
Use _ or _tl to silence this warning.
[unused-<span class="nb">pattern</span>-matching-variable,<span class="nb">pattern</span>-matching]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showLongListInstance</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{ShowLong A} : ShowLong (list A) 
  := { showLong l := showLongList l}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showLong2List</span> {<span class="nv">A</span>} `{ShowLong2 A} (indent : string) (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;&quot;</span>
    | [h] =&gt; indent ++ <span class="s2">&quot;- &quot;</span> ++ showLong2 h
    | h :: tl =&gt; indent ++ <span class="s2">&quot;- &quot;</span> ++ showLong2 h ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ showLong2List indent tl
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showLong2ListInstance</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{ShowLong2 A} (indent : string) : ShowLong2 (list A) 
  := { showLong2 l := showLong2List indent l}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showListForProofs</span> {<span class="nv">A</span>} `{<span class="kn">Show</span> A} (l : list A) :=
    <span class="kr">match</span> l <span class="kr">with</span>
      | [] =&gt; <span class="s2">&quot;&quot;</span>
      | h :: tl =&gt; <span class="s2">&quot;</span>

<span class="s2">----------------</span>

<span class="s2">&quot;</span> ++ show h ++ showListForProofs tl
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showSingleJudgement</span> (<span class="nv">e</span> : evid) (<span class="nv">s</span> : singleJudgement) := 
  <span class="kr">match</span> s <span class="kr">with</span>
    | SingleJudgement a c =&gt; show e ++ <span class="s2">&quot;^{&quot;</span> ++ show a ++ <span class="s2">&quot;} \in &quot;</span>
                                 ++ show c
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showEvidJudgementPairInstance</span> : <span class="kn">Show</span> (evid * singleJudgement) 
  := { show es := <span class="kr">let</span> (<span class="nv">e</span>,s) := es <span class="kr">in</span> showSingleJudgement e s}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showLongSingleJudgement</span> (<span class="nv">e</span> : evid) (<span class="nv">s</span> : singleJudgement) := 
  <span class="kr">match</span> s <span class="kr">with</span>
    | SingleJudgement a c =&gt; showLong c ++ <span class="s2">&quot; is supported by $&quot;</span> ++ showLong e ++ <span class="s2">&quot;$ which &quot;</span> ++ showLong a ++ <span class="s2">&quot; uses&quot;</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showLong2SingleJudgement</span> (<span class="nv">e</span> : evid) (<span class="nv">s</span> : singleJudgement) := 
  <span class="kr">match</span> s <span class="kr">with</span>
    | SingleJudgement a c =&gt; showLong2 c ++ <span class="s2">&quot; is held by &quot;</span> ++ showLong2 a ++ <span class="s2">&quot; by the evidence $&quot;</span> ++ showLong2 e ++ <span class="s2">&quot;$&quot;</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showJudgement</span> (<span class="nv">Ps</span> : list (evid * singleJudgement)) (<span class="nv">Ts</span> : list trustRelationInfo) (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j) :=
<span class="kr">let</span> <span class="nv">computedEvidence</span> := computeEvidenceSimple j p <span class="kr">in</span>
  <span class="kr">match</span> j <span class="kr">with</span>
  | Entail s =&gt; 
      <span class="kr">match</span> Ps <span class="kr">with</span>
        | [] =&gt; showSingleJudgement computedEvidence s
        | (h :: tl) <span class="kr">as</span> Ps =&gt; show Ps ++ <span class="s2">&quot; \vdash_{&quot;</span> ++ show Ts ++ <span class="s2">&quot;} &quot;</span> ++ (showSingleJudgement computedEvidence s)
      <span class="kr">end</span>
  | IsAVeracityClaim c =&gt; show c ++ <span class="s2">&quot; \em{ is a veracity claim}&quot;</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv3-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chk7"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showJudgement [] [] j1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="kr">fun</span>
    <span class="nv">p</span> : proofTreeOf
          ||- \<span class="bp">by</span>
              Actor
                (NamePair _a2_ <span class="s2">&quot;a_{2}&quot;</span> <span class="s2">&quot;actor 2&quot;</span>) \<span class="kr">in</span>
              (AtomicClaim
                 (NamePair _c2_ <span class="s2">&quot;c_{2}&quot;</span>
                    <span class="s2">&quot;example claim 2&quot;</span>)) =&gt;
  (<span class="kr">fix</span> append (s1 s2 : string) {<span class="kr">struct</span> s1} :
       string :=
     <span class="kr">match</span> s1 <span class="kr">with</span>
     | <span class="s2">&quot;&quot;</span> =&gt; s2
     | String c s1&#39; =&gt; String c (append s1&#39; s2)
     <span class="kr">end</span>)
    ((<span class="kr">fix</span> showEvid (e : evid) : string :=
        <span class="kr">match</span> e <span class="kr">with</span>
        | AtomicEvid (NamePair _ name _) =&gt; name
        | {{e1, e2}} =&gt;
            String <span class="s2">&quot;(&quot;</span>
              ((<span class="kr">fix</span> append
                  (s1 s2 : string) {<span class="kr">struct</span> s1} :
                    string :=
                  <span class="kr">match</span> s1 <span class="kr">with</span>
                  | <span class="s2">&quot;&quot;</span> =&gt; s2
                  | String c s1&#39; =&gt;
                      String c (append s1&#39; s2)
                  <span class="kr">end</span>) (showEvid e1)
                 (String <span class="s2">&quot;,&quot;</span>
                    (String <span class="s2">&quot; &quot;</span>
                       ((<span class="kr">fix</span> append
                           (s1 s2 : string)
                           {<span class="kr">struct</span> s1} :
                             string :=
                           <span class="kr">match</span> s1 <span class="kr">with</span>
                           | <span class="s2">&quot;&quot;</span> =&gt; s2
                           | String c s1&#39; =&gt;
                               String c
                                 (append s1&#39; s2)
                           <span class="kr">end</span>) (showEvid e2) <span class="s2">&quot;)&quot;</span>))))
        | Left e0 =&gt;
            String <span class="s2">&quot;i&quot;</span>
              (String <span class="s2">&quot;(&quot;</span>
                 ((<span class="kr">fix</span> append
                     (s1 s2 : string) {<span class="kr">struct</span> s1} :
                       string :=
                     <span class="kr">match</span> s1 <span class="kr">with</span>
                     | <span class="s2">&quot;&quot;</span> =&gt; s2
                     | String c s1&#39; =&gt;
                         String c (append s1&#39; s2)
                     <span class="kr">end</span>) (showEvid e0) <span class="s2">&quot;)&quot;</span>))
        | Right e0 =&gt;
            String <span class="s2">&quot;j&quot;</span>
              (String <span class="s2">&quot;(&quot;</span>
                 ((<span class="kr">fix</span> append
                     (s1 s2 : string) {<span class="kr">struct</span> s1} :
                       string :=
                     <span class="kr">match</span> s1 <span class="kr">with</span>
                     | <span class="s2">&quot;&quot;</span> =&gt; s2
                     | String c s1&#39; =&gt;
                         String c (append s1&#39; s2)
                     <span class="kr">end</span>) (showEvid e0) <span class="s2">&quot;)&quot;</span>))
        | Lambda e1 e2 =&gt;
            String <span class="s2">&quot;(&quot;</span>
              (String <span class="s2">&quot;\&quot;</span>
                 (String <span class="s2">&quot;l&quot;</span>
                    (String <span class="s2">&quot;a&quot;</span>
                       (String <span class="s2">&quot;m&quot;</span>
                          (String <span class="s2">&quot;b&quot;</span>
                             (String <span class="s2">&quot;d&quot;</span>
                                (String <span class="s2">&quot;a&quot;</span>
                                   (String <span class="s2">&quot; &quot;</span>
                                      (... ...
                                         ...)))))))))
        | Apply e1 e2 =&gt;
            (<span class="kr">fix</span> append
               (s1 s2 : string) {<span class="kr">struct</span> s1} :
                 string :=
               <span class="kr">match</span> s1 <span class="kr">with</span>
               | <span class="s2">&quot;&quot;</span> =&gt; s2
               | String c s1&#39; =&gt;
                   String c (append s1&#39; s2)
               <span class="kr">end</span>) (showEvid e1)
              (String <span class="s2">&quot;(&quot;</span>
                 ((<span class="kr">fix</span> append
                     (s1 s2 : string) {<span class="kr">struct</span> s1} :
                       string :=
                     <span class="kr">match</span> s1 <span class="kr">with</span>
                     | <span class="s2">&quot;&quot;</span> =&gt; s2
                     | String c s1&#39; =&gt;
                         String c (append s1&#39; s2)
                     <span class="kr">end</span>) (showEvid e2) <span class="s2">&quot;)&quot;</span>))
        <span class="kr">end</span>)
       <span class="kr">match</span>
         (<span class="kr">fix</span> computeEvidence
            (j : judgement) (p0 : proofTreeOf j)
            {<span class="kr">struct</span> p0} : option evid :=
            <span class="kr">match</span> p0 <span class="kr">with</span>
            | assume e _ _ _ =&gt; Some e
            | bot_elim a _ M =&gt;
                computeEvidence ||- \<span class="bp">by</span> a \<span class="kr">in</span> _|_
                  M
            | and_intro a C1 C2 L R =&gt;
                <span class="kr">match</span>
                  computeEvidence
                    ||- \<span class="bp">by</span> a \<span class="kr">in</span> C1 L
                <span class="kr">with</span>
                | Some e1 =&gt;
                    <span class="kr">match</span>
                      computeEvidence
                        ||- \<span class="bp">by</span> a \<span class="kr">in</span> C2 R
                    <span class="kr">with</span>
                    | Some e2 =&gt; Some {{e1, e2}}
                    | None =&gt; None
                    <span class="kr">end</span>
                | None =&gt; None
                <span class="kr">end</span>
            | and_elim1 a C1 C2 M =&gt;
                <span class="kr">match</span>
                  computeEvidence
                    ||- \<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2) M
                <span class="kr">with</span>
                | Some {{e1, _}} =&gt; Some e1
                | _ =&gt; None
                <span class="kr">end</span>
            | and_elim2 a C1 C2 M =&gt;
                <span class="kr">match</span>
                  computeEvidence
                    ||- \<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2) M
                <span class="kr">with</span>
                | Some {{_, e2}} =&gt; Some e2
                | _ =&gt; None
                <span class="kr">end</span>
            | or_intro1 a C1 _ M =&gt;
                <span class="kr">match</span>
                  computeEvidence
                    ||- \<span class="bp">by</span> a \<span class="kr">in</span> C1 M
                <span class="kr">with</span>
                | Some e1 =&gt; Some (Left e1)
                | None =&gt; None
                <span class="kr">end</span>
            | or_intro2 a _ C2 M =&gt;
                <span class="kr">match</span>
                  computeEvidence
                    ||- \<span class="bp">by</span> a \<span class="kr">in</span> C2 M
                <span class="kr">with</span>
                | Some e1 =&gt; Some (Right e1)
                | None =&gt; None
                <span class="kr">end</span>
            | or_elim1 a C1 C2 M =&gt;
                <span class="kr">match</span>
                  computeEvidence
                    ||- \<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2) M
                <span class="kr">with</span>
                | Some (Left e1) =&gt; Some e1
                | _ =&gt; None
                <span class="kr">end</span>
            | or_elim2 a C1 C2 M =&gt;
                <span class="kr">match</span>
                  computeEvidence
                    ||- \<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2) M
                <span class="kr">with</span>
                | Some (Right e2) =&gt; Some e2
                | _ =&gt; None
                <span class="kr">end</span>
            | trust _ a2 C _ L =&gt;
                computeEvidence ||- \<span class="bp">by</span> a2 \<span class="kr">in</span> C
                  L
            | impl_intro e1 _ a C2 M =&gt;
                <span class="kr">match</span>
                  computeEvidence
                    ||- \<span class="bp">by</span> a \<span class="kr">in</span> C2 M
                <span class="kr">with</span>
                | Some e2 =&gt; Some (Lambda e1 e2)
                | None =&gt; None
                <span class="kr">end</span>
            | impl_elim a C1 C2 L R =&gt;
                <span class="kr">match</span>
                  computeEvidence
                    ||- \<span class="bp">by</span> a \<span class="kr">in</span> (Implies C1 C2)
                    L
                <span class="kr">with</span>
                | Some e1 =&gt;
                    <span class="kr">match</span>
                      computeEvidence
                        ||- \<span class="bp">by</span> a \<span class="kr">in</span> C1 R
                    <span class="kr">with</span>
                    | Some e2 =&gt;
                        Some (Apply e1 e2)
                    | None =&gt; None
                    <span class="kr">end</span>
                | None =&gt; None
                <span class="kr">end</span>
            | _ =&gt; None
            <span class="kr">end</span>)
           ||- \<span class="bp">by</span>
               Actor
                 (NamePair _a2_ <span class="s2">&quot;a_{2}&quot;</span> <span class="s2">&quot;actor 2&quot;</span>) \<span class="kr">in</span>
               (AtomicClaim
                  (NamePair _c2_ <span class="s2">&quot;c_{2}&quot;</span>
                     <span class="s2">&quot;example claim 2&quot;</span>)) p
       <span class="kr">with</span>
       | Some e =&gt; e
       | None =&gt;
           AtomicEvid
             (NamePair _eQ_ <span class="s2">&quot;?&quot;</span>
                <span class="s2">&quot;Unknown evidence (possibly from an incomplete proof)&quot;</span>)
       <span class="kr">end</span>) <span class="s2">&quot;^{a_{2}} \in c_{2}&quot;</span>
: proofTreeOf j1 -&gt; string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showJudgementForAdmits</span> (<span class="nv">j</span> : judgement) :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | Entail (SingleJudgement a c) =&gt; 
      show a ++ <span class="s2">&quot; \in &quot;</span> ++ show c
  | IsAVeracityClaim c =&gt; show c
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Eval compute in showJudgement [\by a1 \in c1] [] j1. *)</span>

<span class="c">(* Definition showLongJudgement (Ps : list singleJudgement) (Ts : list trustRelationInfo) (j : judgement) (p : proofTreeOf j) :=</span>
<span class="c">  match j with</span>
<span class="c">  | Entail s =&gt; </span>
<span class="c">      match Ps with</span>
<span class="c">        | [] =&gt; showLong s</span>
<span class="c">        | (h :: tl) as Ps =&gt; &quot;Assuming &quot; ++ showLong Ps ++ &quot; then &quot; ++ showLong s</span>
<span class="c">      end</span>
<span class="c">  | IsAVeracityClaim c =&gt; showLong c ++ &quot; is a veracity claim&quot;</span>
<span class="c">  end. *)</span>

<span class="c">(* With explicit &quot;None&quot;s *)</span>
<span class="c">(* Definition showLong2Judgement (Ps : list singleJudgement) (Ts : list trustRelationInfo) (indent : string) (j : judgement) (p : proofTreeOf j) :=</span>
<span class="c">  match j with</span>
<span class="c">  | Entail s =&gt; </span>
<span class="c">      match Ps,Ts with</span>
<span class="c">        | [],[] =&gt; showLong2 s ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made: None&quot; ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used: None&quot;</span>
<span class="c">        | (h :: tl),[] =&gt; showLong2 s ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made:&quot; ++ showLong2List (&quot;  &quot; ++ indent) Ps ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used: None&quot;</span>
<span class="c">        | [],(h :: tl) =&gt; showLong2 s ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made: None&quot; ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used:&quot; ++ showLong2List (&quot;  &quot; ++ indent) Ts</span>
<span class="c">        | (h :: tl),(h2::tl2) =&gt; showLong2 s ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made:&quot; ++ showLong2List (&quot;  &quot; ++ indent) Ps ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used:&quot; ++ showLong2List (&quot;  &quot; ++ indent) Ts</span>
<span class="c">      end</span>
<span class="c">  | IsAVeracityClaim c =&gt; showLong c ++ &quot; is a veracity claim&quot; (* ShowLong2 won&#39;t actually use this branch. *)</span>
<span class="c">  end. *)</span>


<span class="c">(* Definition showLong2Judgement (Ps : list singleJudgement) (Ts : list trustRelationInfo) (indent : string) (j : judgement) (p : proofTreeOf j) :=</span>
<span class="c">  match j with</span>
<span class="c">  | Entail s =&gt; </span>
<span class="c">      match Ps,Ts with</span>
<span class="c">        | [],[] =&gt; showLong2 s</span>
<span class="c">        | (h :: tl),[] =&gt; showLong2 s ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;collapsed:: true</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made:</span>
<span class="c">&quot; ++ indent ++ &quot;  collapsed:: true</span>
<span class="c">&quot; ++ showLong2List (&quot;  &quot; ++ indent) Ps</span>
<span class="c">        | [],(h :: tl) =&gt; showLong2 s ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;collapsed:: true</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used:</span>
<span class="c">&quot; ++ indent ++ &quot;  collapsed:: true</span>
<span class="c">&quot; ++ showLong2List (&quot;  &quot; ++ indent) Ts</span>
<span class="c">        | (h :: tl),(h2::tl2) =&gt; showLong2 s ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;collapsed:: true</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made:</span>
<span class="c">&quot; ++ indent ++ &quot;  collapsed:: true</span>
<span class="c">&quot; ++ showLong2List (&quot;  &quot; ++ indent) Ps ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used:</span>
<span class="c">&quot; ++ indent ++ &quot;  collapsed:: true</span>
<span class="c">&quot; ++ showLong2List (&quot;  &quot; ++ indent) Ts</span>
<span class="c">      end</span>
<span class="c">  | IsAVeracityClaim c =&gt; showLong c ++ &quot; is a veracity claim&quot; (* ShowLong2 won&#39;t actually use this branch. *)</span>
<span class="c">  end. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAllTrustRelationsUsed</span> (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j)
  : list trustRelationInfo :=
<span class="kr">match</span> p <span class="kr">with</span>
| <span class="nb">admit</span> _ =&gt; []
| leaf c =&gt; []
| assume e a name M =&gt; getAllTrustRelationsUsed _ M
| bot_elim a C M =&gt; getAllTrustRelationsUsed _ M
| and_intro a C1 C2 L R =&gt; 
    getAllTrustRelationsUsed _ L ++ getAllTrustRelationsUsed _ R 
| and_elim1 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| and_elim2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_intro1 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_intro2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_elim1 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_elim2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| trust a1 a2 C name L =&gt; 
    name :: getAllTrustRelationsUsed _ L
| impl_intro e1 C1 a C2 M =&gt; getAllTrustRelationsUsed _ M
| impl_elim a C1 C2 L R =&gt; 
   getAllTrustRelationsUsed _ L ++ getAllTrustRelationsUsed _ R 
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAllEvidence</span> (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j)
  : list evid :=
<span class="kr">match</span> p <span class="kr">with</span>
| <span class="nb">admit</span> _ =&gt; []
| leaf c =&gt; []
| assume e a name M =&gt; e :: (getAllEvidence _ M)
| bot_elim a C M =&gt; e :: (getAllEvidence _ M)
| and_intro a C1 C2 L R =&gt; 
    e1 :: e2 :: getAllEvidence _ L ++ getAllEvidence _ R 
| and_elim1 a C1 C2 M =&gt; e1 :: e2 :: getAllEvidence _ M
| and_elim2 a C1 C2 M =&gt; e1 :: e2 :: getAllEvidence _ M
| or_intro1 a C1 C2 M =&gt; e1 :: getAllEvidence _ M
| or_intro2 a C1 C2 M =&gt; e2 :: getAllEvidence _ M
| or_elim1 a C1 C2 M =&gt; e1 :: getAllEvidence _ M
| or_elim2 a C1 C2 M =&gt; e2 :: getAllEvidence _ M
| trust a1 a2 C name L =&gt; e ::  getAllEvidence _ L
| impl_intro e1 C1 a C2 M =&gt; e1 :: e2 :: getAllEvidence _ M
| impl_elim a C1 C2 L R =&gt; 
   e1 :: e2 :: getAllEvidence _ L ++ getAllEvidence _ R 
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isAtomicEvidence</span> (<span class="nv">e</span> : evid) : bool :=
<span class="kr">match</span> e <span class="kr">with</span>
  | AtomicEvid _ =&gt; true
  | _ =&gt; false
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAssumptions</span> (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j) : list singleJudgement := 
<span class="kr">match</span> p <span class="kr">with</span>
| <span class="nb">admit</span> _ =&gt; []
| leaf c =&gt; []
| assume e a c M =&gt; \<span class="bp">by</span> a \<span class="kr">in</span> c :: getAssumptions _ M
| bot_elim a C M =&gt; getAssumptions _ M
| and_intro a C1 C2 L R =&gt; 
    getAssumptions _ L ++ getAssumptions _ R 
| and_elim1 a C1 C2 M =&gt; getAssumptions _ M
| and_elim2 a C1 C2 M =&gt; getAssumptions _ M
| or_intro1 a C1 C2 M =&gt; getAssumptions _ M
| or_intro2 a C1 C2 M =&gt; getAssumptions _ M
| or_elim1 a C1 C2 M =&gt; getAssumptions _ M
| or_elim2 a C1 C2 M =&gt; getAssumptions _ M
| trust a1 a2 C name L =&gt; 
    getAssumptions _ L
| impl_intro e1 C1 a C2 M =&gt; filter (beq (\<span class="bp">by</span> a \<span class="kr">in</span> C1)) (getAssumptions _ M)
| impl_elim a C1 C2 L R =&gt; 
   getAssumptions _ L ++ getAssumptions _ R 
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAssumptionsWithEvidence</span> (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j) : list (evid * singleJudgement) := 
<span class="kr">match</span> p <span class="kr">with</span>
| <span class="nb">admit</span> _ =&gt; []
| leaf c =&gt; []
| assume e a c M =&gt; (e, \<span class="bp">by</span> a \<span class="kr">in</span> c) :: getAssumptionsWithEvidence _ M
| bot_elim a C M =&gt; getAssumptionsWithEvidence _ M
| and_intro a C1 C2 L R =&gt; 
    getAssumptionsWithEvidence _ L ++ getAssumptionsWithEvidence _ R 
| and_elim1 a C1 C2 M =&gt; getAssumptionsWithEvidence _ M
| and_elim2 a C1 C2 M =&gt; getAssumptionsWithEvidence _ M
| or_intro1 a C1 C2 M =&gt; getAssumptionsWithEvidence _ M
| or_intro2 a C1 C2 M =&gt; getAssumptionsWithEvidence _ M
| or_elim1 a C1 C2 M =&gt; getAssumptionsWithEvidence _ M
| or_elim2 a C1 C2 M =&gt; getAssumptionsWithEvidence _ M
| trust a1 a2 C name L =&gt; 
    getAssumptionsWithEvidence _ L
| impl_intro e1 C1 a C2 M =&gt; filter (beq (e1, \<span class="bp">by</span> a \<span class="kr">in</span> C1)) (getAssumptionsWithEvidence _ M)
| impl_elim a C1 C2 L R =&gt; 
   getAssumptionsWithEvidence _ L ++ getAssumptionsWithEvidence _ R 
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">removeDups</span> {<span class="nv">A</span>} `{Beq A} (l : list A) : list A :=
<span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; []
| h :: tl =&gt; <span class="kr">if</span> existsb (beq h) tl <span class="kr">then</span> removeDups tl <span class="kr">else</span> h :: removeDups tl
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">beqJudgement</span> (<span class="nv">j1</span> <span class="nv">j2</span> : judgement) : bool :=
<span class="kr">match</span> j1,j2 <span class="kr">with</span>
| Entail s,Entail s&#39; =&gt; beq s s&#39;
| IsAVeracityClaim c,IsAVeracityClaim c&#39; =&gt; beq c c&#39;
| _,_ =&gt; false
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq judgement := { beq := beqJudgement }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">beqProofTreeOf</span> {<span class="nv">j1</span> <span class="nv">j2</span> : judgement} (<span class="nv">P1</span> : proofTreeOf j1) (<span class="nv">P2</span> : proofTreeOf j2) : bool :=
<span class="kr">match</span> P1,P2 <span class="kr">with</span>
| <span class="nb">admit</span> j1,<span class="nb">admit</span> j2 =&gt; beq j1 j2
| leaf c1, leaf c2 =&gt; beq c1 c2
| assume e a1 C1 M1, assume e2 a2 C2 M2 =&gt; beq e e2 &amp;&amp; beq a1 a2 &amp;&amp; beq C1 C2 &amp;&amp; beqProofTreeOf M1 M2
| bot_elim a1 C1 M1, bot_elim a2 C2 M2 =&gt; beq a1 a2 &amp;&amp; beq C1 C2 &amp;&amp; beqProofTreeOf M1 M2
| and_intro a C1 C2 L R, and_intro a&#39; C1&#39; C2&#39; L&#39; R&#39; =&gt; beq a a&#39; &amp;&amp; beq C1 C1&#39; &amp;&amp; beq C2 C2&#39; &amp;&amp; beqProofTreeOf L L&#39; &amp;&amp; beqProofTreeOf R R&#39;
| and_elim1 a C1 C2 M, and_elim1 a&#39; C1&#39; C2&#39; M&#39; =&gt; beq a a&#39; &amp;&amp; beq C1 C1&#39; &amp;&amp; beq C2 C2&#39; &amp;&amp; beqProofTreeOf M M&#39;
| and_elim2 a C1 C2 M, and_elim2 a&#39; C1&#39; C2&#39; M&#39; =&gt; beq a a&#39; &amp;&amp; beq C1 C1&#39; &amp;&amp; beq C2 C2&#39; &amp;&amp; beqProofTreeOf M M&#39;
| or_intro1 a C1 C2 M, or_intro1 a&#39; C1&#39; C2&#39; M&#39; =&gt; beq a a&#39; &amp;&amp; beq C1 C1&#39; &amp;&amp; beq C2 C2&#39; &amp;&amp; beqProofTreeOf M M&#39;
| or_intro2 a C1 C2 M, or_intro2 a&#39; C1&#39; C2&#39; M&#39; =&gt; beq a a&#39; &amp;&amp; beq C1 C1&#39; &amp;&amp; beq C2 C2&#39; &amp;&amp; beqProofTreeOf M M&#39;
| or_elim1 a C1 C2 M, or_elim1 a&#39; C1&#39; C2&#39; M&#39; =&gt; beq a a&#39; &amp;&amp; beq C1 C1&#39; &amp;&amp; beq C2 C2&#39; &amp;&amp; beqProofTreeOf M M&#39;
| or_elim2 a C1 C2 M, or_elim2 a&#39; C1&#39; C2&#39; M&#39; =&gt; beq a a&#39; &amp;&amp; beq C1 C1&#39; &amp;&amp; beq C2 C2&#39; &amp;&amp; beqProofTreeOf M M&#39;
| trust a1 a2 C name L, trust a1&#39; a2&#39; C&#39; name&#39; L&#39; =&gt; beq a1 a1&#39; &amp;&amp; beq a2 a2&#39; &amp;&amp; beq C C&#39; &amp;&amp; beq name name&#39; &amp;&amp; beqProofTreeOf L L&#39;
| impl_intro e C1 a C2 M, impl_intro e&#39; C1&#39; a&#39; C2&#39; M&#39; =&gt; beq e e&#39; &amp;&amp; beq C1 C1&#39; &amp;&amp; beq a a&#39; &amp;&amp; beq C2 C2&#39; &amp;&amp; beqProofTreeOf M M&#39;
| impl_elim a C1 C2 L R, impl_elim a&#39; C1&#39; C2&#39; L&#39; R&#39; =&gt; beq a a&#39; &amp;&amp; beq C1 C1&#39; &amp;&amp; beq C2 C2&#39; &amp;&amp; beqProofTreeOf L L&#39; &amp;&amp; beqProofTreeOf R R&#39;
| _,_ =&gt; false
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">beqProofTreeOfSameJudgement</span> (<span class="nv">j</span> : judgement) (<span class="nv">P1</span> <span class="nv">P2</span> : proofTreeOf j) :=
  @beqProofTreeOf j j P1 P2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">beqProofTreeOfSameJudgementInstance</span> (<span class="nv">j</span> : judgement) : Beq (proofTreeOf j) := { beq := beqProofTreeOf }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showProofTreeOfHelper</span> (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j)
  : string :=
<span class="kr">let</span> <span class="nv">Ts</span> := (removeDups (getAllTrustRelationsUsed j p)) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">Ps</span> := (removeDups (getAssumptionsWithEvidence j p)) <span class="kr">in</span>
<span class="kr">match</span> p <span class="kr">with</span>
| <span class="nb">admit</span> j =&gt; <span class="s2">&quot;\AxiomC{? $&quot;</span> ++ (showJudgementForAdmits j) ++ <span class="s2">&quot;$ ?}&quot;</span>
| leaf c =&gt; <span class="s2">&quot;\AxiomC{$ &quot;</span> 
             ++ show c 
             ++ <span class="s2">&quot; \textit{ is a veracity claim} $}&quot;</span>
| assume e a c M =&gt; showProofTreeOfHelper _ M
    ++ <span class="s2">&quot; \RightLabel{ $ assume $}\UnaryInfC{$ &quot;</span>
    ++ showJudgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
| bot_elim a C M =&gt; showProofTreeOfHelper _ M
    ++ <span class="s2">&quot; \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ &quot;</span>
    ++ showJudgement Ps Ts _ p
    ++ <span class="s2">&quot; $}&quot;</span>
| and_intro a C1 C2 L R =&gt; 
    showProofTreeOfHelper _ L
 ++ showProofTreeOfHelper _ R 
 ++ <span class="s2">&quot; \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ &quot;</span>
 ++ showJudgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
| and_elim1 a C1 C2 M =&gt; showProofTreeOfHelper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \land^{-1} $} \UnaryInfC{$ &quot;</span>
 ++ showJudgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| and_elim2 a C1 C2 M =&gt; showProofTreeOfHelper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \land^{-2} $} \UnaryInfC{$ &quot;</span>
 ++ showJudgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_intro1 a C1 C2 M =&gt; showProofTreeOfHelper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{+1} $} \UnaryInfC{$ &quot;</span>
 ++ showJudgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_intro2 a C1 C2 M =&gt; showProofTreeOfHelper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{+2} $} \UnaryInfC{$ &quot;</span>
 ++ showJudgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_elim1 a C1 C2 M =&gt; showProofTreeOfHelper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{-1} $} \UnaryInfC{$ &quot;</span>
 ++ showJudgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_elim2 a C1 C2 M =&gt; showProofTreeOfHelper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{-2} $} \UnaryInfC{$ &quot;</span>
 ++ showJudgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| trust a1 a2 C name L =&gt; 
    showProofTreeOfHelper _ L
 ++ <span class="s2">&quot; \AxiomC{$&quot;</span> ++ show a1 ++ show name ++ show a2 ++ <span class="s2">&quot;$} &quot;</span>
 ++ <span class="s2">&quot; \RightLabel{ $ trust\ &quot;</span> ++ show name
 ++ <span class="s2">&quot;$} \BinaryInfC{$ &quot;</span>
 ++ showJudgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
| impl_intro e1 C1 a C2 M =&gt; showProofTreeOfHelper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ &quot;</span>
 ++ showJudgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| impl_elim a C1 C2 L R =&gt; 
     showProofTreeOfHelper _ L
 ++ showProofTreeOfHelper _ R 
 ++ <span class="s2">&quot; \RightLabel{ $ \rightarrow^{-} $} \BinaryInfC{$ &quot;</span>
 ++ showJudgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Fixpoint showLongProofTreeOfHelper (indent : string) (j : judgement) (p : proofTreeOf j)</span>
<span class="c">  : string :=</span>
<span class="c">let Ts := (removeDups (getAllTrustRelationsUsed j p)) in</span>
<span class="c">let Ps := (removeDups (getAssumptions j p)) in</span>
<span class="c">match p with</span>
<span class="c">| admit p =&gt; indent ++ &quot;we stopped the proof at this point and assumed it was provable.&quot;</span>
<span class="c">| leaf c =&gt; indent ++ showLong c ++ &quot; is a veracity claim.&quot;</span>
<span class="c">| assume e a c M =&gt; </span>
<span class="c">indent ++ showLongJudgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by assumption.&quot;</span>
<span class="c">| bot_elim a C M =&gt;</span>
<span class="c">indent ++ showLongJudgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by the logical principle of explosion.&quot;</span>
<span class="c">| and_intro a C1 C2 L R =&gt; </span>
<span class="c">indent ++ showLongJudgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ L ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ R ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;and&#39;.&quot;</span>
<span class="c">| and_elim1 a C1 C2 M =&gt;</span>
<span class="c">indent ++ showLongJudgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;and&#39;.&quot;</span>
<span class="c">| and_elim2 a C1 C2 M =&gt; </span>
<span class="c">indent ++ showLongJudgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;and&#39;.&quot;</span>
<span class="c">| or_intro1 a C1 C2 M =&gt;</span>
<span class="c">indent ++ showLongJudgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;or&#39;.&quot;</span>
<span class="c">| or_intro2 a C1 C2 M =&gt;</span>
<span class="c">indent ++ showLongJudgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;or&#39;.&quot;</span>
<span class="c">| or_elim1 a C1 C2 M =&gt;</span>
<span class="c">indent ++ showLongJudgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;or&#39;.&quot;</span>
<span class="c">| or_elim2 a C1 C2 M =&gt; </span>
<span class="c">indent ++ showLongJudgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;or&#39;.&quot;</span>
<span class="c">| trust a1 a2 C name L =&gt; </span>
<span class="c">indent ++ showLongJudgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ L ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by the trust relation &quot; ++ showLong name ++ &quot;.&quot;</span>
<span class="c">| impl_intro e1 C1 a C2 M =&gt; </span>
<span class="c">indent ++ showLongJudgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for implication.&quot;</span>
<span class="c">| impl_elim a C1 C2 L R =&gt; </span>
<span class="c">indent ++ showLongJudgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ L ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ showLongProofTreeOfHelper (&quot;  &quot; ++ indent) _ R ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for implication.&quot;</span>
<span class="c">end. *)</span>



<span class="c">(* Fixpoint showLong2ProofTreeOfHelper (indent : string) (j : judgement) (p : proofTreeOf j)</span>
<span class="c">  : string :=</span>
<span class="c">let Ts := (removeDups (getAllTrustRelationsUsed j p)) in</span>
<span class="c">let Ps := (removeDups (getAssumptions j p)) in</span>
<span class="c">match p with</span>
<span class="c">| admit p =&gt; indent ++ &quot;- &quot; ++ &quot;We stopped the proof at this point and assumed it was provable.&quot;</span>
<span class="c">| leaf c =&gt; indent ++ &quot;- &quot; ++ showLong2 c ++ &quot; is a veracity claim.&quot; (* We won&#39;t actually use this branch in ShowLong2 *)</span>
<span class="c">| assume e a c M =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showLong2Judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: we assume this&quot;</span>
<span class="c">| bot_elim a C M =&gt;</span>
<span class="c">indent ++ &quot;- &quot; ++ showLong2Judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: the principle of explosion</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| and_intro a C1 C2 L R =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showLong2Judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: and introduction</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proofs:</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ L ++ &quot;</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ R</span>
<span class="c">| and_elim1 a C1 C2 M =&gt;</span>
<span class="c">indent ++ &quot;- &quot; ++ showLong2Judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: and elimination (1)</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| and_elim2 a C1 C2 M =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showLong2Judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: and elimination (2)</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| or_intro1 a C1 C2 M =&gt;</span>
<span class="c">indent ++ &quot;- &quot; ++ showLong2Judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: or introduction (1)</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| or_intro2 a C1 C2 M =&gt;</span>
<span class="c">indent ++ &quot;- &quot; ++ showLong2Judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: or introduction (2)</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| or_elim1 a C1 C2 M =&gt;</span>
<span class="c">indent ++ &quot;- &quot; ++ showLong2Judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: or elimination (1)</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| or_elim2 a C1 C2 M =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showLong2Judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: or elimination (2)</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| trust a1 a2 C name L =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showLong2Judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: trust, with relation &quot; ++ showLong2 name ++ &quot;</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ L</span>
<span class="c">| impl_intro e1 C1 a C2 M =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showLong2Judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: implication introduction</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| impl_elim a C1 C2 L R =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showLong2Judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: implication elimination</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proofs:</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ L ++ &quot;</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper (&quot;      &quot; ++ indent) _ R</span>
<span class="c">end. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showProofTreeOf</span> <span class="nv">j</span> <span class="nv">p</span>
  := <span class="s2">&quot;\begin{prooftree}&quot;</span> ++ showProofTreeOfHelper j p
       ++ <span class="s2">&quot;\end{prooftree}&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showProofTreeOfInstance</span> (<span class="nv">j</span> : judgement)
  : <span class="kn">Show</span> (proofTreeOf j) := { show := showProofTreeOf j}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Definition showLongProofTreeOf j p := &quot;</span>

<span class="c">&quot; ++ showLongProofTreeOfHelper &quot;- &quot; j p ++ &quot;</span>

<span class="c">&quot;.</span>
<span class="c">Instance showLongProofTreeOfInstance (j : judgement)</span>
<span class="c">  : ShowLong (proofTreeOf j) := { showLong := showLongProofTreeOf j}. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">printProofTitle</span> <span class="nv">j</span> :=
<span class="kr">match</span> j <span class="kr">with</span>
| Entail (SingleJudgement a c) =&gt; <span class="s2">&quot;### Veracity proof that &quot;</span> ++ showLong2 c ++ <span class="s2">&quot; is held by &quot;</span> ++ showLong2 a
| IsAVeracityClaim c =&gt; <span class="s2">&quot;### Veracity proof that &quot;</span> ++ showLong2 c ++ <span class="s2">&quot; is a veracity claim&quot;</span>
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Definition showLong2ProofTreeOf j p := &quot;</span>

<span class="c">&quot; ++ printProofTitle j ++ &quot;</span>
<span class="c">&quot; ++ showLong2ProofTreeOfHelper &quot;  &quot; j p ++ &quot;</span>
<span class="c">  - Atomic evidence is abbreviated as follows:</span>
<span class="c">    collapsed:: true</span>
<span class="c">&quot; ++ showLong2List &quot;    &quot; (map showEvidNamePair (removeDups (filter isAtomicEvidence (getAllEvidence j p)))) ++ &quot;</span>

<span class="c">&quot;.</span>
<span class="c">Instance showLong2ProofTreeOfInstance (j : judgement)</span>
<span class="c">  : ShowLong2 (proofTreeOf j) := { showLong2 := showLong2ProofTreeOf j}. *)</span>


<span class="c">(* |</span>

<span class="c">Proof Automation without Ltac</span>
<span class="c">-----------------------------</span>

<span class="c">The approach taken here is to search for proofs using Coq&#39;s functional language, rather than relying on Ltac.</span>
<span class="c">This will:</span>
<span class="c"> - Perform backwards search</span>
<span class="c"> - Use &quot;admit&quot; (which may in future be renamed &quot;hole&quot;) to fill in holes in the current proofs search.</span>
<span class="c"> - Involve a function which takes a single proof tree (potentially containing holes), and generates a list of proof trees &quot;one level deeper&quot;, potentially including holes.</span>
<span class="c"> - Include a depth limit, after which the proof search is halted.</span>
<span class="c"> - Include a function to filter out proof trees based on whether they still contain holes, (and in the future other attributes such as whether the resulting weight is above a certain value)</span>
<span class="c"> - Involve a function that takes a list of prooftrees and returns a list of prooftrees &quot;one level deeper&quot;, making use of the function which takes a single proof tree as input.</span>

<span class="c">|*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">toProofTreeWithHole</span> (<span class="nv">a</span> : actor) (<span class="nv">c</span> : claim) := <span class="nb">admit</span> (||- \<span class="bp">by</span> a \<span class="kr">in</span> c).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Definition atomicClaimInfo (name : namePair) : option evid :=</span>
<span class="c">  match name with</span>
<span class="c">    | NamePair &quot;e_{no}&quot; &quot;no evidence&quot; =&gt; None</span>
<span class="c">    | _ =&gt; Some (AtomicEvid (NamePair &quot;e_{?}&quot; &quot;unknown evidence&quot;))</span>
<span class="c">  end. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">oneLevelDeeperJudgement</span> (<span class="nv">j</span> : judgement) : list (proofTreeOf j) :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | Entail (SingleJudgement a c) =&gt; 
    (<span class="kr">if</span> (beq a a1) &amp;&amp; (beq c C) <span class="kr">then</span> [assume e a c (leaf c)] <span class="kr">else</span> [])
    ++
    (<span class="kr">if</span> (beq a a2) &amp;&amp; (beq c C) <span class="kr">then</span> [assume e a c (leaf c)] <span class="kr">else</span> [])
    ++
    (<span class="kr">if</span> (beq a a1) &amp;&amp; (beq c (C /\&#39; C)) <span class="kr">then</span> [assume e a c (leaf c)] <span class="kr">else</span> [])
    ++
    <span class="kr">match</span> c <span class="kr">with</span>
      | AtomicClaim name =&gt; []
      | Bottom =&gt; []
      | And c1 c2 =&gt; [and_intro a c1 c2 (<span class="nb">admit</span> _) (<span class="nb">admit</span> _)] 
      | Or c1 c2 =&gt; []
      | Implies c1 c2 =&gt; []
      <span class="kr">end</span>
  | IsAVeracityClaim c =&gt; [leaf c]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv3-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chk8"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> oneLevelDeeperJudgement (||- \<span class="bp">by</span> a1 \<span class="kr">in</span> (C /\&#39; C)).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= [assume
     (AtomicEvid
        (NamePair _e_ <span class="s2">&quot;e&quot;</span> <span class="s2">&quot;example evidence e&quot;</span>))
     (Actor (NamePair _a1_ <span class="s2">&quot;a_{1}&quot;</span> <span class="s2">&quot;actor 1&quot;</span>))
     (AtomicClaim
        (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>) /\&#39;
      AtomicClaim
        (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>))
     (leaf
        (AtomicClaim
           (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>) /\&#39;
         AtomicClaim
           (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>)));
   and_intro
     (Actor (NamePair _a1_ <span class="s2">&quot;a_{1}&quot;</span> <span class="s2">&quot;actor 1&quot;</span>))
     (AtomicClaim
        (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>))
     (AtomicClaim
        (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>))
     (<span class="nb">admit</span>
        ||- \<span class="bp">by</span>
            Actor
              (NamePair _a1_ <span class="s2">&quot;a_{1}&quot;</span> <span class="s2">&quot;actor 1&quot;</span>) \<span class="kr">in</span>
            (AtomicClaim
               (NamePair _C_ <span class="s2">&quot;C&quot;</span>
                  <span class="s2">&quot;example evidence C&quot;</span>)))
     (<span class="nb">admit</span>
        ||- \<span class="bp">by</span>
            Actor
              (NamePair _a1_ <span class="s2">&quot;a_{1}&quot;</span> <span class="s2">&quot;actor 1&quot;</span>) \<span class="kr">in</span>
            (AtomicClaim
               (NamePair _C_ <span class="s2">&quot;C&quot;</span>
                  <span class="s2">&quot;example evidence C&quot;</span>)))]
: list (proofTreeOf ||- \<span class="bp">by</span> a1 \<span class="kr">in</span> (C /\&#39; C))</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">oneLevelDeeper</span> (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j) : list (proofTreeOf j) :=
  <span class="kr">match</span> p <span class="kr">with</span>
| <span class="nb">admit</span> j =&gt; oneLevelDeeperJudgement j
| leaf c =&gt; []
| assume e a name M =&gt; map (assume e a name) (oneLevelDeeper _ M)
| bot_elim a C M =&gt; map (bot_elim a C) (oneLevelDeeper _ M)
| and_intro a C1 C2 L R =&gt; map (<span class="kr">fun</span> <span class="nv">L2</span> =&gt; and_intro a C1 C2 L2 R) (oneLevelDeeper _ L)
                        ++ map (and_intro a C1 C2 L) (oneLevelDeeper _ R)
| and_elim1 a C1 C2 M =&gt; map (and_elim1 a C1 C2) (oneLevelDeeper _ M)
| and_elim2 a C1 C2 M =&gt; map (and_elim2 a C1 C2) (oneLevelDeeper _ M)
| or_intro1 a C1 C2 M =&gt; map (or_intro1 a C1 C2) (oneLevelDeeper _ M)
| or_intro2 a C1 C2 M =&gt; map (or_intro2 a C1 C2) (oneLevelDeeper _ M)
| or_elim1 a C1 C2 M =&gt; map (or_elim1 a C1 C2) (oneLevelDeeper _ M)
| or_elim2 a C1 C2 M =&gt; map (or_elim2 a C1 C2) (oneLevelDeeper _ M)
| trust a1 a2 C name L =&gt; map (trust a1 a2 C name) (oneLevelDeeper _ L)
| impl_intro e1 C1 a C2 M =&gt; map (impl_intro e1 C1 a C2) (oneLevelDeeper _ M)
| impl_elim a C1 C2 L R =&gt; map (<span class="kr">fun</span> <span class="nv">L2</span> =&gt; impl_elim a C1 C2 L2 R) (oneLevelDeeper _ L)
                        ++ map (impl_elim a C1 C2 L) (oneLevelDeeper _ R)
<span class="kr">end</span>
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv3-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chk9"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> oneLevelDeeper _ (toProofTreeWithHole a1 (C /\&#39; C)).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= [assume
     (AtomicEvid
        (NamePair _e_ <span class="s2">&quot;e&quot;</span> <span class="s2">&quot;example evidence e&quot;</span>))
     (Actor (NamePair _a1_ <span class="s2">&quot;a_{1}&quot;</span> <span class="s2">&quot;actor 1&quot;</span>))
     (AtomicClaim
        (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>) /\&#39;
      AtomicClaim
        (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>))
     (leaf
        (AtomicClaim
           (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>) /\&#39;
         AtomicClaim
           (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>)));
   and_intro
     (Actor (NamePair _a1_ <span class="s2">&quot;a_{1}&quot;</span> <span class="s2">&quot;actor 1&quot;</span>))
     (AtomicClaim
        (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>))
     (AtomicClaim
        (NamePair _C_ <span class="s2">&quot;C&quot;</span> <span class="s2">&quot;example evidence C&quot;</span>))
     (<span class="nb">admit</span>
        ||- \<span class="bp">by</span>
            Actor
              (NamePair _a1_ <span class="s2">&quot;a_{1}&quot;</span> <span class="s2">&quot;actor 1&quot;</span>) \<span class="kr">in</span>
            (AtomicClaim
               (NamePair _C_ <span class="s2">&quot;C&quot;</span>
                  <span class="s2">&quot;example evidence C&quot;</span>)))
     (<span class="nb">admit</span>
        ||- \<span class="bp">by</span>
            Actor
              (NamePair _a1_ <span class="s2">&quot;a_{1}&quot;</span> <span class="s2">&quot;actor 1&quot;</span>) \<span class="kr">in</span>
            (AtomicClaim
               (NamePair _C_ <span class="s2">&quot;C&quot;</span>
                  <span class="s2">&quot;example evidence C&quot;</span>)))]
: list (proofTreeOf ||- \<span class="bp">by</span> a1 \<span class="kr">in</span> (C /\&#39; C))</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">oneLevelDeeperOfList</span> <span class="nv">j</span> (<span class="nv">l</span> : list (proofTreeOf j)) : list (proofTreeOf j) :=
 removeDups (flat_map (oneLevelDeeper j) l).</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv3-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chka"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span>  show (oneLevelDeeperOfList _ (oneLevelDeeperOfList _ (oneLevelDeeper _ (toProofTreeWithHole a1 (C /\&#39; C /\&#39; C))))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{? $a_{1} \in C$ ?} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ?^{a_{1}} \in C \wedge C $}\AxiomC{? $a_{1} \in C$ ?} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ?^{a_{1}} \in C \wedge C \wedge C $}\end{prooftree}, \begin{prooftree}\AxiomC{? $a_{1} \in C$ ?}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ?^{a_{1}} \in C \wedge C $}\AxiomC{? $a_{1} \in C$ ?} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ?^{a_{1}} \in C \wedge C \wedge C $}\end{prooftree}, \begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C $}\end{prooftree}, \begin{prooftree}\AxiomC{? $a_{1} \in C$ ?}\AxiomC{? $a_{1} \in C$ ?} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ ?^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ?^{a_{1}} \in C \wedge C \wedge C $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">repeatFn</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">f</span> : A -&gt; A) :=
<span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; id
  | <span class="mi">1</span> =&gt; f
  | S n&#39; =&gt; <span class="kr">fun</span> <span class="nv">a</span> =&gt; f (repeatFn n&#39; f a)
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> list_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">repeatListFnAndKeepPartials</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{Beq A} (n : nat) (f : list A -&gt; list A) (l : list A) :=
<span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; []
  | <span class="mi">1</span> =&gt; removeDups (f l)
  | S n&#39; =&gt; removeDups ((f l) ++ f (repeatListFnAndKeepPartials n&#39; f l))
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">generateProofsWithDepthLimit</span> <span class="nv">j</span> <span class="nv">d</span> := repeatListFnAndKeepPartials d (oneLevelDeeperOfList j).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">noHoles</span> {<span class="nv">j</span> : judgement} (<span class="nv">p</span> : proofTreeOf j) : bool :=
  <span class="kr">match</span> p <span class="kr">with</span>
| <span class="nb">admit</span> j =&gt; false
| leaf c =&gt; true
| assume e a name M =&gt; noHoles M
| bot_elim a C M =&gt; noHoles M
| and_intro a C1 C2 L R =&gt; noHoles L &amp;&amp; noHoles R
| and_elim1 a C1 C2 M =&gt; noHoles M
| and_elim2 a C1 C2 M =&gt; noHoles M
| or_intro1 a C1 C2 M =&gt; noHoles M
| or_intro2 a C1 C2 M =&gt; noHoles M
| or_elim1 a C1 C2 M =&gt; noHoles M
| or_elim2 a C1 C2 M =&gt; noHoles M
| trust a1 a2 C name L =&gt; noHoles L
| impl_intro e1 C1 a C2 M =&gt; noHoles M
| impl_elim a C1 C2 L R =&gt; noHoles L &amp;&amp; noHoles R
<span class="kr">end</span>
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">proofSearch</span> (<span class="nv">j</span> : judgement) (<span class="nv">l</span> : list (proofTreeOf j)) (<span class="nv">d</span> : nat) : list (proofTreeOf j) := 
  <span class="kr">match</span> d <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; []
  | S d&#39; =&gt; <span class="kr">let</span> <span class="nv">newL</span> := removeDups (oneLevelDeeperOfList j l) <span class="kr">in</span> (filter noHoles newL) ++ proofSearch j (filter (<span class="kr">fun</span> <span class="nv">p</span> =&gt; negb (noHoles p)) newL) d&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** TODO: Try removing string comparison and replacing it with more native comparison, might cause speedup. *)</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv3-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chkb"><span class="kn">Time</span> <span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showListForProofs (( (proofSearch _  [toProofTreeWithHole a1 ((C /\&#39; C) /\&#39; (C /\&#39; C) /\&#39; (C /\&#39; C) /\&#39; (C /\&#39; C))] <span class="mi">20</span>)))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (((e, e), e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} (((e, e), e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((((e, e), e), e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (e, (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, (e, e)), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} (((e, (e, e)), e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} ((e, e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} (((e, e), (e, e)), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (((e, e), e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ((e, e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} (((e, e), (e, e)), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((((e, e), (e, e)), e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (((e, e), e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((((e, e), e), (e, e)), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (e, (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} ((e, (e, e)), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} (((e, (e, e)), (e, e)), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} (((e, e), e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} ((((e, e), e), e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (e, (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, (e, e)), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (((e, (e, e)), e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} ((e, e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (((e, e), (e, e)), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ((e, e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (((e, e), (e, e)), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((((e, e), (e, e)), (e, e)), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ((e, e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} (((e, e), (e, e)), e)^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} ((((e, e), (e, e)), e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (((e, e), e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} ((((e, e), e), (e, e)), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (e, (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} ((e, (e, e)), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (((e, (e, e)), (e, e)), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ((e, e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (((e, e), (e, e)), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ((((e, e), (e, e)), (e, e)), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C \wedge C $}\end{prooftree}&quot;</span>
     : string</blockquote><blockquote class="alectryon-message">Finished transaction <span class="kr">in</span> <span class="mi">144</span>.<span class="mi">593</span> secs (<span class="mi">144</span>.<span class="mi">566</span>u,<span class="mi">0</span>.<span class="mi">023</span>s) (successful)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogicv3-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chkc"><span class="kn">Time</span> <span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showListForProofs ( filter noHoles (( (generateProofsWithDepthLimit _ <span class="mi">7</span>  [toProofTreeWithHole a1 ((C /\&#39; C) /\&#39; (C /\&#39; C))]))))).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} (e, e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C, e^{a_{1}} \in C \wedge C \vdash_{} ((e, e), e)^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \wedge C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \wedge C \vdash_{} e^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \wedge C, e^{a_{1}} \in C \vdash_{} (e, (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}</span>

<span class="s2">----------------</span>

<span class="s2">\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C \vdash_{} e^{a_{1}} \in C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} (e, e)^{a_{1}} \in C \wedge C $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C \vdash_{} ((e, e), (e, e))^{a_{1}} \in C \wedge C \wedge C \wedge C $}\end{prooftree}&quot;</span>
     : string</blockquote><blockquote class="alectryon-message">Finished transaction <span class="kr">in</span> <span class="mi">0</span>.<span class="mi">3</span> secs (<span class="mi">0</span>.<span class="mi">298</span>u,<span class="mi">0</span>.<span class="mi">002</span>s) (successful)</blockquote></div></div></small></span></pre></div>
<div class="section" id="an-example-from-the-paper">
<h1>An example from the paper</h1>
<p>This example is the top half of the proof tree on p13 (Section 4.2) of the draft paper.</p>
<p>The proof trees visualised in this section are <strong>automatically generated</strong> by Coq.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogicv3-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogicv3-v-chkd"><span class="kn">Definition</span> <span class="nf">l</span> := AtomicEvid (NamePair <span class="s2">&quot;l&quot;</span> <span class="s2">&quot;example evidence l&quot;</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">In environment
e4 : evid
c4 : claim
The term <span class="s2">&quot;&quot;</span>l<span class="s2">&quot;&quot;</span> has type <span class="s2">&quot;string&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;name&quot;</span>.</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">s</span> := AtomicEvid (NamePair <span class="s2">&quot;s&quot;</span> <span class="s2">&quot;example evidence s&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c</span> := AtomicEvid (NamePair <span class="s2">&quot;c&quot;</span> <span class="s2">&quot;example evidence c&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">P</span> := Actor (NamePair <span class="s2">&quot;P&quot;</span> <span class="s2">&quot;Penelope&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Q</span> := Actor (NamePair <span class="s2">&quot;Q&quot;</span> <span class="s2">&quot;Quintin&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C1</span> := AtomicClaim (NamePair <span class="s2">&quot;C_1&quot;</span> <span class="s2">&quot;claim 1&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C2</span> := AtomicClaim (NamePair <span class="s2">&quot;C_2&quot;</span> <span class="s2">&quot;claim 2&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C3</span> := AtomicClaim (NamePair <span class="s2">&quot;C_3&quot;</span> <span class="s2">&quot;claim 3&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C4</span> := AtomicClaim (NamePair <span class="s2">&quot;C_4&quot;</span> <span class="s2">&quot;claim 4&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C5</span> := AtomicClaim (NamePair <span class="s2">&quot;C_5&quot;</span> <span class="s2">&quot;claim 5&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trustT</span> := Trust (NamePair <span class="s2">&quot;T&quot;</span> <span class="s2">&quot;T&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trustU</span> := Trust (NamePair <span class="s2">&quot;U&quot;</span> <span class="s2">&quot;U&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trustV</span> := Trust (NamePair <span class="s2">&quot;V&quot;</span> <span class="s2">&quot;V&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concreteProofTreeExampleWith2Conjuncts</span> : 
proofTreeOf ( ||- \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">epose proof</span> (and_intro _ C1 C2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span> <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume l).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume s).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (show concreteProofTreeExampleWith2Conjuncts).</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showLong concreteProofTreeExampleWith2Conjuncts).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 concreteProofTreeExampleWith2Conjuncts.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concreteProofTreeExampleWith3Conjuncts</span> : 
proofTreeOf ( ||- \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">epose proof</span> (and_intro) P (C1 /\&#39; C2) C3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span> <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">epose proof</span> (and_intro) _ C1 C2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span> <span class="kr">in</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume l).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume s).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume c).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (show concreteProofTreeExampleWith3Conjuncts).</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showLong concreteProofTreeExampleWith3Conjuncts).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 concreteProofTreeExampleWith3Conjuncts.</span></span></pre><p>We can also combine existing trees into new trees, when appropriate. For example:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concreteProofTreeExampleWith3ConjunctsUsingExistingTree</span> : 
proofTreeOf  ||- \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">epose proof</span> (and_intro) P (C1 /\&#39; C2) C3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span> <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> concreteProofTreeExampleWith2Conjuncts.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Show Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume c).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (show concreteProofTreeExampleWith3Conjuncts).</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showLong concreteProofTreeExampleWith3Conjuncts).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 concreteProofTreeExampleWith3Conjuncts.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concreteProofTreeExampleTrust</span> : 
proofTreeOf ||- \<span class="bp">by</span> a1 \<span class="kr">in</span> (C).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (trust a1 a2 C trustT).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume e).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (show concreteProofTreeExampleTrust).</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showLong concreteProofTreeExampleTrust).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 concreteProofTreeExampleTrust.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concreteProofTreeExampleWith3ConjunctsWithTrust</span> : 
proofTreeOf ||- \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (trust _ _ _ trustU).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concreteProofTreeExampleWith3ConjunctsUsingExistingTree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (show concreteProofTreeExampleWith3ConjunctsWithTrust).</span><span class="alectryon-wsp"> </span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showLong concreteProofTreeExampleWith3ConjunctsWithTrust).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 concreteProofTreeExampleWith3ConjunctsWithTrust.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras</span> : 
proofTreeOf ||- \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (trust Q Q _ trustU).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (trust Q Q _ trustV).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (trust _ _ _ trustU).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concreteProofTreeExampleWith3ConjunctsUsingExistingTree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Show Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (show concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras).</span><span class="alectryon-wsp"> </span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showLong concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">proofTreeOfClaim</span> (<span class="nv">c</span> : claim) := {
  _a : actor;
  _p : proofTreeOf ||- (\<span class="bp">by</span> _a \<span class="kr">in</span> c)
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showProofTreeOfClaim</span> (<span class="nv">c</span> : claim) : <span class="kn">Show</span> (proofTreeOfClaim c) := { show p := show (_p c p) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Instance showLongProofTreeOfClaim (c : claim) : ShowLong (proofTreeOfClaim c) := { showLong p := showLong (_p c p) }. *)</span>
<span class="c">(* Instance showLong2ProofTreeOfClaim (c : claim) : ShowLong2 (proofTreeOfClaim c) := { showLong2 p := showLong2 (_p c p) }. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">exampleWithProofOf</span> : proofTreeOfClaim C1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eexists</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume e1 a1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> show exampleWithProofOf.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong exampleWithProofOf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 exampleWithProofOf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">usingAll</span> : proofTreeOfClaim (Implies _|_ C1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eexists</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (or_elim1 _ _ C2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> or_intro1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (or_elim2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> or_intro2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> and_elim1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> and_intro.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> and_elim2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> and_intro.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume e2 a1); <span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">2</span>: <span class="nb">apply</span> (assume e2 a1); <span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (trust _ _ _ trustT).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (impl_intro e2 _|_ a1 C1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> bot_elim.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume e2 a1 _|_).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unshelve</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Show Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">apply</span> C2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> show usingAll.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong usingAll.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 usingAll.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">proveClaim</span> := 
<span class="c">(* unshelve eexists _ _ _; *)</span>
(<span class="kp">repeat</span> ( 
<span class="kp">idtac</span>
<span class="c">(* + unshelve eapply or_elim1 *)</span>
<span class="c">(* + unshelve eapply admit *)</span>
+ <span class="nb">unshelve</span> <span class="nb">eapply</span> or_intro1
<span class="c">(* + unshelve eapply or_elim2 *)</span>
+ <span class="nb">unshelve</span> <span class="nb">eapply</span> or_intro2
<span class="c">(* + unshelve eapply and_elim1 *)</span>
+ <span class="nb">unshelve</span> <span class="nb">eapply</span> and_intro
<span class="c">(* + unshelve eapply and_elim2 *)</span>
+ <span class="nb">unshelve</span> <span class="nb">eapply</span> and_intro; <span class="nb">simpl</span>
+ <span class="nb">unshelve</span> <span class="nb">apply</span> assume
+ <span class="nb">unshelve</span> <span class="nb">apply</span> leaf
<span class="c">(* + unshelve eapply (trust _ _ _ _ _ (Trust &quot;T&quot;)) *)</span>
+ <span class="nb">unshelve</span> <span class="nb">eapply</span> (impl_intro)
+ <span class="nb">simpl</span>
+ <span class="nb">unshelve</span> <span class="nb">eapply</span> bot_elim));
<span class="kp">repeat</span> (<span class="nb">apply</span> a1
+ <span class="nb">apply</span> C2
+ <span class="nb">apply</span> e2
+ <span class="nb">apply</span> [])
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="kn">From</span> <span class="kn">Ltac2</span> <span class="kn">Require Import</span> <span class="kn">Ltac2</span>.

<span class="kn">Definition</span> <span class="nf">eQ</span> := AtomicEvid (NamePair <span class="s2">&quot;e_{?}&quot;</span> <span class="s2">&quot;unknown evidence&quot;</span>).
<span class="kn">Definition</span> <span class="nf">CQ</span> := AtomicClaim (NamePair <span class="s2">&quot;C_{?}&quot;</span> <span class="s2">&quot;unknown claim&quot;</span>).
<span class="kn">Definition</span> <span class="nf">aQ</span> := Actor (NamePair <span class="s2">&quot;a_{?}&quot;</span> <span class="s2">&quot;unknown actor&quot;</span>).

<span class="c">(* Ltac2 maybePrintMessage1 s := Message.print (Message.of_string s). *)</span>
<span class="c">(* Ltac2 maybePrintMessage2 s := Message.print (Message.of_string s). *)</span>
<span class="kn">Ltac2</span> maybePrintMessage1 s := ().
<span class="kn">Ltac2</span> maybePrintMessage2 s := ().
<span class="kn">Ltac2 Type</span> exn ::= [ VeracityProofSearchException(string) ].

<span class="kn">Ltac2</span> tryLeaf etc :=
maybePrintMessage1 <span class="s2">&quot;Trying leaf&quot;</span>;
<span class="kr">match! goal with</span>
   | [ |- proofTreeOf (IsAVeracityClaim _) ] =&gt; (maybePrintMessage2 <span class="s2">&quot;Applying leaf&quot;</span>); (<span class="nb">eapply</span> leaf); etc
   | [ |- _ ] =&gt; <span class="kp">fail</span>
<span class="kr">end</span>.

<span class="kn">Ltac2</span> tryAssumeWitha1 etc :=
(maybePrintMessage1 <span class="s2">&quot;Trying assume&quot;</span>);
<span class="kr">match! goal with</span>
   | [ |- proofTreeOf _ ] =&gt; (maybePrintMessage2 <span class="s2">&quot;Applying assume&quot;</span>); <span class="nb">eapply</span> (assume _ a1); etc
   | [ |- _ ] =&gt; Control.zero (VeracityProofSearchException <span class="s2">&quot;Didn&#39;t match&quot;</span>)
<span class="kr">end</span>.

<span class="kn">Ltac2</span> tryAndIntro etc :=
(maybePrintMessage1 <span class="s2">&quot;Trying and_intro&quot;</span>);
<span class="kr">match! goal with</span>
   | [ |- (proofTreeOf _ ||- _ \<span class="bp">by</span> _ \<span class="kr">in</span> (_ /\&#39; _)) ] =&gt; (maybePrintMessage2 <span class="s2">&quot;Applying and_intro&quot;</span>); <span class="nb">eapply</span> and_intro; Control.enter (<span class="kr">fun</span> <span class="nv">_</span> =&gt; etc)
   | [ |- _ ] =&gt; Control.zero (VeracityProofSearchException <span class="s2">&quot;Didn&#39;t match&quot;</span>)
<span class="kr">end</span>.

<span class="kn">Ltac2</span> tryTrust etc :=
(maybePrintMessage1 <span class="s2">&quot;Trying trust&quot;</span>);
<span class="kr">match! goal with</span>
   | [ |- proofTreeOf _ ] =&gt; (maybePrintMessage2 <span class="s2">&quot;Applying trust&quot;</span>); (<span class="nb">eapply</span> (trust _ _ _ _ _ _)); etc
   | [ |- _ ] =&gt; Control.zero (VeracityProofSearchException <span class="s2">&quot;Didn&#39;t match&quot;</span>)
<span class="kr">end</span>.

<span class="kn">Ltac2</span> fillConstant () :=
<span class="kp">solve</span> [ <span class="nb">apply</span> CQ | <span class="nb">apply</span> aQ | <span class="nb">apply</span> eQ | <span class="nb">apply</span> ([] : list singleJudgement) | <span class="nb">apply</span> (Trust <span class="s2">&quot;?&quot;</span>) ].

<span class="kt">Set</span> Default <span class="kn">Proof</span> Mode <span class="s2">&quot;Ltac2&quot;</span>.
<span class="c">(* Set Ltac2 Backtrace. *)</span>

<span class="kn">Ltac2 rec</span> autoProveMain max_depth :=
<span class="kr">match</span> Int.equal <span class="mi">0</span> max_depth <span class="kr">with</span>
  | true =&gt; Control.zero (VeracityProofSearchException (<span class="s2">&quot;Ran out of depth.&quot;</span>))
  <span class="c">(* | true =&gt; () *)</span>
  | false =&gt; <span class="kp">solve</span> [
      <span class="nb">eapply</span> and_intro; autoProveMain (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume eQ a1); autoProveMain (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> leaf; autoProveMain (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (trust _ _ _); autoProveMain (Int.sub max_depth <span class="mi">1</span>)
    | fillConstant (); autoProveMain (Int.sub max_depth <span class="mi">1</span>)
  ]
<span class="kr">end</span>.

<span class="kn">Ltac2 rec</span> autoProveHelper d :=
 Message.print (Message.of_string <span class="s2">&quot;Depth:&quot;</span>);
 Message.print (Message.of_int d);
 <span class="kp">solve</span> [ autoProveMain d | autoProveHelper (Int.add d <span class="mi">1</span>) ].

<span class="kn">Ltac2</span> autoProve () := autoProveHelper <span class="mi">1</span>.</span></pre><p>The following demonstrates a constraing that the claim must be believed by actor 2, and we have constrained only assuming claims for actor 1 in the tactic.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">exampleC1</span> : proofTreeOfClaim (C2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eexists</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">autoProve ().</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Show Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> show exampleC1.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong exampleC1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 exampleC1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="kt">Set</span> Default <span class="kn">Proof</span> Mode <span class="s2">&quot;Ltac2&quot;</span>.</span></pre><p>The following demonstrates automatically proving a larger claim.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(*  *)</span>
<span class="c">(* Set Default Goal Selector &quot;!&quot;. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">automatedProof</span> : proofTreeOfClaim (C1 /\&#39; C2 /\&#39; C3 /\&#39; C4 /\&#39; C5).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eexists</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Time</span> autoProve ().  <span class="c">(* Finished transaction in 0.1 secs (0.099u,0.s) (successful) *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Time autoProve (). Using match statements Finished transaction in 0.188 secs (0.181u,0.004s) (successful) *)</span>
<span class="c">(* Time autoProveMain 7. Finished transaction in 0.002 secs (0.002u,0.s) (successful) *)</span>
<span class="c">(* Time autoProveMain ().  Finished transaction in 1.503 secs (1.475u,0.s) (successful) *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Show Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> show automatedProof.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong automatedProof.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 automatedProof.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="kn">Ltac2 rec</span> autoProveMain1 max_depth :=
<span class="kr">match</span> Int.equal <span class="mi">0</span> max_depth <span class="kr">with</span>
  | true =&gt; Control.zero (VeracityProofSearchException (<span class="s2">&quot;Ran out of depth.&quot;</span>))
  <span class="c">(* | true =&gt; () *)</span>
  | false =&gt; <span class="kp">solve</span> [
      <span class="nb">eapply</span> and_intro; autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (impl_intro); autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume l P C1); autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume s P C2); autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume c P C3); autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> leaf; autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">simpl</span>; autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
    <span class="c">(* | eapply (trust _ _ _ _ _ _); autoProveMain1 (Int.sub max_depth 1) *)</span>
    | fillConstant (); autoProveMain1 (Int.sub max_depth <span class="mi">1</span>)
  ]
<span class="kr">end</span>.

<span class="kn">Ltac2 rec</span> autoProveHelper1 d :=
 Message.print (Message.of_string <span class="s2">&quot;Depth:&quot;</span>);
 Message.print (Message.of_int d);
 <span class="kp">solve</span> [ autoProveMain1 d | autoProveHelper1 (Int.add d <span class="mi">1</span>) ].

<span class="kn">Ltac2</span> autoProve1 () := autoProveHelper1 <span class="mi">1</span>.

<span class="kn">Definition</span> <span class="nf">fromPaper1</span> : proofTreeOfClaim (C1 /\&#39; C2 /\&#39; C3).
<span class="kn">Proof</span>.
<span class="nb">eexists</span> _.
autoProve1 ().
<span class="kn">Show Proof</span>.
<span class="kn">Defined</span>.</span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> show fromPaper1.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong fromPaper1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 fromPaper1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">healthy</span> := AtomicClaim (NamePair <span class="s2">&quot;H&quot;</span> <span class="s2">&quot;healthy&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">nonToxic</span> := AtomicClaim (NamePair <span class="s2">&quot;N&quot;</span> <span class="s2">&quot;non-toxic&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">organic</span> := AtomicClaim (NamePair <span class="s2">&quot;O&quot;</span> <span class="s2">&quot;organic&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">belief</span> := AtomicEvid (NamePair <span class="s2">&quot;b&quot;</span> <span class="s2">&quot;belief&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">testing</span> := AtomicEvid (NamePair <span class="s2">&quot;t&quot;</span> <span class="s2">&quot;testing&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">audit</span> := AtomicEvid (NamePair <span class="s2">&quot;a&quot;</span> <span class="s2">&quot;audit&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">retailer</span> := Actor (NamePair <span class="s2">&quot;r&quot;</span> <span class="s2">&quot;retailer&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">vineyard</span> := Actor (NamePair <span class="s2">&quot;v&quot;</span> <span class="s2">&quot;vineyard&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">winery</span> := Actor (NamePair <span class="s2">&quot;w&quot;</span> <span class="s2">&quot;winery&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">exampleFromJosh</span> : proofTreeOfClaim healthy.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eexists</span> retailer.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (impl_elim _ (nonToxic /\&#39; organic)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">try</span> (<span class="nb">apply</span> (assume belief retailer (Implies (nonToxic /\&#39; organic) healthy))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">try</span> (<span class="nb">apply</span> (assume testing vineyard nonToxic)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">try</span> (<span class="nb">apply</span> (assume audit winery organic)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> and_intro.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (trust retailer vineyard _ trustT).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">try</span> (<span class="nb">apply</span> (assume belief retailer (Implies (nonToxic /\&#39; organic) healthy))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">try</span> (<span class="nb">apply</span> (assume testing vineyard nonToxic)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">try</span> (<span class="nb">apply</span> (assume audit winery organic)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (trust retailer winery _ trustT).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">try</span> (<span class="nb">apply</span> (assume belief retailer (Implies (nonToxic /\&#39; organic) healthy))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">try</span> (<span class="nb">apply</span> (assume testing vineyard nonToxic)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">try</span> (<span class="nb">apply</span> (assume audit winery organic)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Show Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> show exampleFromJosh.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong exampleFromJosh.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 exampleFromJosh.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="kn">Ltac2 rec</span> autoProveMain2 max_depth :=
<span class="kr">match</span> Int.equal <span class="mi">0</span> max_depth <span class="kr">with</span>
  | true =&gt; Control.zero (VeracityProofSearchException (<span class="s2">&quot;Ran out of depth.&quot;</span>))
  <span class="c">(* | true =&gt; () *)</span>
  | false =&gt; <span class="kp">solve</span> [
      <span class="nb">eapply</span> and_intro; autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (impl_elim); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (trust retailer vineyard _ trustT); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (trust retailer winery _ trustT); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume testing vineyard nonToxic); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume belief retailer (Implies (nonToxic /\&#39; organic) healthy)); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> (assume audit winery organic); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    | <span class="nb">eapply</span> leaf; autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
    <span class="c">(* | simpl; autoProveMain2 (Int.sub max_depth 1) *)</span>
    <span class="c">(* | eapply (trust _ _ _ _ _ _); autoProveMain2 (Int.sub max_depth 1) *)</span>
    | fillConstant (); autoProveMain2 (Int.sub max_depth <span class="mi">1</span>)
  ]
<span class="kr">end</span>.

<span class="kn">Ltac2 rec</span> autoProveHelper2 d max_depth :=
 Message.print (Message.of_string <span class="s2">&quot;Depth:&quot;</span>);
 Message.print (Message.of_int d);
 <span class="kr">match</span> Int.lt d max_depth <span class="kr">with</span>
 | true =&gt; <span class="kp">solve</span> [ autoProveMain2 d | autoProveHelper2 (Int.add d <span class="mi">1</span>) max_depth ]
 | false =&gt; Message.print(Message.of_string <span class="s2">&quot;Reached max depth, possibly unprovable by these tactics.&quot;</span>)
<span class="kr">end</span>.
<span class="kn">Ltac2</span> autoProve2 () := autoProveHelper2 <span class="mi">1</span> <span class="mi">20</span>.


<span class="kn">Definition</span> <span class="nf">exampleFromJoshAuto</span> : proofTreeOfClaim healthy.
<span class="nb">eexists</span> retailer.
autoProve2 ().
<span class="kn">Show Proof</span>.
<span class="kn">Defined</span>.</span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> show exampleFromJoshAuto.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showLong exampleFromJoshAuto).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 exampleFromJoshAuto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">whiteboardExample</span> : proofTreeOfClaim (Implies C1 C2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Proof</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eexists</span> a2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (impl_intro e1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (trust a2 _ _ trustT).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume e2 a1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> leaf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> show whiteboardExample.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showLong whiteboardExample).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showLong2 whiteboardExample.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="kn">Open Scope</span> string_scope.

<span class="kn">Definition</span> <span class="nf">allProofsAsString</span> := 
    show concreteProofTreeExampleWith2Conjuncts
 ++ show concreteProofTreeExampleWith3Conjuncts
 ++ show concreteProofTreeExampleTrust
 ++ show concreteProofTreeExampleWith3ConjunctsWithTrust
 ++ show concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras
 ++ show exampleWithProofOf
 ++ show usingAll
 ++ show exampleC1
 ++ show automatedProof
 ++ show fromPaper1
 ++ show exampleFromJosh
 ++ show exampleFromJoshAuto
 ++ show whiteboardExample.

<span class="c">(* Definition allProofsAsString := </span>
<span class="c">    showLong2 concreteProofTreeExampleWith2Conjuncts</span>
<span class="c"> ++ showLong2 concreteProofTreeExampleWith3Conjuncts</span>
<span class="c"> ++ showLong2 concreteProofTreeExampleTrust</span>
<span class="c"> ++ showLong2 concreteProofTreeExampleWith3ConjunctsWithTrust</span>
<span class="c"> ++ showLong2 concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras</span>
<span class="c"> ++ showLong2 exampleWithProofOf</span>
<span class="c"> ++ showLong2 usingAll</span>
<span class="c"> ++ showLong2 exampleC1</span>
<span class="c"> ++ showLong2 automatedProof</span>
<span class="c"> ++ showLong2 fromPaper1</span>
<span class="c"> ++ showLong2 exampleFromJosh</span>
<span class="c"> ++ showLong2 exampleFromJoshAuto</span>
<span class="c"> ++ showLong2 whiteboardExample. *)</span>


<span class="c">(* Eval compute in allProofsAsString. *)</span>

<span class="kn">End</span> <span class="nf">VeracityLogic</span>.</span></pre></div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">VeracityLogicV3.v</tt>, line 1292)</p>
Coq raised an exception:
  &gt; In environment
  &gt; e4 : evid
  &gt; c4 : claim
  &gt; The term &quot;&quot;l&quot;&quot; has type &quot;string&quot; while it is expected to have type &quot;name&quot;.
The offending chunk is delimited by &gt;&gt;&gt;‚Ä¶&lt;&lt;&lt; below:
  &gt; Definition l := AtomicEvid (NamePair &gt;&gt;&gt;&quot;l&quot;&lt;&lt;&lt; &quot;example evidence l&quot;).
  &gt; Definition s := AtomicEvid (NamePair &quot;s&quot; &quot;example evidence s&quot;).
  &gt; Definition c := AtomicEvid (NamePair &quot;c&quot; &quot;example evidence c&quot;).
Results past this point may be unreliable.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">VeracityLogicV3.v</tt>, line 1558)</p>
Coq raised an exception:
  &gt; In environment
  &gt; e4 : evid
  &gt; c4 : claim
  &gt; The term &quot;&quot;l&quot;&quot; has type &quot;string&quot; while it is expected to have type &quot;name&quot;.
The offending chunk is delimited by &gt;&gt;&gt;‚Ä¶&lt;&lt;&lt; below:
  &gt; Eval compute in showLong usingAll.
  &gt; Ev&gt;&gt;&gt;al &lt;&lt;&lt;compute in showLong2 usingAll.
  &gt;
  &gt; Ltac proveClaim := 
Results past this point may be unreliable.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">VeracityLogicV3.v</tt>, line 1687)</p>
Coq raised an exception:
  &gt; In environment
  &gt; e4 : evid
  &gt; c4 : claim
  &gt; The term &quot;&quot;l&quot;&quot; has type &quot;string&quot; while it is expected to have type &quot;name&quot;.
The offending chunk is delimited by &gt;&gt;&gt;‚Ä¶&lt;&lt;&lt; below:
  &gt; Eval compute in showLong exampleC1.
  &gt; E&gt;&gt;&gt;val&lt;&lt;&lt; compute in showLong2 exampleC1.
  &gt;
  &gt; Set Default Proof Mode &quot;Ltac2&quot;.
Results past this point may be unreliable.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">VeracityLogicV3.v</tt>, line 1724)</p>
Coq raised an exception:
  &gt; Syntax error: illegal begin of vernac.
The offending chunk is delimited by &gt;&gt;&gt;‚Ä¶&lt;&lt;&lt; below:
  &gt; Eval compute in showLong automatedProof.
  &gt; Eval compute in showLong2 automatedProof.
  &gt; &gt;&gt;&gt;Ltac2&lt;&lt;&lt; rec autoProveMain1 max_depth :=
  &gt; match Int.equal 0 max_depth with
  &gt;   | true =&gt; Control.zero (VeracityProofSearchException (&quot;Ran out of depth.&quot;))
Results past this point may be unreliable.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">VeracityLogicV3.v</tt>, line 1830)</p>
Coq raised an exception:
  &gt; Syntax error: illegal begin of vernac.
The offending chunk is delimited by &gt;&gt;&gt;‚Ä¶&lt;&lt;&lt; below:
  &gt; Eval compute in showLong exampleFromJosh.
  &gt; Eval compute in showLong2 exampleFromJosh.
  &gt; &gt;&gt;&gt;Ltac2&lt;&lt;&lt; rec autoProveMain2 max_depth :=
  &gt; match Int.equal 0 max_depth with
  &gt;   | true =&gt; Control.zero (VeracityProofSearchException (&quot;Ran out of depth.&quot;))
Results past this point may be unreliable.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">VeracityLogicV3.v</tt>, line 1808)</p>
Coq raised an exception:
  &gt; In environment
  &gt; e4 : evid
  &gt; c4 : claim
  &gt; The term &quot;&quot;l&quot;&quot; has type &quot;string&quot; while it is expected to have type &quot;name&quot;.
The offending chunk is delimited by &gt;&gt;&gt;‚Ä¶&lt;&lt;&lt; below:
  &gt; Eval compute in (showLong whiteboardE&gt;&gt;&gt;xam&lt;&lt;&lt;ple).
  &gt; Eval compute in showLong2 whiteboardExample.
  &gt;
Results past this point may be unreliable.</div>
</div>
</div>
</div></body>
</html>
