<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Veracity Logic Mechanised in Coq</title>
<script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js?config=TeX-AMS_CHTML"></script>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="veracity-logic-mechanised-in-coq">
<h1 class="title">Veracity Logic Mechanised in Coq</h1>

<!-- The following is required to get MathJax to process the outputs marked with the class coq-math. -->
<link rel="stylesheet" href="overrides.css">

<script type="text/javascript">
  document.addEventListener("DOMContentLoaded", () => {
     // 1. Find all relevant Alectryon tags
     var spans = document.querySelectorAll(".coq-math > * > * > * > * > * > .s2, .custom-math");

     // 2. Wrap the contents of each in \(\) math delimiters, add mathjax class
     spans.forEach(function (e) {
         e.innerText = '\\[' + e.innerText + '\\]';
         e.classList.add("mathjax_process");
     });

     // 3. If MathJax has already loaded, force reprocessing
     window.MathJax && MathJax.typesetPromise(spans);
  });
</script>

<style type="text/css"> /* Override MathJax margins */
    .coq-math .goal-conclusion > *,
    .coq-math .hyp-body span > *,
    .coq-math .hyp-type span > * {
        margin: 0 !important;
    }
</style><div class="section" id="imports">
<h1>Imports</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> String.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Bool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Program.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">VeracityLogic</span>.</span></span></pre></div>
<div class="section" id="types-for-names">
<h1>Types for names</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">atomic_evid_name</span> :=
  | _e_
  | _e1_
  | _e2_
  | _e3_
  | _e4_
  | _eQ_
  | _l_
  | _s_
  | _c_
  | _belief_
  | _testing_
  | _audit_
  | _compile_
  | _review_
  | _assess_
  | _business_procedure_
  | _ingredients_percentage_list_
  | _breakdown_of_formulations_list_
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">atomic_evid_name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">actor_name</span> :=
  | _a1_
  | _a2_
  | _a3_
  | _a4_
  | _aQ_
  | _retailer_
  | _vineyard_
  | _winery_
  | _P_
  | _Q_
  | _applicant_
  | _certifier_
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">actor_name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">claim_name</span> :=
  | _c1_
  | _c2_
  | _c3_
  | _c4_
  | _c5_
  | _cQ_
  | _healthy_
  | _nonToxic_
  | _organic_
  | _ingredients_valid_
  | _ingredients_valid_approved_
  | _recipe_valid_
  | _percentage_ingredients_valid_
  | _breakdown_of_formulations_valid_
  | _successful_market_compliance_assessment_
.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">claim_name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">trust_relation_name</span> :=
  | _T_
  | _U_
  | _V_
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">trust_relation_name</span>.</span></span></pre></div>
<div class="section" id="types-of-aspecs-of-the-veracity-logic">
<h1>Types of aspecs of the veracity logic</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">claim</span> :=
  | AtomicClaim (n : claim_name)
  | Bottom
  | And (c1 c2 : claim)
  | Or  (c1 c2 : claim)
  | Implies  (c1 c2 : claim).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">claim</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">evid</span> :=
  | AtomicEvid (n : atomic_evid_name)
  | Pair (e1 e2: evid)
  | Left (e1 : evid)
  | Right (e1 : evid)
  | Lambda (x bx : evid).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">evid</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">actor</span> :=
  | Actor (n : actor_name).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">actor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">trustRelation</span> :=
  | Trust (n : trust_relation_name).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">trustRelation</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">judgement</span> :=
  Judgement (e : evid) (a : actor) (c: claim).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">judgement</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;E \by A \in C&quot;</span> := (Judgement E A C) (<span class="kn">at level</span> <span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;/\&#39;&quot;</span> := And (<span class="kn">at level</span> <span class="mi">81</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;\/&#39;&quot;</span> := Or (<span class="kn">at level</span> <span class="mi">86</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;-&gt;&#39;&quot;</span> := Implies (<span class="kn">at level</span> <span class="mi">99</span>, <span class="kn">right associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;_|_&quot;</span> := (Bottom) (<span class="kn">at level</span> <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{{ x , y , .. , z }}&quot;</span> := (Pair .. (Pair x y) .. z).</span></span></pre></div>
<div class="section" id="boolean-equality-typeclass">
<h1>Boolean Equality Typeclass</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Beq</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    beq : A -&gt; A -&gt; bool
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk0"><span class="kn">Infix</span> <span class="s2">&quot;=?&quot;</span> := beq : beq_scope.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Declaring a scope implicitly <span class="kr">is</span> deprecated; use <span class="kr">in</span>
advance an explicit <span class="s2">&quot;Declare Scope beq_scope.&quot;</span>.
[undeclared-scope,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq atomic_evid_name := { beq := atomic_evid_name_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq actor_name := { beq := actor_name_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq claim_name := { beq := claim_name_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq trust_relation_name := { beq := trust_relation_name_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq evid := { beq := evid_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq claim := { beq := claim_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq actor := { beq := actor_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq trustRelation := { beq := trustRelation_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq judgement := { beq := judgement_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> string.</span></span></pre></div>
<div class="section" id="the-machinery-for-applying-lambas">
<h1>The machinery for applying lambas</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">MatchingFormat</span> (<span class="nv">e1</span> <span class="nv">e2</span> : evid) :=
  <span class="kr">match</span> e1,e2 <span class="kr">with</span>
  | AtomicEvid _,AtomicEvid _ =&gt; <span class="kt">True</span>
  | Pair e1 e2,Pair e1&#39; e2&#39; =&gt; MatchingFormat e1 e1&#39; /\ MatchingFormat e2 e2&#39;
  | Left e,Left e&#39; =&gt; MatchingFormat e e&#39;
  | Right e,Right e&#39; =&gt; MatchingFormat e e&#39;
  | Lambda x bx,Lambda x&#39; bx&#39; =&gt; MatchingFormat x x&#39; /\ MatchingFormat bx bx&#39;
  | _,_ =&gt; <span class="kt">False</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">matchingFormat</span> (<span class="nv">e1</span> <span class="nv">e2</span> : evid) :=
  <span class="kr">match</span> e1,e2 <span class="kr">with</span>
  | AtomicEvid _,AtomicEvid _ =&gt; true
  | Pair e1 e2,Pair e1&#39; e2&#39; =&gt; matchingFormat e1 e1&#39; &amp;&amp; matchingFormat e2 e2&#39;
  | Left e,Left e&#39; =&gt; matchingFormat e e&#39;
  | Right e,Right e&#39; =&gt; matchingFormat e e&#39;
  | Lambda x bx, Lambda x&#39; bx&#39; =&gt; matchingFormat x x&#39; &amp;&amp; matchingFormat bx bx&#39;
  | _,_ =&gt; false
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1"><span class="kn">Lemma</span> <span class="nf">matchingFormat_bool_Prop_iff</span> : <span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span>, MatchingFormat e1 e2 &lt;-&gt; matchingFormat e1 e2 = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 &lt;-&gt; matchingFormat e1 e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 &lt;-&gt; matchingFormat e1 e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1 e2 -&gt; matchingFormat e1 e2 = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk4"><hr></label><div class="goal-conclusion">matchingFormat e1 e2 = true -&gt; MatchingFormat e1 e2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1 e2 -&gt; matchingFormat e1 e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk6"><span class="nb">revert</span> e2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt; matchingFormat e1 e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk7"><span class="nb">induction</span> e1; <span class="nb">induction</span> e2; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span>MatchingFormat {{e1_1, e1_2}} e2_1 -&gt;
matchingFormat {{e1_1, e1_2}} e2_1 = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span>MatchingFormat {{e1_1, e1_2}} e2_2 -&gt;
matchingFormat {{e1_1, e1_2}} e2_2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat {{e1_1, e1_2}} {{e2_1, e2_2}} -&gt;
matchingFormat {{e1_1, e1_2}} {{e2_1, e2_2}} = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt;
matchingFormat e1 e2 = true</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Left e1) e2 -&gt;
matchingFormat (Left e1) e2 = true</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk8"><hr></label><div class="goal-conclusion">MatchingFormat (Left e1) (Left e2) -&gt;
matchingFormat (Left e1) (Left e2) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt;
matchingFormat e1 e2 = true</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Right e1) e2 -&gt;
matchingFormat (Right e1) e2 = true</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk9"><hr></label><div class="goal-conclusion">MatchingFormat (Right e1) (Right e2) -&gt;
matchingFormat (Right e1) (Right e2) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Lambda e1_1 e1_2) e2_1 -&gt;
matchingFormat (Lambda e1_1 e1_2) e2_1 = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Lambda e1_1 e1_2) e2_2 -&gt;
matchingFormat (Lambda e1_1 e1_2) e2_2 = true</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chka"><hr></label><div class="goal-conclusion">MatchingFormat (Lambda e1_1 e1_2) (Lambda e2_1 e2_2) -&gt;
matchingFormat (Lambda e1_1 e1_2) (Lambda e2_1 e2_2) =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span>MatchingFormat {{e1_1, e1_2}} e2_1 -&gt;
matchingFormat {{e1_1, e1_2}} e2_1 = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span>MatchingFormat {{e1_1, e1_2}} e2_2 -&gt;
matchingFormat {{e1_1, e1_2}} e2_2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat {{e1_1, e1_2}} {{e2_1, e2_2}} -&gt;
matchingFormat {{e1_1, e1_2}} {{e2_1, e2_2}} = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1_1 e2_1 /\ MatchingFormat e1_2 e2_2 -&gt;
matchingFormat e1_1 e2_1 &amp;&amp; matchingFormat e1_2 e2_2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1 /\
MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 &amp;&amp; matchingFormat e1_2 e2_2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chke"><span class="nb">apply</span> andb_true_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1 /\
MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 = true /\
matchingFormat e1_2 e2_2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkf"><span class="nb">destruct</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 = true /\
matchingFormat e1_2 e2_2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk10"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk11"><hr></label><div class="goal-conclusion">matchingFormat e1_2 e2_2 = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk12">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk13"><span class="nb">apply</span> IHe1_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1_1 e2_1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk14">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_2 e2_2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk15"><span class="nb">apply</span> IHe1_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1_2 e2_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk16">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt;
matchingFormat e1 e2 = true</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Left e1) e2 -&gt;
matchingFormat (Left e1) e2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat (Left e1) (Left e2) -&gt;
matchingFormat (Left e1) (Left e2) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk17"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt;
matchingFormat e1 e2 = true</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2 <span class="kr">with</span>
| Left e&#39; =&gt; MatchingFormat e1 e&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2 <span class="kr">with</span>
| Left e&#39; =&gt; matchingFormat e1 e&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1 e2 -&gt; matchingFormat e1 e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk18"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt;
matchingFormat e1 e2 = true</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2 <span class="kr">with</span>
| Left e&#39; =&gt; MatchingFormat e1 e&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2 <span class="kr">with</span>
| Left e&#39; =&gt; matchingFormat e1 e&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1 e2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1 e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk19"><span class="nb">apply</span> IHe1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt;
matchingFormat e1 e2 = true</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2 <span class="kr">with</span>
| Left e&#39; =&gt; MatchingFormat e1 e&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2 <span class="kr">with</span>
| Left e&#39; =&gt; matchingFormat e1 e&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1 e2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1 e2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt;
matchingFormat e1 e2 = true</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Right e1) e2 -&gt;
matchingFormat (Right e1) e2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat (Right e1) (Right e2) -&gt;
matchingFormat (Right e1) (Right e2) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1b"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt;
matchingFormat e1 e2 = true</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2 <span class="kr">with</span>
| Right e&#39; =&gt; MatchingFormat e1 e&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2 <span class="kr">with</span>
| Right e&#39; =&gt; matchingFormat e1 e&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1 e2 -&gt; matchingFormat e1 e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt;
matchingFormat e1 e2 = true</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2 <span class="kr">with</span>
| Right e&#39; =&gt; MatchingFormat e1 e&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2 <span class="kr">with</span>
| Right e&#39; =&gt; matchingFormat e1 e&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1 e2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1 e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1d"><span class="nb">apply</span> IHe1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt;
matchingFormat e1 e2 = true</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2 <span class="kr">with</span>
| Right e&#39; =&gt; MatchingFormat e1 e&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2 <span class="kr">with</span>
| Right e&#39; =&gt; matchingFormat e1 e&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1 e2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1 e2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Lambda e1_1 e1_2) e2_1 -&gt;
matchingFormat (Lambda e1_1 e1_2) e2_1 = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Lambda e1_1 e1_2) e2_2 -&gt;
matchingFormat (Lambda e1_1 e1_2) e2_2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat (Lambda e1_1 e1_2) (Lambda e2_1 e2_2) -&gt;
matchingFormat (Lambda e1_1 e1_2) (Lambda e2_1 e2_2) =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1f"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1_1 e2_1 /\ MatchingFormat e1_2 e2_2 -&gt;
matchingFormat e1_1 e2_1 &amp;&amp; matchingFormat e1_2 e2_2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk20"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1 /\
MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 &amp;&amp; matchingFormat e1_2 e2_2 =
true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk21"><span class="nb">apply</span> andb_true_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1 /\
MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 = true /\
matchingFormat e1_2 e2_2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk22"><span class="nb">destruct</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 = true /\
matchingFormat e1_2 e2_2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk23"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk24"><hr></label><div class="goal-conclusion">matchingFormat e1_2 e2_2 = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk25">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk26"><span class="nb">apply</span> IHe1_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1_1 e2_1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk27">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_2 e2_2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk28"><span class="nb">apply</span> IHe1_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_1 e2 -&gt;
matchingFormat e1_1 e2 = true</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
MatchingFormat e1_2 e2 -&gt;
matchingFormat e1_2 e2 = true</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span> -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_1 e2_1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1_2 e2_2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1_2 e2_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1 e2 = true -&gt; MatchingFormat e1 e2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2a"><span class="nb">revert</span> e2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1 e2 = true -&gt; MatchingFormat e1 e2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2b"><span class="nb">induction</span> e1; <span class="nb">induction</span> e2; <span class="nb">simpl</span> <span class="kr">in</span> *; (<span class="kp">try</span> <span class="bp">discriminate</span>); <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_1 e2 = true -&gt;
MatchingFormat e1_1 e2</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_2 e2 = true -&gt;
MatchingFormat e1_2 e2</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 &amp;&amp; matchingFormat e1_2 e2_2 =
true -&gt;
MatchingFormat e1_1 e2_1 /\ MatchingFormat e1_2 e2_2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_1 e2 = true -&gt;
MatchingFormat e1_1 e2</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_2 e2 = true -&gt;
MatchingFormat e1_2 e2</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk2c"><hr></label><div class="goal-conclusion">matchingFormat e1_1 e2_1 &amp;&amp; matchingFormat e1_2 e2_2 =
true -&gt;
MatchingFormat e1_1 e2_1 /\ MatchingFormat e1_2 e2_2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_1 e2 = true -&gt;
MatchingFormat e1_1 e2</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_2 e2 = true -&gt;
MatchingFormat e1_2 e2</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 &amp;&amp; matchingFormat e1_2 e2_2 =
true -&gt;
MatchingFormat e1_1 e2_1 /\ MatchingFormat e1_2 e2_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_1 e2 = true -&gt;
MatchingFormat e1_1 e2</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_2 e2 = true -&gt;
MatchingFormat e1_2 e2</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>matchingFormat e1_1 e2_1 &amp;&amp;
matchingFormat e1_2 e2_2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1_1 e2_1 /\ MatchingFormat e1_2 e2_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2f"><span class="nb">apply</span> andb_prop <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_1 e2 = true -&gt;
MatchingFormat e1_1 e2</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_2 e2 = true -&gt;
MatchingFormat e1_2 e2</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>matchingFormat e1_1 e2_1 = true /\
matchingFormat e1_2 e2_2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1_1 e2_1 /\ MatchingFormat e1_2 e2_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk30"><span class="nb">destruct</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_1 e2 = true -&gt;
MatchingFormat e1_1 e2</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_2 e2 = true -&gt;
MatchingFormat e1_2 e2</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    matchingFormat e1_1 e1&#39; &amp;&amp;
    matchingFormat e1_2 e2&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| {{e1&#39;, e2&#39;}} =&gt;
    MatchingFormat e1_1 e1&#39; /\
    MatchingFormat e1_2 e2&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>matchingFormat e1_1 e2_1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>matchingFormat e1_2 e2_2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1_1 e2_1 /\ MatchingFormat e1_2 e2_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk31">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_1 e2 = true -&gt;
MatchingFormat e1_1 e2</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_2 e2 = true -&gt;
MatchingFormat e1_2 e2</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1_1 e2_1 &amp;&amp; matchingFormat e1_2 e2_2 =
true -&gt;
MatchingFormat e1_1 e2_1 /\ MatchingFormat e1_2 e2_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk32"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_1 e2 = true -&gt;
MatchingFormat e1_1 e2</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_2 e2 = true -&gt;
MatchingFormat e1_2 e2</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>matchingFormat e1_1 e2_1 &amp;&amp;
matchingFormat e1_2 e2_2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1_1 e2_1 /\ MatchingFormat e1_2 e2_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk33"><span class="nb">apply</span> andb_prop <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_1 e2 = true -&gt;
MatchingFormat e1_1 e2</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_2 e2 = true -&gt;
MatchingFormat e1_2 e2</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>matchingFormat e1_1 e2_1 = true /\
matchingFormat e1_2 e2_2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1_1 e2_1 /\ MatchingFormat e1_2 e2_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk34"><span class="nb">destruct</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1_1, e1_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe1_1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_1 e2 = true -&gt;
MatchingFormat e1_1 e2</span></span></span><br><span><var>IHe1_2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e2</span> : evid,
matchingFormat e1_2 e2 = true -&gt;
MatchingFormat e1_2 e2</span></span></span><br><span><var>e2_1, e2_2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>IHe2_1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_1 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>IHe2_2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    matchingFormat e1_1 x&#39; &amp;&amp;
    matchingFormat e1_2 bx&#39;
| _ =&gt; false
<span class="kr">end</span> = true -&gt;
<span class="kr">match</span> e2_2 <span class="kr">with</span>
| Lambda x&#39; bx&#39; =&gt;
    MatchingFormat e1_1 x&#39; /\
    MatchingFormat e1_2 bx&#39;
| _ =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>matchingFormat e1_1 e2_1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>matchingFormat e1_2 e2_2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1_1 e2_1 /\ MatchingFormat e1_2 e2_2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk35"><span class="kn">Lemma</span> <span class="nf">matchingFormat_bool_to_Prop</span> : <span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span>, matchingFormat e1 e2 = true -&gt; MatchingFormat e1 e2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> : evid,
matchingFormat e1 e2 = true -&gt; MatchingFormat e1 e2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> : evid,
matchingFormat e1 e2 = true -&gt; MatchingFormat e1 e2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> matchingFormat_bool_Prop_iff.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk37"><span class="kn">Lemma</span> <span class="nf">matchingFormat_Prop_to_bool</span> : <span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span>, MatchingFormat e1 e2 -&gt; matchingFormat e1 e2 = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt; matchingFormat e1 e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> : evid,
MatchingFormat e1 e2 -&gt; matchingFormat e1 e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> matchingFormat_bool_Prop_iff.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">substitutions</span> (<span class="nv">x</span> <span class="nv">a</span> : evid) (<span class="nv">HMatching</span> : MatchingFormat x a) (<span class="nv">n</span> : atomic_evid_name) : option atomic_evid_name :=
  <span class="kr">match</span> x,a <span class="kr">with</span>
  | AtomicEvid name,AtomicEvid name&#39; =&gt; <span class="kr">if</span> n =? name <span class="kr">then</span> Some name&#39; <span class="kr">else</span> None
  | Pair e1 e2,Pair e1&#39; e2&#39; =&gt; <span class="kr">match</span> substitutions e1 e1&#39; _ n <span class="kr">with</span>
                               | Some name&#39; =&gt; Some name&#39;
                               | None =&gt; substitutions e2 e2&#39; _ n
                               <span class="kr">end</span>
  | Left e,Left e&#39; =&gt; substitutions e e&#39; _ n
  | Right e,Right e&#39; =&gt; substitutions e e&#39; _ n
  | Lambda x bx,Lambda x&#39; bx&#39; =&gt; substitutions bx bx&#39; _ n
  | _,_ =&gt; _
  <span class="kr">end</span>
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk39"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1', e2', e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat {{e1, e2}} {{e1&#39;, e2&#39;}}</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1 e1&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3a"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1', e2', e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1 e1&#39; /\
MatchingFormat e2 e2&#39;</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1 e1&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3b"><span class="nb">destruct</span> HMatching.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1', e2', e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1 e1&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e2 e2&#39;</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e1 e1&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3c"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1', e2', e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat {{e1, e2}} {{e1&#39;, e2&#39;}}</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e2 e2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3d"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1', e2', e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1 e1&#39; /\
MatchingFormat e2 e2&#39;</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e2 e2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3e"><span class="nb">destruct</span> HMatching.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e1', e2', e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat e1 e1&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat e2 e2&#39;</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat e2 e2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3f"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x', bx', x, bx</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Lambda x bx)
  (Lambda x&#39; bx&#39;)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat bx bx&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk40"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x', bx', x, bx</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x x&#39; /\
MatchingFormat bx bx&#39;</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat bx bx&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk41"><span class="nb">destruct</span> HMatching.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x', bx', x, bx</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MatchingFormat x x&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MatchingFormat bx bx&#39;</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MatchingFormat bx bx&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk42"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = x /\ {{e1&#39;, e2&#39;}} = a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid, ~ (Left e = x /\ Left e&#39; = a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = x /\ Right e&#39; = a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~ (Lambda x0 bx = x /\ Lambda x&#39; bx&#39; = a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~ (AtomicEvid name = x /\ AtomicEvid name&#39; = a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option atomic_evid_name</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk43"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = x /\ {{e1&#39;, e2&#39;}} = a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid, ~ (Left e = x /\ Left e&#39; = a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = x /\ Right e&#39; = a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~ (Lambda x0 bx = x /\ Lambda x&#39; bx&#39; = a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~ (AtomicEvid name = x /\ AtomicEvid name&#39; = a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk44"><span class="nb">destruct</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n0</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (AtomicEvid n0) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = AtomicEvid n0 /\ {{e1&#39;, e2&#39;}} = a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = AtomicEvid n0 /\ Left e&#39; = a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = AtomicEvid n0 /\ Right e&#39; = a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = AtomicEvid n0 /\ Lambda x&#39; bx&#39; = a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = AtomicEvid n0 /\
 AtomicEvid name&#39; = a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x1, x2, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat {{x1, x2}} a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = {{x1, x2}} /\ {{e1&#39;, e2&#39;}} = a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = {{x1, x2}} /\ Left e&#39; = a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = {{x1, x2}} /\ Right e&#39; = a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~ (Lambda x bx = {{x1, x2}} /\ Lambda x&#39; bx&#39; = a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = {{x1, x2}} /\
 AtomicEvid name&#39; = a)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk45"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Left x) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = Left x /\ {{e1&#39;, e2&#39;}} = a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = Left x /\ Left e&#39; = a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = Left x /\ Right e&#39; = a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~ (Lambda x0 bx = Left x /\ Lambda x&#39; bx&#39; = a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Left x /\ AtomicEvid name&#39; = a)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk46"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk47" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Right x) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = Right x /\ {{e1&#39;, e2&#39;}} = a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = Right x /\ Left e&#39; = a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = Right x /\ Right e&#39; = a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~ (Lambda x0 bx = Right x /\ Lambda x&#39; bx&#39; = a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Right x /\
 AtomicEvid name&#39; = a)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk47"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x1, x2, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Lambda x1 x2) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = Lambda x1 x2 /\ {{e1&#39;, e2&#39;}} = a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = Lambda x1 x2 /\ Left e&#39; = a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = Lambda x1 x2 /\ Right e&#39; = a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = Lambda x1 x2 /\ Lambda x&#39; bx&#39; = a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Lambda x1 x2 /\
 AtomicEvid name&#39; = a)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk48"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk49">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n0</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (AtomicEvid n0) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = AtomicEvid n0 /\ {{e1&#39;, e2&#39;}} = a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = AtomicEvid n0 /\ Left e&#39; = a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = AtomicEvid n0 /\ Right e&#39; = a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = AtomicEvid n0 /\ Lambda x&#39; bx&#39; = a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = AtomicEvid n0 /\
 AtomicEvid name&#39; = a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk4a"><span class="nb">destruct</span> a; <span class="kp">try</span> (<span class="nb">simpl</span> <span class="kr">in</span> *; <span class="bp">contradiction</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n0, n1</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (AtomicEvid n0)
  (AtomicEvid n1)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~
({{e1, e2}} = AtomicEvid n0 /\
 {{e1&#39;, e2&#39;}} = AtomicEvid n1)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~
(Left e = AtomicEvid n0 /\
 Left e&#39; = AtomicEvid n1)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~
(Right e = AtomicEvid n0 /\
 Right e&#39; = AtomicEvid n1)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = AtomicEvid n0 /\
 Lambda x&#39; bx&#39; = AtomicEvid n1)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = AtomicEvid n0 /\
 AtomicEvid name&#39; = AtomicEvid n1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk4b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n0, n1</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (AtomicEvid n0)
  (AtomicEvid n1)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~
({{e1, e2}} = AtomicEvid n0 /\
 {{e1&#39;, e2&#39;}} = AtomicEvid n1)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~
(Left e = AtomicEvid n0 /\
 Left e&#39; = AtomicEvid n1)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~
(Right e = AtomicEvid n0 /\
 Right e&#39; = AtomicEvid n1)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = AtomicEvid n0 /\
 Lambda x&#39; bx&#39; = AtomicEvid n1)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = AtomicEvid n0 /\
 AtomicEvid name&#39; = AtomicEvid n1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk4c"><span class="nb">eapply</span> H3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n0, n1</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (AtomicEvid n0)
  (AtomicEvid n1)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~
({{e1, e2}} = AtomicEvid n0 /\
 {{e1&#39;, e2&#39;}} = AtomicEvid n1)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~
(Left e = AtomicEvid n0 /\
 Left e&#39; = AtomicEvid n1)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~
(Right e = AtomicEvid n0 /\
 Right e&#39; = AtomicEvid n1)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = AtomicEvid n0 /\
 Lambda x&#39; bx&#39; = AtomicEvid n1)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = AtomicEvid n0 /\
 AtomicEvid name&#39; = AtomicEvid n1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AtomicEvid <span class="nl">?name</span> = AtomicEvid n0 /\
AtomicEvid <span class="nl">?name&#39;</span> = AtomicEvid n1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk4d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x1, x2, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat {{x1, x2}} a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = {{x1, x2}} /\ {{e1&#39;, e2&#39;}} = a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = {{x1, x2}} /\ Left e&#39; = a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = {{x1, x2}} /\ Right e&#39; = a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~ (Lambda x bx = {{x1, x2}} /\ Lambda x&#39; bx&#39; = a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = {{x1, x2}} /\
 AtomicEvid name&#39; = a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk4e"><span class="nb">destruct</span> a; <span class="kp">try</span> (<span class="nb">simpl</span> <span class="kr">in</span> *; <span class="bp">contradiction</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x1, x2, a1, a2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat {{x1, x2}} {{a1, a2}}</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~
({{e1, e2}} = {{x1, x2}} /\
 {{e1&#39;, e2&#39;}} = {{a1, a2}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = {{x1, x2}} /\ Left e&#39; = {{a1, a2}})</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = {{x1, x2}} /\ Right e&#39; = {{a1, a2}})</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = {{x1, x2}} /\
 Lambda x&#39; bx&#39; = {{a1, a2}})</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = {{x1, x2}} /\
 AtomicEvid name&#39; = {{a1, a2}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk4f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x1, x2, a1, a2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat {{x1, x2}} {{a1, a2}}</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~
({{e1, e2}} = {{x1, x2}} /\
 {{e1&#39;, e2&#39;}} = {{a1, a2}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = {{x1, x2}} /\ Left e&#39; = {{a1, a2}})</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = {{x1, x2}} /\ Right e&#39; = {{a1, a2}})</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = {{x1, x2}} /\
 Lambda x&#39; bx&#39; = {{a1, a2}})</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = {{x1, x2}} /\
 AtomicEvid name&#39; = {{a1, a2}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk50"><span class="nb">eapply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x1, x2, a1, a2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat {{x1, x2}} {{a1, a2}}</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~
({{e1, e2}} = {{x1, x2}} /\
 {{e1&#39;, e2&#39;}} = {{a1, a2}})</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = {{x1, x2}} /\ Left e&#39; = {{a1, a2}})</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = {{x1, x2}} /\ Right e&#39; = {{a1, a2}})</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = {{x1, x2}} /\
 Lambda x&#39; bx&#39; = {{a1, a2}})</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = {{x1, x2}} /\
 AtomicEvid name&#39; = {{a1, a2}})</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{{<span class="nl">?e1</span>, <span class="nl">?e2</span>}} = {{x1, x2}} /\
{{<span class="nl">?e1&#39;</span>, <span class="nl">?e2&#39;</span>}} = {{a1, a2}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk51">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Left x) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = Left x /\ {{e1&#39;, e2&#39;}} = a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = Left x /\ Left e&#39; = a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = Left x /\ Right e&#39; = a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~ (Lambda x0 bx = Left x /\ Lambda x&#39; bx&#39; = a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Left x /\ AtomicEvid name&#39; = a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk52"><span class="nb">destruct</span> a; <span class="kp">try</span> (<span class="nb">simpl</span> <span class="kr">in</span> *; <span class="bp">contradiction</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Left x) (Left a)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = Left x /\ {{e1&#39;, e2&#39;}} = Left a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = Left x /\ Left e&#39; = Left a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = Left x /\ Right e&#39; = Left a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x0 bx = Left x /\ Lambda x&#39; bx&#39; = Left a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Left x /\
 AtomicEvid name&#39; = Left a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk53">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Left x) (Left a)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = Left x /\ {{e1&#39;, e2&#39;}} = Left a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = Left x /\ Left e&#39; = Left a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = Left x /\ Right e&#39; = Left a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x0 bx = Left x /\ Lambda x&#39; bx&#39; = Left a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Left x /\
 AtomicEvid name&#39; = Left a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk54"><span class="nb">eapply</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Left x) (Left a)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = Left x /\ {{e1&#39;, e2&#39;}} = Left a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = Left x /\ Left e&#39; = Left a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = Left x /\ Right e&#39; = Left a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x0 bx = Left x /\ Lambda x&#39; bx&#39; = Left a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Left x /\
 AtomicEvid name&#39; = Left a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Left <span class="nl">?e</span> = Left x /\ Left <span class="nl">?e&#39;</span> = Left a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk55">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Right x) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = Right x /\ {{e1&#39;, e2&#39;}} = a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = Right x /\ Left e&#39; = a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = Right x /\ Right e&#39; = a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~ (Lambda x0 bx = Right x /\ Lambda x&#39; bx&#39; = a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Right x /\
 AtomicEvid name&#39; = a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk56"><span class="nb">destruct</span> a; <span class="kp">try</span> (<span class="nb">simpl</span> <span class="kr">in</span> *; <span class="bp">contradiction</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Right x) (Right a)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = Right x /\ {{e1&#39;, e2&#39;}} = Right a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = Right x /\ Left e&#39; = Right a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = Right x /\ Right e&#39; = Right a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x0 bx = Right x /\
 Lambda x&#39; bx&#39; = Right a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Right x /\
 AtomicEvid name&#39; = Right a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk57">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Right x) (Right a)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = Right x /\ {{e1&#39;, e2&#39;}} = Right a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = Right x /\ Left e&#39; = Right a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = Right x /\ Right e&#39; = Right a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x0 bx = Right x /\
 Lambda x&#39; bx&#39; = Right a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Right x /\
 AtomicEvid name&#39; = Right a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk58"><span class="nb">eapply</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Right x) (Right a)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = Right x /\ {{e1&#39;, e2&#39;}} = Right a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = Right x /\ Left e&#39; = Right a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = Right x /\ Right e&#39; = Right a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x0 bx = Right x /\
 Lambda x&#39; bx&#39; = Right a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Right x /\
 AtomicEvid name&#39; = Right a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Right <span class="nl">?e</span> = Right x /\ Right <span class="nl">?e&#39;</span> = Right a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk59">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x1, x2, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Lambda x1 x2) a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~ ({{e1, e2}} = Lambda x1 x2 /\ {{e1&#39;, e2&#39;}} = a)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Left e = Lambda x1 x2 /\ Left e&#39; = a)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~ (Right e = Lambda x1 x2 /\ Right e&#39; = a)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = Lambda x1 x2 /\ Lambda x&#39; bx&#39; = a)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Lambda x1 x2 /\
 AtomicEvid name&#39; = a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk5a"><span class="nb">destruct</span> a; <span class="kp">try</span> (<span class="nb">simpl</span> <span class="kr">in</span> *; <span class="bp">contradiction</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x1, x2, a1, a2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Lambda x1 x2)
  (Lambda a1 a2)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~
({{e1, e2}} = Lambda x1 x2 /\
 {{e1&#39;, e2&#39;}} = Lambda a1 a2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~
(Left e = Lambda x1 x2 /\ Left e&#39; = Lambda a1 a2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~
(Right e = Lambda x1 x2 /\
 Right e&#39; = Lambda a1 a2)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = Lambda x1 x2 /\
 Lambda x&#39; bx&#39; = Lambda a1 a2)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Lambda x1 x2 /\
 AtomicEvid name&#39; = Lambda a1 a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk5b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x1, x2, a1, a2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Lambda x1 x2)
  (Lambda a1 a2)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~
({{e1, e2}} = Lambda x1 x2 /\
 {{e1&#39;, e2&#39;}} = Lambda a1 a2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~
(Left e = Lambda x1 x2 /\ Left e&#39; = Lambda a1 a2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~
(Right e = Lambda x1 x2 /\
 Right e&#39; = Lambda a1 a2)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = Lambda x1 x2 /\
 Lambda x&#39; bx&#39; = Lambda a1 a2)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Lambda x1 x2 /\
 AtomicEvid name&#39; = Lambda a1 a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk5c"><span class="nb">eapply</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x1, x2, a1, a2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat (Lambda x1 x2)
  (Lambda a1 a2)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
~
({{e1, e2}} = Lambda x1 x2 /\
 {{e1&#39;, e2&#39;}} = Lambda a1 a2)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~
(Left e = Lambda x1 x2 /\ Left e&#39; = Lambda a1 a2)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">e</span> <span class="nv">e&#39;</span> : evid,
~
(Right e = Lambda x1 x2 /\
 Right e&#39; = Lambda a1 a2)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
~
(Lambda x bx = Lambda x1 x2 /\
 Lambda x&#39; bx&#39; = Lambda a1 a2)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
~
(AtomicEvid name = Lambda x1 x2 /\
 AtomicEvid name&#39; = Lambda a1 a2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Lambda <span class="nl">?x</span> <span class="nl">?bx</span> = Lambda x1 x2 /\
Lambda <span class="nl">?x&#39;</span> <span class="nl">?bx&#39;</span> = Lambda a1 a2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk5d"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n, a0</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e1, e2}} = AtomicEvid a0 /\
  {{e1&#39;, e2&#39;}} = {{e, e0}})) /\
(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e1 = AtomicEvid a0 /\ Left e&#39; = {{e, e0}})) /\
(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e1 = AtomicEvid a0 /\ Right e&#39; = {{e, e0}})) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = AtomicEvid a0 /\
  Lambda x&#39; bx&#39; = {{e, e0}})) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = AtomicEvid a0 /\
  AtomicEvid name&#39; = {{e, e0}}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk5e"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n, a0</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e1, e2}} = AtomicEvid a0 /\ {{e1&#39;, e2&#39;}} = Left e)) /\
(<span class="kr">forall</span> <span class="nv">e0</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e0 = AtomicEvid a0 /\ Left e&#39; = Left e)) /\
(<span class="kr">forall</span> <span class="nv">e0</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e0 = AtomicEvid a0 /\ Right e&#39; = Left e)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = AtomicEvid a0 /\
  Lambda x&#39; bx&#39; = Left e)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = AtomicEvid a0 /\
  AtomicEvid name&#39; = Left e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk5f"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n, a0</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e1, e2}} = AtomicEvid a0 /\ {{e1&#39;, e2&#39;}} = Right e)) /\
(<span class="kr">forall</span> <span class="nv">e0</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e0 = AtomicEvid a0 /\ Left e&#39; = Right e)) /\
(<span class="kr">forall</span> <span class="nv">e0</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e0 = AtomicEvid a0 /\ Right e&#39; = Right e)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = AtomicEvid a0 /\
  Lambda x&#39; bx&#39; = Right e)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = AtomicEvid a0 /\
  AtomicEvid name&#39; = Right e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk60"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n, a0</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e1, e2}} = AtomicEvid a0 /\
  {{e1&#39;, e2&#39;}} = Lambda e e0)) /\
(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e1 = AtomicEvid a0 /\ Left e&#39; = Lambda e e0)) /\
(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e&#39;</span> : evid,
 ~
 (Right e1 = AtomicEvid a0 /\ Right e&#39; = Lambda e e0)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = AtomicEvid a0 /\
  Lambda x&#39; bx&#39; = Lambda e e0)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = AtomicEvid a0 /\
  AtomicEvid name&#39; = Lambda e e0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk61"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e1, e2}} = {{e, e0}} /\
  {{e1&#39;, e2&#39;}} = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e1 = {{e, e0}} /\ Left e&#39; = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e1 = {{e, e0}} /\ Right e&#39; = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = {{e, e0}} /\
  Lambda x&#39; bx&#39; = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = {{e, e0}} /\
  AtomicEvid name&#39; = AtomicEvid a0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk62"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0, e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e3</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~ ({{e2, e3}} = {{e, e0}} /\ {{e1&#39;, e2&#39;}} = Left e1)) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e2 = {{e, e0}} /\ Left e&#39; = Left e1)) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e2 = {{e, e0}} /\ Right e&#39; = Left e1)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = {{e, e0}} /\ Lambda x&#39; bx&#39; = Left e1)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = {{e, e0}} /\
  AtomicEvid name&#39; = Left e1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk63"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0, e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e3</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~ ({{e2, e3}} = {{e, e0}} /\ {{e1&#39;, e2&#39;}} = Right e1)) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e2 = {{e, e0}} /\ Left e&#39; = Right e1)) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e2 = {{e, e0}} /\ Right e&#39; = Right e1)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = {{e, e0}} /\ Lambda x&#39; bx&#39; = Right e1)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = {{e, e0}} /\
  AtomicEvid name&#39; = Right e1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk64"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0, e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e3</span> <span class="nv">e4</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e3, e4}} = {{e, e0}} /\
  {{e1&#39;, e2&#39;}} = Lambda e1 e2)) /\
(<span class="kr">forall</span> <span class="nv">e3</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e3 = {{e, e0}} /\ Left e&#39; = Lambda e1 e2)) /\
(<span class="kr">forall</span> <span class="nv">e3</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e3 = {{e, e0}} /\ Right e&#39; = Lambda e1 e2)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = {{e, e0}} /\
  Lambda x&#39; bx&#39; = Lambda e1 e2)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = {{e, e0}} /\
  AtomicEvid name&#39; = Lambda e1 e2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk65"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e1, e2}} = Left e /\ {{e1&#39;, e2&#39;}} = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">e0</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e0 = Left e /\ Left e&#39; = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">e0</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e0 = Left e /\ Right e&#39; = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = Left e /\
  Lambda x&#39; bx&#39; = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = Left e /\
  AtomicEvid name&#39; = AtomicEvid a0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk66"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0, e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e3</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~ ({{e2, e3}} = Left e /\ {{e1&#39;, e2&#39;}} = {{e0, e1}})) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e2 = Left e /\ Left e&#39; = {{e0, e1}})) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e2 = Left e /\ Right e&#39; = {{e0, e1}})) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = Left e /\ Lambda x&#39; bx&#39; = {{e0, e1}})) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = Left e /\
  AtomicEvid name&#39; = {{e0, e1}}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk67"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~ ({{e1, e2}} = Left e /\ {{e1&#39;, e2&#39;}} = Right e0)) /\
(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e1 = Left e /\ Left e&#39; = Right e0)) /\
(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e1 = Left e /\ Right e&#39; = Right e0)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~ (Lambda x bx = Left e /\ Lambda x&#39; bx&#39; = Right e0)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = Left e /\
  AtomicEvid name&#39; = Right e0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk68"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0, e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e3</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e2, e3}} = Left e /\ {{e1&#39;, e2&#39;}} = Lambda e0 e1)) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e2 = Left e /\ Left e&#39; = Lambda e0 e1)) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e2 = Left e /\ Right e&#39; = Lambda e0 e1)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = Left e /\ Lambda x&#39; bx&#39; = Lambda e0 e1)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = Left e /\
  AtomicEvid name&#39; = Lambda e0 e1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk69"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e1, e2}} = Right e /\ {{e1&#39;, e2&#39;}} = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">e0</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e0 = Right e /\ Left e&#39; = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">e0</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e0 = Right e /\ Right e&#39; = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = Right e /\
  Lambda x&#39; bx&#39; = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = Right e /\
  AtomicEvid name&#39; = AtomicEvid a0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk6a"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0, e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e3</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~ ({{e2, e3}} = Right e /\ {{e1&#39;, e2&#39;}} = {{e0, e1}})) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e2 = Right e /\ Left e&#39; = {{e0, e1}})) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e2 = Right e /\ Right e&#39; = {{e0, e1}})) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = Right e /\ Lambda x&#39; bx&#39; = {{e0, e1}})) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = Right e /\
  AtomicEvid name&#39; = {{e0, e1}}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk6b"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~ ({{e1, e2}} = Right e /\ {{e1&#39;, e2&#39;}} = Left e0)) /\
(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e1 = Right e /\ Left e&#39; = Left e0)) /\
(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e1 = Right e /\ Right e&#39; = Left e0)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~ (Lambda x bx = Right e /\ Lambda x&#39; bx&#39; = Left e0)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = Right e /\
  AtomicEvid name&#39; = Left e0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk6c"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0, e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e3</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e2, e3}} = Right e /\ {{e1&#39;, e2&#39;}} = Lambda e0 e1)) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e2 = Right e /\ Left e&#39; = Lambda e0 e1)) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e2 = Right e /\ Right e&#39; = Lambda e0 e1)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = Right e /\
  Lambda x&#39; bx&#39; = Lambda e0 e1)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = Right e /\
  AtomicEvid name&#39; = Lambda e0 e1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk6d"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e1, e2}} = Lambda e e0 /\
  {{e1&#39;, e2&#39;}} = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e1 = Lambda e e0 /\ Left e&#39; = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">e1</span> <span class="nv">e&#39;</span> : evid,
 ~
 (Right e1 = Lambda e e0 /\ Right e&#39; = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = Lambda e e0 /\
  Lambda x&#39; bx&#39; = AtomicEvid a0)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = Lambda e e0 /\
  AtomicEvid name&#39; = AtomicEvid a0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk6e"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0, e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e3</span> <span class="nv">e4</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e3, e4}} = Lambda e e0 /\
  {{e1&#39;, e2&#39;}} = {{e1, e2}})) /\
(<span class="kr">forall</span> <span class="nv">e3</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e3 = Lambda e e0 /\ Left e&#39; = {{e1, e2}})) /\
(<span class="kr">forall</span> <span class="nv">e3</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e3 = Lambda e e0 /\ Right e&#39; = {{e1, e2}})) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = Lambda e e0 /\
  Lambda x&#39; bx&#39; = {{e1, e2}})) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = Lambda e e0 /\
  AtomicEvid name&#39; = {{e1, e2}}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk6f"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0, e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e3</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e2, e3}} = Lambda e e0 /\ {{e1&#39;, e2&#39;}} = Left e1)) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e2 = Lambda e e0 /\ Left e&#39; = Left e1)) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e2 = Lambda e e0 /\ Right e&#39; = Left e1)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = Lambda e e0 /\ Lambda x&#39; bx&#39; = Left e1)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = Lambda e e0 /\
  AtomicEvid name&#39; = Left e1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk70"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>HMatching</var><span class="hyp-type"><b>: </b><span>MatchingFormat x a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>atomic_evid_name</span></span></span><br><span><var>e, e0, e1</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e3</span> <span class="nv">e1&#39;</span> <span class="nv">e2&#39;</span> : evid,
 ~
 ({{e2, e3}} = Lambda e e0 /\ {{e1&#39;, e2&#39;}} = Right e1)) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Left e2 = Lambda e e0 /\ Left e&#39; = Right e1)) /\
(<span class="kr">forall</span> <span class="nv">e2</span> <span class="nv">e&#39;</span> : evid,
 ~ (Right e2 = Lambda e e0 /\ Right e&#39; = Right e1)) /\
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">bx</span> <span class="nv">x&#39;</span> <span class="nv">bx&#39;</span> : evid,
 ~
 (Lambda x bx = Lambda e e0 /\
  Lambda x&#39; bx&#39; = Right e1)) /\
(<span class="kr">forall</span> <span class="nv">name</span> <span class="nv">name&#39;</span> : atomic_evid_name,
 ~
 (AtomicEvid name = Lambda e e0 /\
  AtomicEvid name&#39; = Right e1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> ((<span class="kp">try</span> <span class="nb">split</span>); (<span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">unfold</span> not; <span class="nb">intros</span>; <span class="nb">destruct</span> H; (<span class="kp">try</span> <span class="nb">inversion</span> H; <span class="kp">try</span> <span class="nb">inversion</span> H0)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">notUsedInInnerLambda</span> (<span class="nv">x</span> <span class="nv">bx</span> : evid) : bool :=
<span class="kr">match</span> bx <span class="kr">with</span>
  | AtomicEvid _ =&gt; true
  | Pair e1 e2 =&gt; notUsedInInnerLambda x e1 &amp;&amp; notUsedInInnerLambda x e2
  | Left e =&gt; notUsedInInnerLambda x e
  | Right e =&gt; notUsedInInnerLambda x e
  | Lambda x&#39; bx&#39; =&gt; negb (x =? x&#39;) &amp;&amp; notUsedInInnerLambda x bx&#39;
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">apply_lambda</span> (<span class="nv">x</span> <span class="nv">bx</span> <span class="nv">a</span> : evid) (<span class="nv">H1</span> : matchingFormat x a = true) (<span class="nv">H2</span> : notUsedInInnerLambda x bx = true) : evid := 
  <span class="kr">let</span> <span class="nv">H1&#39;</span> := (matchingFormat_bool_to_Prop x a H1) <span class="kr">in</span>
  <span class="kr">match</span> bx <span class="kr">with</span>
  | AtomicEvid name =&gt; <span class="kr">match</span> substitutions x a H1&#39; name <span class="kr">with</span>
                       | Some name&#39; =&gt; AtomicEvid name&#39;
                       | None =&gt; AtomicEvid name
                       <span class="kr">end</span>
  | Pair e1 e2 =&gt; Pair (apply_lambda x e1 a H1 _) (apply_lambda x e2 a H1 _)
  | Left e =&gt; (apply_lambda x e a H1 _)
  | Right e =&gt; (apply_lambda x e a H1 _)
  | Lambda x&#39; bx&#39; =&gt; Lambda x&#39; (apply_lambda x bx&#39; a H1 _)
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk71"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>matchingFormat x a = true</span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>notUsedInInnerLambda x {{e1, e2}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda x e1 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk72"><span class="nb">simpl</span> <span class="kr">in</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>matchingFormat x a = true</span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>notUsedInInnerLambda x e1 &amp;&amp;
notUsedInInnerLambda x e2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda x e1 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk73"><span class="nb">apply</span> andb_prop <span class="kr">in</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>matchingFormat x a = true</span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>notUsedInInnerLambda x e1 = true /\
notUsedInInnerLambda x e2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda x e1 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk74"><span class="nb">destruct</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>matchingFormat x a = true</span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>notUsedInInnerLambda x e1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>notUsedInInnerLambda x e2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda x e1 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk75"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>matchingFormat x a = true</span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>notUsedInInnerLambda x {{e1, e2}} = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda x e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk76"><span class="nb">simpl</span> <span class="kr">in</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>matchingFormat x a = true</span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>notUsedInInnerLambda x e1 &amp;&amp;
notUsedInInnerLambda x e2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda x e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk77"><span class="nb">apply</span> andb_prop <span class="kr">in</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>matchingFormat x a = true</span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>notUsedInInnerLambda x e1 = true /\
notUsedInInnerLambda x e2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda x e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk78"><span class="nb">destruct</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>matchingFormat x a = true</span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>notUsedInInnerLambda x e1 = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>notUsedInInnerLambda x e2 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda x e2 = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk79"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>matchingFormat x a = true</span></span></span><br><span><var>x', bx'</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>notUsedInInnerLambda x (Lambda x&#39; bx&#39;) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda x bx&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk7a"><span class="nb">simpl</span> <span class="kr">in</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>matchingFormat x a = true</span></span></span><br><span><var>x', bx'</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>negb (evid_beq x x&#39;) &amp;&amp;
notUsedInInnerLambda x bx&#39; = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda x bx&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk7b"><span class="nb">apply</span> andb_prop <span class="kr">in</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>matchingFormat x a = true</span></span></span><br><span><var>x', bx'</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>negb (evid_beq x x&#39;) = true /\
notUsedInInnerLambda x bx&#39; = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda x bx&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk7c"><span class="nb">destruct</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, a</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>matchingFormat x a = true</span></span></span><br><span><var>x', bx'</var><span class="hyp-type"><b>: </b><span>evid</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>negb (evid_beq x x&#39;) = true</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>notUsedInInnerLambda x bx&#39; = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda x bx&#39; = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre></div>
<div class="section" id="the-central-inductive-definition-of-valid-proof-trees">
<h1>The central inductive definition of valid proof trees</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">proofTreeOf</span> : judgement -&gt; <span class="kt">Type</span> :=
| assume e a c : proofTreeOf ((AtomicEvid e) \<span class="bp">by</span> a \<span class="kr">in</span> c)
| and_intro e1 e2 a C1 C2

(L: proofTreeOf (e1 \<span class="bp">by</span> a \<span class="kr">in</span> C1))
                           (R: proofTreeOf (e2 \<span class="bp">by</span> a \<span class="kr">in</span> C2))
                        :
    proofTreeOf ({{e1, e2}} \<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2))

| and_elim1 e1 e2 a C1 C2

    (M : proofTreeOf ({{e1, e2}} \<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2)))
                           :
             proofTreeOf (e1 \<span class="bp">by</span> a \<span class="kr">in</span> C1)

| and_elim2 e1 e2 a C1 C2

    (M : proofTreeOf ({{e1, e2}} \<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2)))
                          :
        proofTreeOf (e2 \<span class="bp">by</span> a \<span class="kr">in</span> C2)

| or_intro1 e1 a C1 C2

           (M: proofTreeOf (e1 \<span class="bp">by</span> a \<span class="kr">in</span> C1))
                          :
    proofTreeOf ((Left e1) \<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2))

| or_intro2 e2 a C1 C2

           (M: proofTreeOf (e2 \<span class="bp">by</span> a \<span class="kr">in</span> C2))
                          :
    proofTreeOf ((Right e2) \<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2))

    | or_elim1 e1 a C1 C2

    (M: proofTreeOf ((Left e1) \<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2)))
                        :
      proofTreeOf (e1 \<span class="bp">by</span> a \<span class="kr">in</span> C1)

| or_elim2 e2 a C1 C2

    (M : proofTreeOf ((Right e2) \<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2)))
                          :
        proofTreeOf (e2 \<span class="bp">by</span> a \<span class="kr">in</span> C2)

| trust e a1 a2 C (name : trustRelation)

(L: proofTreeOf (e \<span class="bp">by</span> a2 \<span class="kr">in</span> C))
                          :
            proofTreeOf (e \<span class="bp">by</span> a1 \<span class="kr">in</span> C)

| impl_intro (x : evid) (bx : evid) a (C1 : claim) C2
                    (H : notUsedInInnerLambda x bx = true)

              (M: proofTreeOf (bx \<span class="bp">by</span> a \<span class="kr">in</span> C2))
                              :
   proofTreeOf ((Lambda x bx) \<span class="bp">by</span> a \<span class="kr">in</span> (Implies C1 C2))
| impl_elim x bx y a C1 C2
               (H1 : notUsedInInnerLambda x bx = true)                
                  (H2 : matchingFormat x y = true)

(L: proofTreeOf ((Lambda x bx) \<span class="bp">by</span> a \<span class="kr">in</span> (Implies C1 C2)))
                           (R: proofTreeOf (y \<span class="bp">by</span> a \<span class="kr">in</span> C1))
                        :
    proofTreeOf ((apply_lambda x bx y H2 H1) \<span class="bp">by</span> a \<span class="kr">in</span> C2)
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">proofTreeOf_wrapped</span> (<span class="nv">a</span> : actor) (<span class="nv">c</span> : claim) := {
  _e : evid;
  _p : proofTreeOf (_e \<span class="bp">by</span> a \<span class="kr">in</span> c)
}.</span></span></pre></div>
<div class="section" id="string-representations">
<h1>String representations</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ShowForProofTree</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    showForProofTree : A -&gt; string
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ShowForNaturalLanguage</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    showForNaturalLanguage : A -&gt; string
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ShowForLogSeq</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    showForLogSeq : A -&gt; string
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree atomic_evid_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _e_ =&gt; <span class="s2">&quot;e&quot;</span>
      | _e1_ =&gt; <span class="s2">&quot;e_{1}&quot;</span>
      | _e2_ =&gt; <span class="s2">&quot;e_{2}&quot;</span>
      | _e3_ =&gt; <span class="s2">&quot;e_{3}&quot;</span>
      | _e4_ =&gt; <span class="s2">&quot;e_{4}&quot;</span>
      | _eQ_ =&gt; <span class="s2">&quot;e_{?}&quot;</span>
      | _l_ =&gt; <span class="s2">&quot;l&quot;</span>
      | _s_ =&gt; <span class="s2">&quot;s&quot;</span>
      | _c_ =&gt; <span class="s2">&quot;c&quot;</span>
      | _belief_ =&gt; <span class="s2">&quot;b&quot;</span>
      | _testing_ =&gt; <span class="s2">&quot;t&quot;</span>
      | _audit_ =&gt; <span class="s2">&quot;a&quot;</span>
      | _compile_=&gt; <span class="s2">&quot;c&quot;</span>
      | _review_=&gt; <span class="s2">&quot;r&quot;</span>
      | _assess_ =&gt; <span class="s2">&quot;a&quot;</span>
      | _business_procedure_ =&gt; <span class="s2">&quot;p&quot;</span>
      | _ingredients_percentage_list_ =&gt; <span class="s2">&quot;e_{PI}&quot;</span>
      | _breakdown_of_formulations_list_=&gt; <span class="s2">&quot;e_{BF}&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree actor_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _a1_ =&gt; <span class="s2">&quot;a_{1}&quot;</span>
      | _a2_ =&gt; <span class="s2">&quot;a_{2}&quot;</span>
      | _a3_ =&gt; <span class="s2">&quot;a_{3}&quot;</span>
      | _a4_ =&gt; <span class="s2">&quot;a_{4}&quot;</span>
      | _aQ_ =&gt; <span class="s2">&quot;a_{?}&quot;</span>
      | _retailer_ =&gt; <span class="s2">&quot;r&quot;</span>
      | _vineyard_ =&gt; <span class="s2">&quot;v&quot;</span>
      | _winery_ =&gt; <span class="s2">&quot;w&quot;</span>
      | _P_ =&gt; <span class="s2">&quot;P&quot;</span>
      | _Q_ =&gt; <span class="s2">&quot;Q&quot;</span>
      | _applicant_ =&gt; <span class="s2">&quot;A&quot;</span>
      | _certifier_ =&gt; <span class="s2">&quot;C&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree claim_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _c1_ =&gt; <span class="s2">&quot;C_{1}&quot;</span>
      | _c2_ =&gt; <span class="s2">&quot;C_{2}&quot;</span>
      | _c3_ =&gt; <span class="s2">&quot;C_{3}&quot;</span>
      | _c4_ =&gt; <span class="s2">&quot;C_{4}&quot;</span>
      | _c5_ =&gt; <span class="s2">&quot;C_{5}&quot;</span>
      | _cQ_ =&gt; <span class="s2">&quot;C_{?}&quot;</span>
      | _healthy_ =&gt; <span class="s2">&quot;H&quot;</span>
      | _nonToxic_ =&gt; <span class="s2">&quot;N&quot;</span>
      | _organic_ =&gt; <span class="s2">&quot;O&quot;</span>
      | _ingredients_valid_ =&gt; <span class="s2">&quot;\mathit{IV}&quot;</span>
      | _ingredients_valid_approved_ =&gt; <span class="s2">&quot;\mathit{IVA}&quot;</span>
      | _recipe_valid_ =&gt; <span class="s2">&quot;\mathit{RV}&quot;</span>      
      | _percentage_ingredients_valid_ =&gt; <span class="s2">&quot;\mathit{PIV}&quot;</span>
      | _breakdown_of_formulations_valid_ =&gt; <span class="s2">&quot;\mathit{BFV}&quot;</span>
      | _successful_market_compliance_assessment_ =&gt; <span class="s2">&quot;\mathit{SMCA}&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree trust_relation_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _T_ =&gt; <span class="s2">&quot;T&quot;</span>
      | _U_ =&gt; <span class="s2">&quot;U&quot;</span>
      | _V_ =&gt; <span class="s2">&quot;V&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage atomic_evid_name := { 
  showForNaturalLanguage n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _e_ =&gt; <span class="s2">&quot;atomic evidence e&quot;</span>
      | _e1_ =&gt; <span class="s2">&quot;atomic evidence 1&quot;</span>
      | _e2_ =&gt; <span class="s2">&quot;atomic evidence 2&quot;</span>
      | _e3_ =&gt; <span class="s2">&quot;atomic evidence 3&quot;</span>
      | _e4_ =&gt; <span class="s2">&quot;atomic evidence 4&quot;</span>
      | _eQ_ =&gt;  <span class="s2">&quot;unknown evidence&quot;</span>
      | _l_ =&gt; <span class="s2">&quot;atomic evidence l&quot;</span>
      | _s_ =&gt; <span class="s2">&quot;atomic evidence s&quot;</span>
      | _c_ =&gt; <span class="s2">&quot;atomic evidence c&quot;</span>
      | _belief_ =&gt; <span class="s2">&quot;belief&quot;</span>
      | _testing_ =&gt; <span class="s2">&quot;testing&quot;</span>
      | _audit_ =&gt; <span class="s2">&quot;audit&quot;</span>
      | _compile_=&gt; <span class="s2">&quot;compile&quot;</span>
      | _review_=&gt; <span class="s2">&quot;review&quot;</span>
      | _assess_ =&gt; <span class="s2">&quot;assess&quot;</span>
      | _business_procedure_ =&gt; <span class="s2">&quot;business procedure&quot;</span>
      | _ingredients_percentage_list_ =&gt; <span class="s2">&quot;ingredients percentage list&quot;</span>
      | _breakdown_of_formulations_list_ =&gt; <span class="s2">&quot;breakdown of formulations list&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq atomic_evid_name := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage actor_name := { 
  showForNaturalLanguage n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _a1_ =&gt; <span class="s2">&quot;actor 1&quot;</span>
      | _a2_ =&gt; <span class="s2">&quot;actor 2&quot;</span>
      | _a3_ =&gt; <span class="s2">&quot;actor 3&quot;</span>
      | _a4_ =&gt; <span class="s2">&quot;actor 4&quot;</span>
      | _aQ_ =&gt; <span class="s2">&quot;unknown actor&quot;</span>
      | _retailer_ =&gt; <span class="s2">&quot;retailer&quot;</span>
      | _vineyard_ =&gt; <span class="s2">&quot;vineyard&quot;</span>
      | _winery_ =&gt; <span class="s2">&quot;winery&quot;</span>
      | _P_ =&gt; <span class="s2">&quot;Penelope&quot;</span>
      | _Q_ =&gt; <span class="s2">&quot;Quintin&quot;</span>
      | _applicant_ =&gt; <span class="s2">&quot;applicant&quot;</span>
      | _certifier_ =&gt; <span class="s2">&quot;certifier&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq actor_name := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage claim_name := { 
  showForNaturalLanguage n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _c1_ =&gt; <span class="s2">&quot;claim 1&quot;</span>
      | _c2_ =&gt; <span class="s2">&quot;claim 2&quot;</span>
      | _c3_ =&gt; <span class="s2">&quot;claim 3&quot;</span>
      | _c4_ =&gt; <span class="s2">&quot;claim 4&quot;</span>
      | _c5_ =&gt; <span class="s2">&quot;claim 5&quot;</span>
      | _cQ_ =&gt; <span class="s2">&quot;unknown claim&quot;</span>
      | _healthy_ =&gt; <span class="s2">&quot;healthy&quot;</span>
      | _nonToxic_ =&gt; <span class="s2">&quot;non-toxic&quot;</span>
      | _organic_ =&gt; <span class="s2">&quot;organic&quot;</span>
      | _ingredients_valid_ =&gt; <span class="s2">&quot;ingredients-valid&quot;</span>
      | _ingredients_valid_approved_ =&gt; <span class="s2">&quot;ingredients-valid-approved&quot;</span>
      | _recipe_valid_ =&gt; <span class="s2">&quot;recipe-valid&quot;</span>      
      | _percentage_ingredients_valid_ =&gt; <span class="s2">&quot;percentage-ingredients-valid&quot;</span>
      | _breakdown_of_formulations_valid_ =&gt; <span class="s2">&quot;breakdown-of-formulations-valid&quot;</span>
      | _successful_market_compliance_assessment_ =&gt; <span class="s2">&quot;successful-market-compliance-assessment&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq claim_name := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage trust_relation_name := { 
  showForNaturalLanguage n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _T_ =&gt; <span class="s2">&quot;trust relation T&quot;</span>
      | _U_ =&gt; <span class="s2">&quot;trust relation U&quot;</span>
      | _V_ =&gt; <span class="s2">&quot;trust relation V&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq trust_relation_name := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForProofTree_atomic_as_variable</span> (<span class="nv">n</span> : atomic_evid_name) :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | _e_ =&gt; <span class="s2">&quot;x_{e}&quot;</span>
  | _e1_ =&gt; <span class="s2">&quot;x_{1}&quot;</span>
  | _e2_ =&gt; <span class="s2">&quot;x_{2}&quot;</span>
  | _e3_ =&gt; <span class="s2">&quot;x_{3}&quot;</span>
  | _e4_ =&gt; <span class="s2">&quot;x_{4}&quot;</span>
  | _eQ_ =&gt; <span class="s2">&quot;x_{?}&quot;</span>
  | _l_ =&gt; <span class="s2">&quot;x&quot;</span>
  | _s_ =&gt; <span class="s2">&quot;y&quot;</span>
  | _c_ =&gt; <span class="s2">&quot;z&quot;</span>
  | _belief_ =&gt; <span class="s2">&quot;x_{b}&quot;</span>
  | _testing_ =&gt; <span class="s2">&quot;x_{t}&quot;</span>
  | _audit_ =&gt; <span class="s2">&quot;x_{a}&quot;</span>
  | _compile_=&gt; <span class="s2">&quot;x_{c}&quot;</span>
  | _review_=&gt; <span class="s2">&quot;x_{r}&quot;</span>
  | _assess_ =&gt; <span class="s2">&quot;x_{assess}&quot;</span>
  | _business_procedure_ =&gt; <span class="s2">&quot;x_{p}&quot;</span>
  | _ingredients_percentage_list_ =&gt; <span class="s2">&quot;x_{PI}&quot;</span>
  | _breakdown_of_formulations_list_=&gt; <span class="s2">&quot;x_{BF}&quot;</span>
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">contains</span> {<span class="nv">A</span>} `{Beq A} (x : A) (l : list A) : bool :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; false
  | h :: tl =&gt; (x =? h) || contains x tl
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForProofTreeEvid</span> (<span class="nv">atomicAsVariables</span> : list evid) <span class="nv">e</span> :=
  <span class="kr">match</span> e <span class="kr">with</span>
  | AtomicEvid name =&gt; <span class="kr">if</span> contains (AtomicEvid name) atomicAsVariables <span class="kr">then</span> showForProofTree_atomic_as_variable name <span class="kr">else</span> showForProofTree name
  | Pair e1 e2 =&gt; <span class="s2">&quot;(&quot;</span> ++ (showForProofTreeEvid atomicAsVariables e1) ++ <span class="s2">&quot;, &quot;</span>
                      ++ (showForProofTreeEvid atomicAsVariables e2) ++ <span class="s2">&quot;)&quot;</span>
  | Left e =&gt; <span class="s2">&quot;i(&quot;</span> ++ showForProofTreeEvid atomicAsVariables e ++ <span class="s2">&quot;)&quot;</span>
  | Right e =&gt; <span class="s2">&quot;j(&quot;</span> ++ showForProofTreeEvid atomicAsVariables e ++ <span class="s2">&quot;)&quot;</span>
  | Lambda e1 e2 =&gt; <span class="s2">&quot;\lambda(&quot;</span> ++ showForProofTreeEvid (e1 :: atomicAsVariables) e1 ++ <span class="s2">&quot;)(&quot;</span> ++ showForProofTreeEvid (e1 :: atomicAsVariables) e2 ++ <span class="s2">&quot;)&quot;</span>
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree evid := {
  showForProofTree := showForProofTreeEvid []
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage evid := { showForNaturalLanguage := showForProofTree }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq evid := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree claim := {
  showForProofTree :=
  <span class="kr">fix</span> showForProofTreeClaim c :=
    <span class="kr">match</span> c <span class="kr">with</span>
      | AtomicClaim name =&gt; showForProofTree name
      | Bottom =&gt; <span class="s2">&quot;\bot&quot;</span>
      | And c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForProofTreeClaim c1 ++ <span class="s2">&quot; \wedge &quot;</span> ++ showForProofTreeClaim c2 ++ <span class="s2">&quot;)&quot;</span>
      | Or c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForProofTreeClaim c1 ++ <span class="s2">&quot; \vee &quot;</span> ++ showForProofTreeClaim c2 ++ <span class="s2">&quot;)&quot;</span>
      | Implies c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForProofTreeClaim c1 ++ <span class="s2">&quot; \rightarrow &quot;</span> ++ showForProofTreeClaim c2 ++ <span class="s2">&quot;)&quot;</span>
    <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage claim := {
  showForNaturalLanguage :=
  <span class="kr">fix</span> showForNaturalLanguageClaim c :=
    <span class="kr">match</span> c <span class="kr">with</span>
      | AtomicClaim name =&gt; showForNaturalLanguage name
      | Bottom =&gt; <span class="s2">&quot;impossible&quot;</span>
      | And c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForNaturalLanguageClaim c1 ++ <span class="s2">&quot; and &quot;</span> ++ showForNaturalLanguageClaim c2  ++ <span class="s2">&quot;)&quot;</span>
      | Or c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForNaturalLanguageClaim c1 ++ <span class="s2">&quot; or &quot;</span> ++ showForNaturalLanguageClaim c2 ++ <span class="s2">&quot;)&quot;</span>
      | Implies c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForNaturalLanguageClaim c1 ++ <span class="s2">&quot; implies &quot;</span> ++ showForNaturalLanguageClaim c2 ++ <span class="s2">&quot;)&quot;</span>
    <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq claim := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree actor := {
  showForProofTree a :=
  <span class="kr">match</span> a <span class="kr">with</span>
    | Actor name =&gt; showForProofTree name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage actor := {
  showForNaturalLanguage a :=
  <span class="kr">match</span> a <span class="kr">with</span>
    | Actor name =&gt; showForNaturalLanguage name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq actor := {
  showForLogSeq a :=
  <span class="kr">match</span> a <span class="kr">with</span>
    | Actor name =&gt; showForLogSeq name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree trustRelation := {
  showForProofTree t :=
  <span class="kr">match</span> t <span class="kr">with</span>
    | Trust name =&gt; showForProofTree name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage trustRelation := {
  showForNaturalLanguage t :=
  <span class="kr">match</span> t <span class="kr">with</span>
    | Trust name =&gt; showForNaturalLanguage name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq trustRelation := {
  showForLogSeq t :=
  <span class="kr">match</span> t <span class="kr">with</span>
    | Trust name =&gt; showForLogSeq name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForProofTree_list</span> {<span class="nv">A</span>} `{ShowForProofTree A} (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;&quot;</span>
    | [h] =&gt; showForProofTree h
    | h1 :: (h2 :: tl) <span class="kr">as</span> tl&#39; =&gt; showForProofTree h1 ++ <span class="s2">&quot;, &quot;</span> ++ showForProofTree_list tl&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForProofTree_list_instance</span> (<span class="nv">A</span> : <span class="kt">Type</span>) `(ShowForProofTree A) : ShowForProofTree (list A) := {
  showForProofTree l := showForProofTree_list l
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk7d"><span class="kn">Fixpoint</span> <span class="nf">showForNaturalLanguage_list</span> {<span class="nv">A</span>} `{ShowForNaturalLanguage A} (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;no items&quot;</span>
    | [h] =&gt; showForNaturalLanguage h
    | [h1;h2] =&gt; showForNaturalLanguage h1 ++ <span class="s2">&quot;, and &quot;</span> ++ showForNaturalLanguage h2
    | h1 :: (h2 :: tl) <span class="kr">as</span> tl&#39; =&gt; showForNaturalLanguage h1 ++ <span class="s2">&quot;, &quot;</span> ++ showForNaturalLanguage_list tl&#39;
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Unused variable tl might be a misspelled <span class="nb">constructor</span>.
Use _ or _tl to silence this warning.
[unused-<span class="nb">pattern</span>-matching-variable,<span class="nb">pattern</span>-matching]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForNaturalLanguage_list_instance</span> (<span class="nv">A</span> : <span class="kt">Type</span>) `(ShowForNaturalLanguage A) : ShowForNaturalLanguage (list A) := {
    showForNaturalLanguage l := showForNaturalLanguage_list l
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForLogSeq_list</span> {<span class="nv">A</span>} `{ShowForLogSeq A} (indent : string) (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;&quot;</span>
    | [h] =&gt; indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq h
    | h :: tl =&gt; indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq h ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ showForLogSeq_list indent tl
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree judgement := {
  showForProofTree j :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | Judgement e a c =&gt; showForProofTree e ++ <span class="s2">&quot;^{&quot;</span> ++ showForProofTree a ++ <span class="s2">&quot;} \in &quot;</span>
                                  ++ showForProofTree c
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage judgement := {
  showForNaturalLanguage j :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | Judgement e a c =&gt; showForNaturalLanguage c ++ <span class="s2">&quot; is supported by $&quot;</span> ++ showForNaturalLanguage e ++ <span class="s2">&quot;$ which &quot;</span> ++ showForNaturalLanguage a ++ <span class="s2">&quot; uses&quot;</span>
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq judgement := {
  showForLogSeq j :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | Judgement e a c =&gt; showForLogSeq c ++ <span class="s2">&quot; is held by &quot;</span> ++ showForLogSeq a ++ <span class="s2">&quot; by the evidence $&quot;</span> ++ showForLogSeq e ++ <span class="s2">&quot;$&quot;</span>
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForProofTree_judgement</span> (<span class="nv">Ps</span> : list judgement) (<span class="nv">Ts</span> : list trustRelation) (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j) :=
    <span class="kr">match</span> Ps <span class="kr">with</span>
      | [] =&gt; showForProofTree j
      | (h :: tl) <span class="kr">as</span> Ps =&gt; showForProofTree Ps ++ <span class="s2">&quot; \vdash_{&quot;</span> ++ showForProofTree Ts ++ <span class="s2">&quot;} &quot;</span> ++ (showForProofTree j)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForNaturalLanguage_judgement</span> (<span class="nv">Ps</span> : list judgement) (<span class="nv">Ts</span> : list trustRelation) (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j) :=
  <span class="kr">match</span> Ps <span class="kr">with</span>
    | [] =&gt; showForNaturalLanguage j
    | (h :: tl) <span class="kr">as</span> Ps =&gt; <span class="s2">&quot;Assuming &quot;</span> ++ showForNaturalLanguage Ps ++ <span class="s2">&quot; then &quot;</span> ++ showForNaturalLanguage j
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForLogSeq_judgement</span> (<span class="nv">Ps</span> : list judgement) (<span class="nv">Ts</span> : list trustRelation) (<span class="nv">indent</span> : string) (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j) :=
  <span class="kr">match</span> Ps,Ts <span class="kr">with</span>
        | [],[] =&gt; showForLogSeq j
        | (h :: tl),[] =&gt; showForLogSeq j ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;collapsed:: true</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Assumptions made:</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;  collapsed:: true</span>
<span class="s2">&quot;</span> ++ showForLogSeq_list (<span class="s2">&quot;  &quot;</span> ++ indent) Ps
        | [],(h :: tl) =&gt; showForLogSeq j ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;collapsed:: true</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Trust relations used:</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;  collapsed:: true</span>
<span class="s2">&quot;</span> ++ showForLogSeq_list (<span class="s2">&quot;  &quot;</span> ++ indent) Ts
        | (h :: tl),(h2::tl2) =&gt; showForLogSeq j ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;collapsed:: true</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Assumptions made:</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;  collapsed:: true</span>
<span class="s2">&quot;</span> ++ showForLogSeq_list (<span class="s2">&quot;  &quot;</span> ++ indent) Ps ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Trust relations used:</span>
<span class="s2">&quot;</span> ++ indent ++ <span class="s2">&quot;  collapsed:: true</span>
<span class="s2">&quot;</span> ++ showForLogSeq_list (<span class="s2">&quot;  &quot;</span> ++ indent) Ts
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAllTrustRelationsUsed</span> (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j)
  : list trustRelation :=
<span class="kr">match</span> p <span class="kr">with</span>
| assume e a C =&gt; []
| and_intro e1 e2 a C1 C2 L R =&gt; 
    getAllTrustRelationsUsed _ L ++ getAllTrustRelationsUsed _ R 
| and_elim1 e1 e2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| and_elim2 e1 e2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_intro1 e1  a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_intro2 e2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_elim1 e1 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_elim2 e2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| trust e a1 a2 C name L =&gt;     name :: getAllTrustRelationsUsed _ L
| impl_intro _ _ _ _ _ _ M =&gt; getAllTrustRelationsUsed _ M
| impl_elim _ _ _ _ _ _ _ _ _ M =&gt; getAllTrustRelationsUsed _ M
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAllEvidence</span> (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j)
  : list evid :=
<span class="kr">match</span> p <span class="kr">with</span>
| assume e a C =&gt; [(AtomicEvid e)]
| and_intro e1 e2 a C1 C2 L R =&gt; getAllEvidence _ L ++ getAllEvidence _ R 
| and_elim1 e1 e2 a C1 C2 M =&gt; getAllEvidence _ M
| and_elim2 e1 e2 a C1 C2 M =&gt; getAllEvidence _ M
| or_intro1 e1 a C1 C2 M =&gt; getAllEvidence _ M
| or_intro2 e2 a C1 C2 M =&gt; getAllEvidence _ M
| or_elim1 e1 a C1 C2 M =&gt; getAllEvidence _ M
| or_elim2 e2 a C1 C2 M =&gt; getAllEvidence _ M
| trust e a1 a2 C name L =&gt; getAllEvidence _ L| impl_intro _ _ _ _ _ _ M =&gt; getAllEvidence _ M
| impl_elim _ _ _ _ _ _ _ _ _ M =&gt; getAllEvidence _ M
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isAtomicEvidence</span> (<span class="nv">e</span> : evid) : bool :=
<span class="kr">match</span> e <span class="kr">with</span>
  | AtomicEvid _ =&gt; true
  | _ =&gt; false
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAssumptions</span> (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j) : list judgement := 
<span class="kr">match</span> p <span class="kr">with</span>
| assume e a C =&gt; [(AtomicEvid e) \<span class="bp">by</span> a \<span class="kr">in</span> C]
| and_intro e1 e2 a C1 C2 L R =&gt; 
    getAssumptions _ L ++ getAssumptions _ R 
| and_elim1 e1 e2 a C1 C2 M =&gt; getAssumptions _ M
| and_elim2 e1 e2 a C1 C2 M =&gt; getAssumptions _ M
| or_intro1 e1 a C1 C2 M =&gt; getAssumptions _ M
| or_intro2 e2 a C1 C2 M =&gt; getAssumptions _ M
| or_elim1 e1 a C1 C2 M =&gt; getAssumptions _ M
| or_elim2 e2 a C1 C2 M =&gt; getAssumptions _ M
| trust e a1 a2 C name L =&gt; 
    getAssumptions _ L
| impl_intro e1 e2 a C1 C2 _ M =&gt; filter (<span class="kr">fun</span> <span class="nv">j</span> =&gt; negb (judgement_beq (e1 \<span class="bp">by</span> a \<span class="kr">in</span> C1) j)) (getAssumptions _ M)
| impl_elim _ _ _ _ _ _ _ _ L R =&gt; getAssumptions _ L ++ getAssumptions _ R
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">removeDups</span> {<span class="nv">A</span>} `{Beq A} (l : list A) : list A :=
    <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; []
    | h :: tl =&gt; <span class="kr">if</span> existsb (beq h) tl <span class="kr">then</span> removeDups tl <span class="kr">else</span> h :: removeDups tl
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForProofTree_proofTreeOf_helper</span> (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j)
  : string :=
<span class="kr">let</span> <span class="nv">Ts</span> := (removeDups (getAllTrustRelationsUsed j p)) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">Ps</span> := (removeDups (getAssumptions j p)) <span class="kr">in</span>
<span class="kr">match</span> p <span class="kr">with</span>
| assume e a C =&gt; <span class="s2">&quot;\AxiomC{$ &quot;</span> 
             ++ showForProofTree C 
             ++ <span class="s2">&quot; \textit{ is a veracity claim} $}&quot;</span>
    ++ <span class="s2">&quot; \RightLabel{ $ assume $}\UnaryInfC{$ &quot;</span>
    ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
| and_intro e1 e2 a C1 C2 L R =&gt; 
    showForProofTree_proofTreeOf_helper _ L
 ++ showForProofTree_proofTreeOf_helper _ R 
 ++ <span class="s2">&quot; \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
 | and_elim1 e1 e2 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \land^{-1} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| and_elim2 e1 e2 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \land^{-2} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
 | or_intro1 e1 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{+1} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_intro2 e2 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{+2} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
 | or_elim1 e1 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{-1} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_elim2 e2 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{-2} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
 | trust e a1 a2 C name L =&gt; 
    showForProofTree_proofTreeOf_helper _ L
 ++ <span class="s2">&quot; \AxiomC{$&quot;</span> ++ showForProofTree a1 ++ showForProofTree name ++ showForProofTree a2 ++ <span class="s2">&quot;$} &quot;</span>
 ++ <span class="s2">&quot; \RightLabel{ $ trust\ &quot;</span> ++ showForProofTree name
 ++ <span class="s2">&quot;$} \BinaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
| impl_intro e1 e2 a C1 C2 H M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| impl_elim x bx y a C1 C2 H1 H2 L R =&gt; 
     showForProofTree_proofTreeOf_helper _ L
 ++ showForProofTree_proofTreeOf_helper _ R 
 ++ <span class="s2">&quot; \RightLabel{ $ \rightarrow^{-} $} \BinaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForNaturalLanguage_proofTreeOf_helper</span> (<span class="nv">indent</span> : string) (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j)
  : string :=
<span class="kr">let</span> <span class="nv">Ts</span> := (removeDups (getAllTrustRelationsUsed j p)) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">Ps</span> := (removeDups (getAssumptions j p)) <span class="kr">in</span>
<span class="kr">match</span> p <span class="kr">with</span>
| assume e a C =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ indent ++ showForNaturalLanguage C ++ <span class="s2">&quot; is a veracity claim.&quot;</span> ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by assumption.&quot;</span>
| and_intro e1 e2 a C1 C2 L R =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ L ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ R ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;and&#39;.&quot;</span>
| and_elim1 e1 e2 a C1 C2 M =&gt;
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;and&#39;.&quot;</span>
| and_elim2 e1 e2 a C1 C2 M =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;and&#39;.&quot;</span>
| or_intro1 e1 a C1 C2 M =&gt;
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;or&#39;.&quot;</span>
| or_intro2 e2 a C1 C2 M =&gt;
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;or&#39;.&quot;</span>
| or_elim1 e1 a C1 C2 M =&gt;
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;or&#39;.&quot;</span>
| or_elim2 e2 a C1 C2 M =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for &#39;or&#39;.&quot;</span>
| trust e a1 a2 C name L =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ L ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by the trust relation &quot;</span> ++ showForNaturalLanguage name ++ <span class="s2">&quot;.&quot;</span>
| impl_intro _ _ _ _ _ _ M =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ M ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for implication.&quot;</span>
| impl_elim _ _ _ _ _  _ _ _ L R =&gt; 
indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ <span class="s2">&quot;, because</span>
<span class="s2">&quot;</span> 
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ L ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ showForNaturalLanguage_proofTreeOf_helper (<span class="s2">&quot;  &quot;</span> ++ indent) _ R ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span>
++ indent ++ <span class="s2">&quot;by a logical rule for implication.&quot;</span>
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForLogSeq_proofTreeOf_helper</span> (<span class="nv">indent</span> : string) (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : proofTreeOf j)
  : string :=
<span class="kr">let</span> <span class="nv">Ts</span> := (removeDups (getAllTrustRelationsUsed j p)) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">Ps</span> := (removeDups (getAssumptions j p)) <span class="kr">in</span>
<span class="kr">match</span> p <span class="kr">with</span>
| assume e a C =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: we assume this&quot;</span>
| and_intro e1 e2 a C1 C2 L R =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: and introduction</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proofs:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ L ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ R
| and_elim1 e1 e2 a C1 C2 M =&gt;
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: and elimination (1)</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| and_elim2 e1 e2 a C1 C2 M =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: and elimination (2)</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| or_intro1 e1 a C1 C2 M =&gt;
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: or introduction (1)</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| or_intro2 e2 a C1 C2 M =&gt;
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: or introduction (2)</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| or_elim1 e1 a C1 C2 M =&gt;
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: or elimination (1)</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| or_elim2 e2 a C1 C2 M =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: or elimination (2)</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| trust e a1 a2 C name L =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: trust, with relation &quot;</span> ++ showForLogSeq name ++ <span class="s2">&quot;</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ L
| impl_intro _ _ _ _ _ _ M =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: implication introduction</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proof:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ M
| impl_elim _ _ _ _ _  _ _ _ L R =&gt; 
indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq_judgement Ps Ts (<span class="s2">&quot;  &quot;</span> ++ indent) _ p ++ <span class="s2">&quot;</span>
<span class="s2">  &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Logical rule used: implication elimination</span>
<span class="s2">    &quot;</span> ++ indent ++ <span class="s2">&quot;- &quot;</span> ++ <span class="s2">&quot;Sub-proofs:</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ L ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper (<span class="s2">&quot;      &quot;</span> ++ indent) _ R
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForProofTree_list_newline</span> {<span class="nv">A</span>} `{ShowForProofTree A} (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;&quot;</span>
    | [h] =&gt; showForProofTree h
    | h1 :: (h2 :: tl) <span class="kr">as</span> tl&#39; =&gt; showForProofTree h1 ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ showForProofTree_list_newline tl&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForProofTree_proofTreeOf</span> <span class="nv">j</span> <span class="nv">p</span>
  := <span class="s2">&quot;\begin{prooftree}&quot;</span> ++ showForProofTree_proofTreeOf_helper j p
       ++ <span class="s2">&quot;\end{prooftree}&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForProofTree_proofTreeOf_instance</span> (<span class="nv">j</span> : judgement)
  : ShowForProofTree (proofTreeOf j) := { showForProofTree := showForProofTree_proofTreeOf j}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForNaturalLanguage_proofTreeOf</span> <span class="nv">j</span> (<span class="nv">p</span> : proofTreeOf j) := <span class="s2">&quot;</span>

<span class="s2">&quot;</span> ++ showForNaturalLanguage_proofTreeOf_helper <span class="s2">&quot;- &quot;</span> j p ++ <span class="s2">&quot;</span>

<span class="s2">&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForNaturalLanguage_proofTreeOf_instance</span> (<span class="nv">j</span> : judgement)
  : ShowForNaturalLanguage (proofTreeOf j) := { showForNaturalLanguage := showForNaturalLanguage_proofTreeOf j}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">printProofTitle</span> <span class="nv">j</span> :=
<span class="kr">match</span> j <span class="kr">with</span>
| Judgement e a c =&gt; <span class="s2">&quot;### Veracity proof that &quot;</span> ++ showForLogSeq c ++ <span class="s2">&quot; is held by &quot;</span> ++ showForLogSeq a ++ <span class="s2">&quot; by the evidence &quot;</span> ++ showForLogSeq e
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq string := { showForLogSeq := id}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForLogSeq_proofTreeOf</span> <span class="nv">j</span> (<span class="nv">p</span> : proofTreeOf j) := 
<span class="kr">let</span> <span class="nv">evidenceList</span> := (removeDups (filter isAtomicEvidence (getAllEvidence j p))) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">evidenceWithNames</span> := map (<span class="kr">fun</span> <span class="nv">e</span> =&gt; <span class="kr">match</span> e <span class="kr">with</span>
                                   | AtomicEvid n =&gt; showForLogSeq e ++ <span class="s2">&quot; = &quot;</span> ++ showForLogSeq n
                                   | _ =&gt; <span class="s2">&quot;&quot;</span>
                                   <span class="kr">end</span>) evidenceList <span class="kr">in</span>
<span class="s2">&quot;</span>

<span class="s2">&quot;</span> ++ printProofTitle j ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ showForLogSeq_proofTreeOf_helper <span class="s2">&quot;  &quot;</span> j p ++ <span class="s2">&quot;</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">&quot;</span> ++ showForLogSeq_list <span class="s2">&quot;    &quot;</span> evidenceWithNames ++ <span class="s2">&quot;</span>

<span class="s2">&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForLogSeq_proofTreeOf_instance</span> (<span class="nv">j</span> : judgement)
  : ShowForLogSeq (proofTreeOf j) := { showForLogSeq := showForLogSeq_proofTreeOf j}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showListOfProofTrees</span> {<span class="nv">j</span> : judgement} (<span class="nv">l</span> : list (proofTreeOf j)) :=
    <span class="kr">match</span> l <span class="kr">with</span>
      | [] =&gt; <span class="s2">&quot;&quot;</span>
      | h :: tl =&gt; <span class="s2">&quot;</span>

<span class="s2">----------------</span>

<span class="s2">&quot;</span> ++ showForProofTree h ++ showListOfProofTrees tl
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForProofTree_proofTreeOf_wrapped_instance</span> (<span class="nv">a</span> : actor) (<span class="nv">c</span> : claim) : ShowForProofTree (proofTreeOf_wrapped a c) := { showForProofTree p := showForProofTree (_p a c p) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForNaturalLanguage_proofTreeOf_wrapped_instance</span> (<span class="nv">a</span> : actor) (<span class="nv">c</span> : claim) : ShowForNaturalLanguage (proofTreeOf_wrapped a c) := { showForNaturalLanguage p := showForNaturalLanguage (_p a c p) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForLogSeq_proofTreeOf_wrapped_instance</span> (<span class="nv">a</span> : actor) (<span class="nv">c</span> : claim) : ShowForLogSeq (proofTreeOf_wrapped a c) := { showForLogSeq p := showForLogSeq (_p a c p) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">validateFDef</span> :=
  <span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">simpl</span>; <span class="nb">autounfold with</span> veracityPrf; <span class="nb">simpl</span>; <span class="bp">reflexivity</span>);
  <span class="kp">try</span> (<span class="nb">simpl</span>; <span class="bp">reflexivity</span>).</span></span></pre></div>
<div class="section" id="examples">
<h1>Examples</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e</span> := AtomicEvid _e_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e1</span> := AtomicEvid _e1_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a1</span> := Actor _a1_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c1</span> := AtomicClaim _c1_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e2</span> := AtomicEvid _e2_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a2</span> := Actor  _a2_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c2</span> := AtomicClaim _c2_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e3</span> := AtomicEvid _e3_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a3</span> := Actor _a3_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c3</span> := AtomicClaim _c3_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e4</span> := AtomicEvid  _e4_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a4</span> := Actor _a4_ .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c4</span> := AtomicClaim _c4_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">l</span> := AtomicEvid _l_ .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">s</span> := AtomicEvid _s_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c</span> := AtomicEvid _c_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">P</span> := Actor _P_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Q</span> := Actor _Q_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C1</span> := AtomicClaim _c1_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C2</span> := AtomicClaim _c2_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C3</span> := AtomicClaim _c3_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C4</span> := AtomicClaim _c4_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C5</span> := AtomicClaim _c5_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trustT</span> := Trust _T_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trustU</span> := Trust _U_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trustV</span> := Trust _V_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk7e"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree_judgement [(e1 \<span class="bp">by</span> a1 \<span class="kr">in</span> c1)] [] (e1 \<span class="bp">by</span> a1 \<span class="kr">in</span> c1) (assume _e1_ a1 c1).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1}&quot;</span>
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk7f"><span class="kn">Definition</span> <span class="nf">process_example</span> : proofTreeOf_wrapped a1 (c3 -&gt;&#39; (c2 -&gt;&#39; (c1 -&gt;&#39; (c1 /\&#39; c2 /\&#39; c3)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1
  (c3 -&gt;&#39; c2 -&gt;&#39; c1 -&gt;&#39; c1 /\&#39; c2 /\&#39; c3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1
  (c3 -&gt;&#39; c2 -&gt;&#39; c1 -&gt;&#39; c1 /\&#39; c2 /\&#39; c3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk81"><span class="nb">eexists</span>  _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (c3 -&gt;&#39; c2 -&gt;&#39; c1 -&gt;&#39; c1 /\&#39; c2 /\&#39; c3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk82"><span class="nb">eapply</span> (impl_intro c _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c2 -&gt;&#39; c1 -&gt;&#39; c1 /\&#39; c2 /\&#39; c3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk83"><span class="nb">eapply</span> (impl_intro s _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 -&gt;&#39; c1 /\&#39; c2 /\&#39; c3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk84"><span class="nb">eapply</span> (impl_intro l _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 /\&#39; c2 /\&#39; c3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk85"><span class="nb">eapply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 /\&#39; c2)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk86"><span class="nb">eapply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e20</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk87"><span class="nb">eapply</span> (assume _l_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e20</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk88"><span class="nb">eapply</span> (assume _s_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume _c_).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk89"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda c
  (Lambda s
     (Lambda l
        {{AtomicEvid _l_, AtomicEvid _s_,
        AtomicEvid _c_}})) = true</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda s
  (Lambda l
     {{AtomicEvid _l_, AtomicEvid _s_,
     AtomicEvid _c_}}) = true</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda l
  {{AtomicEvid _l_, AtomicEvid _s_, AtomicEvid _c_}} =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="kp">try</span> <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8a"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree process_example).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{a_{1}} \in C_{1} \vdash_{} l^{a_{1}} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{a_{1}} \in C_{2} \vdash_{} s^{a_{1}} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{a_{1}} \in C_{1}, s^{a_{1}} \in C_{2} \vdash_{} (l, s)^{a_{1}} \in (C_{1} \wedge C_{2}) $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{a_{1}} \in C_{3} \vdash_{} c^{a_{1}} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{a_{1}} \in C_{1}, s^{a_{1}} \in C_{2}, c^{a_{1}} \in C_{3} \vdash_{} ((l, s), c)^{a_{1}} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ s^{a_{1}} \in C_{2}, c^{a_{1}} \in C_{3} \vdash_{} \lambda(x)(((x, s), c))^{a_{1}} \in (C_{1} \rightarrow ((C_{1} \wedge C_{2}) \wedge C_{3})) $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ c^{a_{1}} \in C_{3} \vdash_{} \lambda(y)(\lambda(x)(((x, y), c)))^{a_{1}} \in (C_{2} \rightarrow (C_{1} \rightarrow ((C_{1} \wedge C_{2}) \wedge C_{3}))) $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda(z)(\lambda(y)(\lambda(x)(((x, y), z))))^{a_{1}} \in (C_{3} \rightarrow (C_{2} \rightarrow (C_{1} \rightarrow ((C_{1} \wedge C_{2}) \wedge C_{3})))) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8b"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage process_example).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- (claim 3 implies (claim 2 implies (claim 1 implies ((claim 1 and claim 2) and claim 3)))) is supported by $\lambda(z)(\lambda(y)(\lambda(x)(((x, y), z))))$ which actor 1 uses, because</span>
<span class="s2">  - Assuming claim 3 is supported by $c$ which actor 1 uses then (claim 2 implies (claim 1 implies ((claim 1 and claim 2) and claim 3))) is supported by $\lambda(y)(\lambda(x)(((x, y), c)))$ which actor 1 uses, because</span>
<span class="s2">    - Assuming claim 2 is supported by $s$ which actor 1 uses, and claim 3 is supported by $c$ which actor 1 uses then (claim 1 implies ((claim 1 and claim 2) and claim 3)) is supported by $\lambda(x)(((x, s), c))$ which actor 1 uses, because</span>
<span class="s2">      - Assuming claim 1 is supported by $l$ which actor 1 uses, claim 2 is supported by $s$ which actor 1 uses, and claim 3 is supported by $c$ which actor 1 uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which actor 1 uses, because</span>
<span class="s2">        - Assuming claim 1 is supported by $l$ which actor 1 uses, and claim 2 is supported by $s$ which actor 1 uses then (claim 1 and claim 2) is supported by $(l, s)$ which actor 1 uses, because</span>
<span class="s2">          - Assuming claim 1 is supported by $l$ which actor 1 uses then claim 1 is supported by $l$ which actor 1 uses, because</span>
<span class="s2">          - claim 1 is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">          - Assuming claim 2 is supported by $s$ which actor 1 uses then claim 2 is supported by $s$ which actor 1 uses, because</span>
<span class="s2">          - claim 2 is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">        - by a logical rule for &#39;and&#39;.</span>
<span class="s2">        - Assuming claim 3 is supported by $c$ which actor 1 uses then claim 3 is supported by $c$ which actor 1 uses, because</span>
<span class="s2">        - claim 3 is a veracity claim.</span>
<span class="s2">        - by assumption.</span>
<span class="s2">      - by a logical rule for &#39;and&#39;.</span>
<span class="s2">    - by a logical rule for implication.</span>
<span class="s2">  - by a logical rule for implication.</span>
<span class="s2">- by a logical rule for implication.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8c"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForLogSeq process_example).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that (claim 3 implies (claim 2 implies (claim 1 implies ((claim 1 and claim 2) and claim 3)))) is held by actor 1 by the evidence \lambda(z)(\lambda(y)(\lambda(x)(((x, y), z))))</span>
<span class="s2">  - (claim 3 implies (claim 2 implies (claim 1 implies ((claim 1 and claim 2) and claim 3)))) is held by actor 1 by the evidence $\lambda(z)(\lambda(y)(\lambda(x)(((x, y), z))))$</span>
<span class="s2">    - Logical rule used: implication introduction</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - (claim 2 implies (claim 1 implies ((claim 1 and claim 2) and claim 3))) is held by actor 1 by the evidence $\lambda(y)(\lambda(x)(((x, y), c)))$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 3 is held by actor 1 by the evidence $c$</span>
<span class="s2">          - Logical rule used: implication introduction</span>
<span class="s2">            - Sub-proof:</span>
<span class="s2">              - (claim 1 implies ((claim 1 and claim 2) and claim 3)) is held by actor 1 by the evidence $\lambda(x)(((x, s), c))$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 2 is held by actor 1 by the evidence $s$</span>
<span class="s2">                  - claim 3 is held by actor 1 by the evidence $c$</span>
<span class="s2">                - Logical rule used: implication introduction</span>
<span class="s2">                  - Sub-proof:</span>
<span class="s2">                    - ((claim 1 and claim 2) and claim 3) is held by actor 1 by the evidence $((l, s), c)$</span>
<span class="s2">                      collapsed:: true</span>
<span class="s2">                      - Assumptions made:</span>
<span class="s2">                        collapsed:: true</span>
<span class="s2">                        - claim 1 is held by actor 1 by the evidence $l$</span>
<span class="s2">                        - claim 2 is held by actor 1 by the evidence $s$</span>
<span class="s2">                        - claim 3 is held by actor 1 by the evidence $c$</span>
<span class="s2">                      - Logical rule used: and introduction</span>
<span class="s2">                        - Sub-proofs:</span>
<span class="s2">                          - (claim 1 and claim 2) is held by actor 1 by the evidence $(l, s)$</span>
<span class="s2">                            collapsed:: true</span>
<span class="s2">                            - Assumptions made:</span>
<span class="s2">                              collapsed:: true</span>
<span class="s2">                              - claim 1 is held by actor 1 by the evidence $l$</span>
<span class="s2">                              - claim 2 is held by actor 1 by the evidence $s$</span>
<span class="s2">                            - Logical rule used: and introduction</span>
<span class="s2">                              - Sub-proofs:</span>
<span class="s2">                                - claim 1 is held by actor 1 by the evidence $l$</span>
<span class="s2">                                  collapsed:: true</span>
<span class="s2">                                  - Assumptions made:</span>
<span class="s2">                                    collapsed:: true</span>
<span class="s2">                                    - claim 1 is held by actor 1 by the evidence $l$</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">                                - claim 2 is held by actor 1 by the evidence $s$</span>
<span class="s2">                                  collapsed:: true</span>
<span class="s2">                                  - Assumptions made:</span>
<span class="s2">                                    collapsed:: true</span>
<span class="s2">                                    - claim 2 is held by actor 1 by the evidence $s$</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">                          - claim 3 is held by actor 1 by the evidence $c$</span>
<span class="s2">                            collapsed:: true</span>
<span class="s2">                            - Assumptions made:</span>
<span class="s2">                              collapsed:: true</span>
<span class="s2">                              - claim 3 is held by actor 1 by the evidence $c$</span>
<span class="s2">                            - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - l = atomic evidence l</span>
<span class="s2">    - s = atomic evidence s</span>
<span class="s2">    - c = atomic evidence c</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8d"><span class="kn">Definition</span> <span class="nf">impl_intro1</span> : proofTreeOf_wrapped a1 ((Implies c1 c1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (c1 -&gt;&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8e"><span class="nb">eexists</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 -&gt;&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8f"><span class="nb">eapply</span> (impl_intro e1 _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume _e1_).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk90"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda e1 (AtomicEvid _e1_) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk91"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree impl_intro1).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda(x_{1})(x_{1})^{a_{1}} \in (C_{1} \rightarrow C_{1}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk92"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage impl_intro1).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- (claim 1 implies claim 1) is supported by $\lambda(x_{1})(x_{1})$ which actor 1 uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $e_{1}$ which actor 1 uses then claim 1 is supported by $e_{1}$ which actor 1 uses, because</span>
<span class="s2">  - claim 1 is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">- by a logical rule for implication.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk93"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForLogSeq impl_intro1).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that (claim 1 implies claim 1) is held by actor 1 by the evidence \lambda(x_{1})(x_{1})</span>
<span class="s2">  - (claim 1 implies claim 1) is held by actor 1 by the evidence $\lambda(x_{1})(x_{1})$</span>
<span class="s2">    - Logical rule used: implication introduction</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{1} = atomic evidence 1</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk94"><span class="kn">Definition</span> <span class="nf">impl_intro_elim</span> : proofTreeOf_wrapped a1 (c1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk95"><span class="nb">eexists</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk96"><span class="nb">eapply</span> (impl_elim e1 _ e2 a1 C1 C1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (Lambda e1 <span class="nl">?bx</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> (C1 -&gt;&#39; C1)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e2 \<span class="bp">by</span> a1 \<span class="kr">in</span> C1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk97"><span class="nb">eapply</span> (impl_intro e1 _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> C1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e2 \<span class="bp">by</span> a1 \<span class="kr">in</span> C1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk98"><span class="nb">eapply</span> (assume _e1_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e2 \<span class="bp">by</span> a1 \<span class="kr">in</span> C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume _e2_).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk99"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat e1 e2 = true</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda e1 (AtomicEvid _e1_) = true</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda e1 (AtomicEvid _e1_) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9a"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree impl_intro_elim).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda(x_{1})(x_{1})^{a_{1}} \in (C_{1} \rightarrow C_{1}) $}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{2}^{a_{1}} \in C_{1} \vdash_{} e_{2}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^{-} $} \BinaryInfC{$ e_{2}^{a_{1}} \in C_{1} \vdash_{} e_{2}^{a_{1}} \in C_{1} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9b"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage impl_intro_elim).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $e_{2}$ which actor 1 uses then claim 1 is supported by $e_{2}$ which actor 1 uses, because</span>
<span class="s2">  - (claim 1 implies claim 1) is supported by $\lambda(x_{1})(x_{1})$ which actor 1 uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $e_{1}$ which actor 1 uses then claim 1 is supported by $e_{1}$ which actor 1 uses, because</span>
<span class="s2">    - claim 1 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for implication.</span>
<span class="s2">  - Assuming claim 1 is supported by $e_{2}$ which actor 1 uses then claim 1 is supported by $e_{2}$ which actor 1 uses, because</span>
<span class="s2">  - claim 1 is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">- by a logical rule for implication.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9c"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForLogSeq impl_intro_elim).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that claim 1 is held by actor 1 by the evidence e_{2}</span>
<span class="s2">  - claim 1 is held by actor 1 by the evidence $e_{2}$</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - Assumptions made:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - claim 1 is held by actor 1 by the evidence $e_{2}$</span>
<span class="s2">    - Logical rule used: implication elimination</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - (claim 1 implies claim 1) is held by actor 1 by the evidence $\lambda(x_{1})(x_{1})$</span>
<span class="s2">          - Logical rule used: implication introduction</span>
<span class="s2">            - Sub-proof:</span>
<span class="s2">              - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">        - claim 1 is held by actor 1 by the evidence $e_{2}$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by actor 1 by the evidence $e_{2}$</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{2} = atomic evidence 2</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9d"><span class="kn">Definition</span> <span class="nf">impl_intro_elim2</span> : proofTreeOf_wrapped a1 (c1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9e"><span class="nb">eexists</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9f"><span class="nb">eapply</span> (impl_elim _ _ {{e1,e2}} a1 (C1 /\&#39; C2) C1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  (Lambda <span class="nl">?x</span> <span class="nl">?bx</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> (C1 /\&#39; C2 -&gt;&#39; C1)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{e1, e2}} \<span class="bp">by</span> a1 \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka0"><span class="nb">eapply</span> (impl_intro {{e3,e4}} _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> C1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{e1, e2}} \<span class="bp">by</span> a1 \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka1"><span class="nb">eapply</span> (and_elim1 _ _ _ _ C2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{<span class="nl">?bx</span>, <span class="nl">?e2</span>}} \<span class="bp">by</span> a1 \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{e1, e2}} \<span class="bp">by</span> a1 \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka2"><span class="nb">eapply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> C1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> C2</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{e1, e2}} \<span class="bp">by</span> a1 \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka3"><span class="nb">eapply</span> (assume _e3_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> C2</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{e1, e2}} \<span class="bp">by</span> a1 \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka4"><span class="nb">eapply</span> (assume _e4_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{e1, e2}} \<span class="bp">by</span> a1 \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka5"><span class="nb">eapply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e1 \<span class="bp">by</span> a1 \<span class="kr">in</span> C1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e2 \<span class="bp">by</span> a1 \<span class="kr">in</span> C2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka6"><span class="nb">eapply</span> (assume).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e2 \<span class="bp">by</span> a1 \<span class="kr">in</span> C2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka7"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">matchingFormat {{e3, e4}} {{e1, e2}} = true</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda {{e3, e4}} (AtomicEvid _e3_) =
true</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda {{e3, e4}} (AtomicEvid _e3_) =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka8"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree impl_intro_elim2).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{3}^{a_{1}} \in C_{1} \vdash_{} e_{3}^{a_{1}} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{4}^{a_{1}} \in C_{2} \vdash_{} e_{4}^{a_{1}} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e_{3}^{a_{1}} \in C_{1}, e_{4}^{a_{1}} \in C_{2} \vdash_{} (e_{3}, e_{4})^{a_{1}} \in (C_{1} \wedge C_{2}) $} \RightLabel{ $ \land^{-1} $} \UnaryInfC{$ e_{3}^{a_{1}} \in C_{1}, e_{4}^{a_{1}} \in C_{2} \vdash_{} e_{3}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ e_{3}^{a_{1}} \in C_{1}, e_{4}^{a_{1}} \in C_{2} \vdash_{} \lambda((e_{3}, e_{4}))(e_{3})^{a_{1}} \in ((C_{1} \wedge C_{2}) \rightarrow C_{1}) $}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{} e_{2}^{a_{1}} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e_{1}^{a_{1}} \in C_{1}, e_{2}^{a_{1}} \in C_{2} \vdash_{} (e_{1}, e_{2})^{a_{1}} \in (C_{1} \wedge C_{2}) $} \RightLabel{ $ \rightarrow^{-} $} \BinaryInfC{$ e_{3}^{a_{1}} \in C_{1}, e_{4}^{a_{1}} \in C_{2}, e_{1}^{a_{1}} \in C_{1}, e_{2}^{a_{1}} \in C_{2} \vdash_{} e_{1}^{a_{1}} \in C_{1} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka9"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage impl_intro_elim2).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $e_{3}$ which actor 1 uses, claim 2 is supported by $e_{4}$ which actor 1 uses, claim 1 is supported by $e_{1}$ which actor 1 uses, and claim 2 is supported by $e_{2}$ which actor 1 uses then claim 1 is supported by $e_{1}$ which actor 1 uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $e_{3}$ which actor 1 uses, and claim 2 is supported by $e_{4}$ which actor 1 uses then ((claim 1 and claim 2) implies claim 1) is supported by $\lambda((e_{3}, e_{4}))(e_{3})$ which actor 1 uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $e_{3}$ which actor 1 uses, and claim 2 is supported by $e_{4}$ which actor 1 uses then claim 1 is supported by $e_{3}$ which actor 1 uses, because</span>
<span class="s2">      - Assuming claim 1 is supported by $e_{3}$ which actor 1 uses, and claim 2 is supported by $e_{4}$ which actor 1 uses then (claim 1 and claim 2) is supported by $(e_{3}, e_{4})$ which actor 1 uses, because</span>
<span class="s2">        - Assuming claim 1 is supported by $e_{3}$ which actor 1 uses then claim 1 is supported by $e_{3}$ which actor 1 uses, because</span>
<span class="s2">        - claim 1 is a veracity claim.</span>
<span class="s2">        - by assumption.</span>
<span class="s2">        - Assuming claim 2 is supported by $e_{4}$ which actor 1 uses then claim 2 is supported by $e_{4}$ which actor 1 uses, because</span>
<span class="s2">        - claim 2 is a veracity claim.</span>
<span class="s2">        - by assumption.</span>
<span class="s2">      - by a logical rule for &#39;and&#39;.</span>
<span class="s2">    - by a logical rule for &#39;and&#39;.</span>
<span class="s2">  - by a logical rule for implication.</span>
<span class="s2">  - Assuming claim 1 is supported by $e_{1}$ which actor 1 uses, and claim 2 is supported by $e_{2}$ which actor 1 uses then (claim 1 and claim 2) is supported by $(e_{1}, e_{2})$ which actor 1 uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $e_{1}$ which actor 1 uses then claim 1 is supported by $e_{1}$ which actor 1 uses, because</span>
<span class="s2">    - claim 1 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">    - Assuming claim 2 is supported by $e_{2}$ which actor 1 uses then claim 2 is supported by $e_{2}$ which actor 1 uses, because</span>
<span class="s2">    - claim 2 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for &#39;and&#39;.</span>
<span class="s2">- by a logical rule for implication.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkaa"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForLogSeq impl_intro_elim2).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that claim 1 is held by actor 1 by the evidence e_{1}</span>
<span class="s2">  - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - Assumptions made:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - claim 1 is held by actor 1 by the evidence $e_{3}$</span>
<span class="s2">      - claim 2 is held by actor 1 by the evidence $e_{4}$</span>
<span class="s2">      - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">      - claim 2 is held by actor 1 by the evidence $e_{2}$</span>
<span class="s2">    - Logical rule used: implication elimination</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - ((claim 1 and claim 2) implies claim 1) is held by actor 1 by the evidence $\lambda((e_{3}, e_{4}))(e_{3})$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by actor 1 by the evidence $e_{3}$</span>
<span class="s2">            - claim 2 is held by actor 1 by the evidence $e_{4}$</span>
<span class="s2">          - Logical rule used: implication introduction</span>
<span class="s2">            - Sub-proof:</span>
<span class="s2">              - claim 1 is held by actor 1 by the evidence $e_{3}$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 1 is held by actor 1 by the evidence $e_{3}$</span>
<span class="s2">                  - claim 2 is held by actor 1 by the evidence $e_{4}$</span>
<span class="s2">                - Logical rule used: and elimination (1)</span>
<span class="s2">                  - Sub-proof:</span>
<span class="s2">                    - (claim 1 and claim 2) is held by actor 1 by the evidence $(e_{3}, e_{4})$</span>
<span class="s2">                      collapsed:: true</span>
<span class="s2">                      - Assumptions made:</span>
<span class="s2">                        collapsed:: true</span>
<span class="s2">                        - claim 1 is held by actor 1 by the evidence $e_{3}$</span>
<span class="s2">                        - claim 2 is held by actor 1 by the evidence $e_{4}$</span>
<span class="s2">                      - Logical rule used: and introduction</span>
<span class="s2">                        - Sub-proofs:</span>
<span class="s2">                          - claim 1 is held by actor 1 by the evidence $e_{3}$</span>
<span class="s2">                            collapsed:: true</span>
<span class="s2">                            - Assumptions made:</span>
<span class="s2">                              collapsed:: true</span>
<span class="s2">                              - claim 1 is held by actor 1 by the evidence $e_{3}$</span>
<span class="s2">                            - Logical rule used: we assume this</span>
<span class="s2">                          - claim 2 is held by actor 1 by the evidence $e_{4}$</span>
<span class="s2">                            collapsed:: true</span>
<span class="s2">                            - Assumptions made:</span>
<span class="s2">                              collapsed:: true</span>
<span class="s2">                              - claim 2 is held by actor 1 by the evidence $e_{4}$</span>
<span class="s2">                            - Logical rule used: we assume this</span>
<span class="s2">        - (claim 1 and claim 2) is held by actor 1 by the evidence $(e_{1}, e_{2})$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">            - claim 2 is held by actor 1 by the evidence $e_{2}$</span>
<span class="s2">          - Logical rule used: and introduction</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">              - claim 2 is held by actor 1 by the evidence $e_{2}$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 2 is held by actor 1 by the evidence $e_{2}$</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{1} = atomic evidence 1</span>
<span class="s2">    - e_{2} = atomic evidence 2</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkab"><span class="kn">Definition</span> <span class="nf">impl_intro2</span> : proofTreeOf_wrapped a1 (Implies c1 (Implies c1 c1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (c1 -&gt;&#39; c1 -&gt;&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkac"><span class="nb">eexists</span>  _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 -&gt;&#39; c1 -&gt;&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkad"><span class="nb">eapply</span> (impl_intro e1 _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 -&gt;&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkae"><span class="nb">eapply</span> (impl_intro e2 _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume _e1_).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkaf"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda e1 (Lambda e2 (AtomicEvid _e1_)) =
true</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda e2 (AtomicEvid _e1_) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb0"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree impl_intro2).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} \lambda(x_{2})(e_{1})^{a_{1}} \in (C_{1} \rightarrow C_{1}) $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda(x_{1})(\lambda(x_{2})(x_{1}))^{a_{1}} \in (C_{1} \rightarrow (C_{1} \rightarrow C_{1})) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb1"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage impl_intro2).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- (claim 1 implies (claim 1 implies claim 1)) is supported by $\lambda(x_{1})(\lambda(x_{2})(x_{1}))$ which actor 1 uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $e_{1}$ which actor 1 uses then (claim 1 implies claim 1) is supported by $\lambda(x_{2})(e_{1})$ which actor 1 uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $e_{1}$ which actor 1 uses then claim 1 is supported by $e_{1}$ which actor 1 uses, because</span>
<span class="s2">    - claim 1 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for implication.</span>
<span class="s2">- by a logical rule for implication.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb2"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForLogSeq impl_intro2).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that (claim 1 implies (claim 1 implies claim 1)) is held by actor 1 by the evidence \lambda(x_{1})(\lambda(x_{2})(x_{1}))</span>
<span class="s2">  - (claim 1 implies (claim 1 implies claim 1)) is held by actor 1 by the evidence $\lambda(x_{1})(\lambda(x_{2})(x_{1}))$</span>
<span class="s2">    - Logical rule used: implication introduction</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - (claim 1 implies claim 1) is held by actor 1 by the evidence $\lambda(x_{2})(e_{1})$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">          - Logical rule used: implication introduction</span>
<span class="s2">            - Sub-proof:</span>
<span class="s2">              - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{1} = atomic evidence 1</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb3"><span class="kn">Definition</span> <span class="nf">impl_and</span> : proofTreeOf_wrapped a1 (Implies c1 (Implies c2 c1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (c1 -&gt;&#39; c2 -&gt;&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb4"><span class="nb">eexists</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 -&gt;&#39; c2 -&gt;&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb5"><span class="nb">eapply</span> (impl_intro e1 _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c2 -&gt;&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb6"><span class="nb">eapply</span> (impl_intro e2 _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume _e1_).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb7"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda e1 (Lambda e2 (AtomicEvid _e1_)) =
true</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda e2 (AtomicEvid _e1_) = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="kp">try</span> <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb8"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree impl_and).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} \lambda(x_{2})(e_{1})^{a_{1}} \in (C_{2} \rightarrow C_{1}) $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda(x_{1})(\lambda(x_{2})(x_{1}))^{a_{1}} \in (C_{1} \rightarrow (C_{2} \rightarrow C_{1})) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb9"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage impl_and).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- (claim 1 implies (claim 2 implies claim 1)) is supported by $\lambda(x_{1})(\lambda(x_{2})(x_{1}))$ which actor 1 uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $e_{1}$ which actor 1 uses then (claim 2 implies claim 1) is supported by $\lambda(x_{2})(e_{1})$ which actor 1 uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $e_{1}$ which actor 1 uses then claim 1 is supported by $e_{1}$ which actor 1 uses, because</span>
<span class="s2">    - claim 1 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for implication.</span>
<span class="s2">- by a logical rule for implication.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkba"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForLogSeq impl_and).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that (claim 1 implies (claim 2 implies claim 1)) is held by actor 1 by the evidence \lambda(x_{1})(\lambda(x_{2})(x_{1}))</span>
<span class="s2">  - (claim 1 implies (claim 2 implies claim 1)) is held by actor 1 by the evidence $\lambda(x_{1})(\lambda(x_{2})(x_{1}))$</span>
<span class="s2">    - Logical rule used: implication introduction</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - (claim 2 implies claim 1) is held by actor 1 by the evidence $\lambda(x_{2})(e_{1})$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">          - Logical rule used: implication introduction</span>
<span class="s2">            - Sub-proof:</span>
<span class="s2">              - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{1} = atomic evidence 1</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkbb"><span class="kn">Definition</span> <span class="nf">and_example</span> : proofTreeOf_wrapped a1 (Implies c1 (c1 /\&#39; c1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (c1 -&gt;&#39; c1 /\&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkbc"><span class="nb">eexists</span>  _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 -&gt;&#39; c1 /\&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkbd"><span class="nb">eapply</span> (impl_intro e1 _ _ _ _ _ ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 /\&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkbe"><span class="nb">eapply</span> (and_intro).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkbf"><span class="nb">eapply</span> (assume _e1_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume _e1_).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc0"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda e1
  {{AtomicEvid _e1_, AtomicEvid _e1_}} = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc1"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree and_example).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} (e_{1}, e_{1})^{a_{1}} \in (C_{1} \wedge C_{1}) $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda(x_{1})((x_{1}, x_{1}))^{a_{1}} \in (C_{1} \rightarrow (C_{1} \wedge C_{1})) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc2"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage and_example).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- (claim 1 implies (claim 1 and claim 1)) is supported by $\lambda(x_{1})((x_{1}, x_{1}))$ which actor 1 uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $e_{1}$ which actor 1 uses then (claim 1 and claim 1) is supported by $(e_{1}, e_{1})$ which actor 1 uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $e_{1}$ which actor 1 uses then claim 1 is supported by $e_{1}$ which actor 1 uses, because</span>
<span class="s2">    - claim 1 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">    - Assuming claim 1 is supported by $e_{1}$ which actor 1 uses then claim 1 is supported by $e_{1}$ which actor 1 uses, because</span>
<span class="s2">    - claim 1 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for &#39;and&#39;.</span>
<span class="s2">- by a logical rule for implication.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc3"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForLogSeq and_example).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that (claim 1 implies (claim 1 and claim 1)) is held by actor 1 by the evidence \lambda(x_{1})((x_{1}, x_{1}))</span>
<span class="s2">  - (claim 1 implies (claim 1 and claim 1)) is held by actor 1 by the evidence $\lambda(x_{1})((x_{1}, x_{1}))$</span>
<span class="s2">    - Logical rule used: implication introduction</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - (claim 1 and claim 1) is held by actor 1 by the evidence $(e_{1}, e_{1})$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">          - Logical rule used: and introduction</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">              - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 1 is held by actor 1 by the evidence $e_{1}$</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e_{1} = atomic evidence 1</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc4"><span class="kn">Program Definition</span> <span class="nf">concreteProofTreeExampleWith2Conjuncts</span> : 
proofTreeOf ({{l, s}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc5"><span class="nb">apply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf l \<span class="bp">by</span> P \<span class="kr">in</span> C1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf s \<span class="bp">by</span> P \<span class="kr">in</span> C2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc6"><span class="nb">apply</span> assume.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf s \<span class="bp">by</span> P \<span class="kr">in</span> C2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> assume.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc7"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith2Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in (C_{1} \wedge C_{2}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc8"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith2Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $l$ which Penelope uses, and claim 2 is supported by $s$ which Penelope uses then (claim 1 and claim 2) is supported by $(l, s)$ which Penelope uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $l$ which Penelope uses then claim 1 is supported by $l$ which Penelope uses, because</span>
<span class="s2">  - claim 1 is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">  - Assuming claim 2 is supported by $s$ which Penelope uses then claim 2 is supported by $s$ which Penelope uses, because</span>
<span class="s2">  - claim 2 is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">- by a logical rule for &#39;and&#39;.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc9"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith2Conjuncts.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that (claim 1 and claim 2) is held by Penelope by the evidence (l, s)</span>
<span class="s2">  - (claim 1 and claim 2) is held by Penelope by the evidence $(l, s)$</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - Assumptions made:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">      - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">    - Logical rule used: and introduction</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">        - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - l = atomic evidence l</span>
<span class="s2">    - s = atomic evidence s</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkca"><span class="kn">Program Definition</span> <span class="nf">concreteProofTreeExampleWith3Conjuncts</span> : 
proofTreeOf ({{{{l, s}},c}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkcb"><span class="nb">apply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkcc"><span class="nb">apply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf l \<span class="bp">by</span> P \<span class="kr">in</span> C1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf s \<span class="bp">by</span> P \<span class="kr">in</span> C2</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkcd"><span class="nb">apply</span> (assume _l_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf s \<span class="bp">by</span> P \<span class="kr">in</span> C2</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkce"><span class="nb">apply</span> (assume _s_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume _c_).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkcf"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith3Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in (C_{1} \wedge C_{2}) $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd0"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith3Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Penelope uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $l$ which Penelope uses, and claim 2 is supported by $s$ which Penelope uses then (claim 1 and claim 2) is supported by $(l, s)$ which Penelope uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $l$ which Penelope uses then claim 1 is supported by $l$ which Penelope uses, because</span>
<span class="s2">    - claim 1 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">    - Assuming claim 2 is supported by $s$ which Penelope uses then claim 2 is supported by $s$ which Penelope uses, because</span>
<span class="s2">    - claim 2 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for &#39;and&#39;.</span>
<span class="s2">  - Assuming claim 3 is supported by $c$ which Penelope uses then claim 3 is supported by $c$ which Penelope uses, because</span>
<span class="s2">  - claim 3 is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">- by a logical rule for &#39;and&#39;.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd1"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith3Conjuncts.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that ((claim 1 and claim 2) and claim 3) is held by Penelope by the evidence ((l, s), c)</span>
<span class="s2">  - ((claim 1 and claim 2) and claim 3) is held by Penelope by the evidence $((l, s), c)$</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - Assumptions made:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">      - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">      - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">    - Logical rule used: and introduction</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - (claim 1 and claim 2) is held by Penelope by the evidence $(l, s)$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">            - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">          - Logical rule used: and introduction</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">              - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">        - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - l = atomic evidence l</span>
<span class="s2">    - s = atomic evidence s</span>
<span class="s2">    - c = atomic evidence c</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small></span></pre><p>We can also combine existing trees into new trees, when appropriate. For example:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd2"><span class="kn">Program Definition</span> <span class="nf">concreteProofTreeExampleWith3ConjunctsUsingExistingTree</span> : 
proofTreeOf {{{{l, s}},c}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd3"><span class="nb">apply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd4"><span class="bp">exact</span> concreteProofTreeExampleWith2Conjuncts.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd5"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(and_intro {{l, s}} c P (C1 /\&#39; C2) C3
   concreteProofTreeExampleWith2Conjuncts <span class="nl">?Goal</span>)</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume _c_).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd6"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith3Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in (C_{1} \wedge C_{2}) $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd7"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith3Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Penelope uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $l$ which Penelope uses, and claim 2 is supported by $s$ which Penelope uses then (claim 1 and claim 2) is supported by $(l, s)$ which Penelope uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $l$ which Penelope uses then claim 1 is supported by $l$ which Penelope uses, because</span>
<span class="s2">    - claim 1 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">    - Assuming claim 2 is supported by $s$ which Penelope uses then claim 2 is supported by $s$ which Penelope uses, because</span>
<span class="s2">    - claim 2 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for &#39;and&#39;.</span>
<span class="s2">  - Assuming claim 3 is supported by $c$ which Penelope uses then claim 3 is supported by $c$ which Penelope uses, because</span>
<span class="s2">  - claim 3 is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">- by a logical rule for &#39;and&#39;.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd8"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith3Conjuncts.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that ((claim 1 and claim 2) and claim 3) is held by Penelope by the evidence ((l, s), c)</span>
<span class="s2">  - ((claim 1 and claim 2) and claim 3) is held by Penelope by the evidence $((l, s), c)$</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - Assumptions made:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">      - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">      - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">    - Logical rule used: and introduction</span>
<span class="s2">      - Sub-proofs:</span>
<span class="s2">        - (claim 1 and claim 2) is held by Penelope by the evidence $(l, s)$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">            - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">          - Logical rule used: and introduction</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">              - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">        - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - l = atomic evidence l</span>
<span class="s2">    - s = atomic evidence s</span>
<span class="s2">    - c = atomic evidence c</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd9"><span class="kn">Program Definition</span> <span class="nf">concreteProofTreeExampleTrust</span> : 
proofTreeOf e \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkda"><span class="nb">eapply</span> (trust _ a1 a2 c1 trustT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e \<span class="bp">by</span> a2 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume _e_).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkdb"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleTrust).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{2}} \in C_{1} \vdash_{} e^{a_{2}} \in C_{1} $} \AxiomC{$a_{1}Ta_{2}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e^{a_{2}} \in C_{1} \vdash_{T} e^{a_{1}} \in C_{1} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkdc"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleTrust).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $e$ which actor 2 uses then claim 1 is supported by $e$ which actor 1 uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $e$ which actor 2 uses then claim 1 is supported by $e$ which actor 2 uses, because</span>
<span class="s2">  - claim 1 is a veracity claim.</span>
<span class="s2">  - by assumption.</span>
<span class="s2">- by the trust relation trust relation T.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkdd"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleTrust.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that claim 1 is held by actor 1 by the evidence e</span>
<span class="s2">  - claim 1 is held by actor 1 by the evidence $e$</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - Assumptions made:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - claim 1 is held by actor 2 by the evidence $e$</span>
<span class="s2">    - Trust relations used:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - trust relation T</span>
<span class="s2">    - Logical rule used: trust, with relation trust relation T</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - claim 1 is held by actor 2 by the evidence $e$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by actor 2 by the evidence $e$</span>
<span class="s2">          - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e = atomic evidence e</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkde"><span class="kn">Program Definition</span> <span class="nf">concreteProofTreeExampleWith3ConjunctsWithTrust</span> : 
proofTreeOf {{{{l, s}},c}} \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkdf"><span class="nb">eapply</span> (trust _ _ _ _ trustU).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> <span class="nl">?a2</span> \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concreteProofTreeExampleWith3ConjunctsUsingExistingTree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chke0"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith3ConjunctsWithTrust).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in (C_{1} \wedge C_{2}) $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $} \AxiomC{$QUP$}  \RightLabel{ $ trust\ U$} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{U} ((l, s), c)^{Q} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small><span class="alectryon-wsp"> </span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chke1"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith3ConjunctsWithTrust).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Quintin uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Penelope uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $l$ which Penelope uses, and claim 2 is supported by $s$ which Penelope uses then (claim 1 and claim 2) is supported by $(l, s)$ which Penelope uses, because</span>
<span class="s2">      - Assuming claim 1 is supported by $l$ which Penelope uses then claim 1 is supported by $l$ which Penelope uses, because</span>
<span class="s2">      - claim 1 is a veracity claim.</span>
<span class="s2">      - by assumption.</span>
<span class="s2">      - Assuming claim 2 is supported by $s$ which Penelope uses then claim 2 is supported by $s$ which Penelope uses, because</span>
<span class="s2">      - claim 2 is a veracity claim.</span>
<span class="s2">      - by assumption.</span>
<span class="s2">    - by a logical rule for &#39;and&#39;.</span>
<span class="s2">    - Assuming claim 3 is supported by $c$ which Penelope uses then claim 3 is supported by $c$ which Penelope uses, because</span>
<span class="s2">    - claim 3 is a veracity claim.</span>
<span class="s2">    - by assumption.</span>
<span class="s2">  - by a logical rule for &#39;and&#39;.</span>
<span class="s2">- by the trust relation trust relation U.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chke2"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith3ConjunctsWithTrust.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that ((claim 1 and claim 2) and claim 3) is held by Quintin by the evidence ((l, s), c)</span>
<span class="s2">  - ((claim 1 and claim 2) and claim 3) is held by Quintin by the evidence $((l, s), c)$</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - Assumptions made:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">      - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">      - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">    - Trust relations used:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - trust relation U</span>
<span class="s2">    - Logical rule used: trust, with relation trust relation U</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - ((claim 1 and claim 2) and claim 3) is held by Penelope by the evidence $((l, s), c)$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">            - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">            - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          - Logical rule used: and introduction</span>
<span class="s2">            - Sub-proofs:</span>
<span class="s2">              - (claim 1 and claim 2) is held by Penelope by the evidence $(l, s)$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                  - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                - Logical rule used: and introduction</span>
<span class="s2">                  - Sub-proofs:</span>
<span class="s2">                    - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                      collapsed:: true</span>
<span class="s2">                      - Assumptions made:</span>
<span class="s2">                        collapsed:: true</span>
<span class="s2">                        - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                      - Logical rule used: we assume this</span>
<span class="s2">                    - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                      collapsed:: true</span>
<span class="s2">                      - Assumptions made:</span>
<span class="s2">                        collapsed:: true</span>
<span class="s2">                        - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                      - Logical rule used: we assume this</span>
<span class="s2">              - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">                - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - l = atomic evidence l</span>
<span class="s2">    - s = atomic evidence s</span>
<span class="s2">    - c = atomic evidence c</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chke3"><span class="kn">Program Definition</span> <span class="nf">concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras</span> : 
proofTreeOf {{{{l, s}},c}} \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chke4"><span class="nb">eapply</span> (trust _ Q Q _ trustU).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chke5"><span class="nb">eapply</span> (trust _ Q Q _ trustV).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chke6"><span class="nb">eapply</span> (trust _ _ _ _ trustU).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> <span class="nl">?a2</span> \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concreteProofTreeExampleWith3ConjunctsUsingExistingTree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chke7"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(trust {{l, s, c}} Q Q (C1 /\&#39; C2 /\&#39; C3) trustU
   (trust {{l, s, c}} Q Q (C1 /\&#39; C2 /\&#39; C3) trustV
      (trust {{l, s, c}} Q P (C1 /\&#39; C2 /\&#39; C3) trustU
         concreteProofTreeExampleWith3ConjunctsUsingExistingTree)))</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chke8"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in (C_{1} \wedge C_{2}) $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $} \AxiomC{$QUP$}  \RightLabel{ $ trust\ U$} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{U} ((l, s), c)^{Q} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $} \AxiomC{$QVQ$}  \RightLabel{ $ trust\ V$} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{V, U} ((l, s), c)^{Q} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $} \AxiomC{$QUQ$}  \RightLabel{ $ trust\ U$} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{V, U} ((l, s), c)^{Q} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small><span class="alectryon-wsp"> </span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chke9"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Quintin uses, because</span>
<span class="s2">  - Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Quintin uses, because</span>
<span class="s2">    - Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Quintin uses, because</span>
<span class="s2">      - Assuming claim 1 is supported by $l$ which Penelope uses, claim 2 is supported by $s$ which Penelope uses, and claim 3 is supported by $c$ which Penelope uses then ((claim 1 and claim 2) and claim 3) is supported by $((l, s), c)$ which Penelope uses, because</span>
<span class="s2">        - Assuming claim 1 is supported by $l$ which Penelope uses, and claim 2 is supported by $s$ which Penelope uses then (claim 1 and claim 2) is supported by $(l, s)$ which Penelope uses, because</span>
<span class="s2">          - Assuming claim 1 is supported by $l$ which Penelope uses then claim 1 is supported by $l$ which Penelope uses, because</span>
<span class="s2">          - claim 1 is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">          - Assuming claim 2 is supported by $s$ which Penelope uses then claim 2 is supported by $s$ which Penelope uses, because</span>
<span class="s2">          - claim 2 is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">        - by a logical rule for &#39;and&#39;.</span>
<span class="s2">        - Assuming claim 3 is supported by $c$ which Penelope uses then claim 3 is supported by $c$ which Penelope uses, because</span>
<span class="s2">        - claim 3 is a veracity claim.</span>
<span class="s2">        - by assumption.</span>
<span class="s2">      - by a logical rule for &#39;and&#39;.</span>
<span class="s2">    - by the trust relation trust relation U.</span>
<span class="s2">  - by the trust relation trust relation V.</span>
<span class="s2">- by the trust relation trust relation U.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkea"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that ((claim 1 and claim 2) and claim 3) is held by Quintin by the evidence ((l, s), c)</span>
<span class="s2">  - ((claim 1 and claim 2) and claim 3) is held by Quintin by the evidence $((l, s), c)$</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - Assumptions made:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">      - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">      - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">    - Trust relations used:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - trust relation V</span>
<span class="s2">      - trust relation U</span>
<span class="s2">    - Logical rule used: trust, with relation trust relation U</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - ((claim 1 and claim 2) and claim 3) is held by Quintin by the evidence $((l, s), c)$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">            - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">            - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">          - Trust relations used:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - trust relation V</span>
<span class="s2">            - trust relation U</span>
<span class="s2">          - Logical rule used: trust, with relation trust relation V</span>
<span class="s2">            - Sub-proof:</span>
<span class="s2">              - ((claim 1 and claim 2) and claim 3) is held by Quintin by the evidence $((l, s), c)$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                  - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                  - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">                - Trust relations used:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - trust relation U</span>
<span class="s2">                - Logical rule used: trust, with relation trust relation U</span>
<span class="s2">                  - Sub-proof:</span>
<span class="s2">                    - ((claim 1 and claim 2) and claim 3) is held by Penelope by the evidence $((l, s), c)$</span>
<span class="s2">                      collapsed:: true</span>
<span class="s2">                      - Assumptions made:</span>
<span class="s2">                        collapsed:: true</span>
<span class="s2">                        - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                        - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                        - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">                      - Logical rule used: and introduction</span>
<span class="s2">                        - Sub-proofs:</span>
<span class="s2">                          - (claim 1 and claim 2) is held by Penelope by the evidence $(l, s)$</span>
<span class="s2">                            collapsed:: true</span>
<span class="s2">                            - Assumptions made:</span>
<span class="s2">                              collapsed:: true</span>
<span class="s2">                              - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                              - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                            - Logical rule used: and introduction</span>
<span class="s2">                              - Sub-proofs:</span>
<span class="s2">                                - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                                  collapsed:: true</span>
<span class="s2">                                  - Assumptions made:</span>
<span class="s2">                                    collapsed:: true</span>
<span class="s2">                                    - claim 1 is held by Penelope by the evidence $l$</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">                                - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                                  collapsed:: true</span>
<span class="s2">                                  - Assumptions made:</span>
<span class="s2">                                    collapsed:: true</span>
<span class="s2">                                    - claim 2 is held by Penelope by the evidence $s$</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">                          - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">                            collapsed:: true</span>
<span class="s2">                            - Assumptions made:</span>
<span class="s2">                              collapsed:: true</span>
<span class="s2">                              - claim 3 is held by Penelope by the evidence $c$</span>
<span class="s2">                            - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - l = atomic evidence l</span>
<span class="s2">    - s = atomic evidence s</span>
<span class="s2">    - c = atomic evidence c</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkeb"><span class="kn">Definition</span> <span class="nf">exampleWithProofOf</span> : proofTreeOf_wrapped a1 C1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkec"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chked"><span class="nb">eexists</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume _e_ a1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkee"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree exampleWithProofOf.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C_{1} \vdash_{} e^{a_{1}} \in C_{1} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkef"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForNaturalLanguage exampleWithProofOf.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 1 is supported by $e$ which actor 1 uses then claim 1 is supported by $e$ which actor 1 uses, because</span>
<span class="s2">- claim 1 is a veracity claim.</span>
<span class="s2">- by assumption.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkf0"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq exampleWithProofOf.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that claim 1 is held by actor 1 by the evidence e</span>
<span class="s2">  - claim 1 is held by actor 1 by the evidence $e$</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - Assumptions made:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - claim 1 is held by actor 1 by the evidence $e$</span>
<span class="s2">    - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e = atomic evidence e</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkf1"><span class="kn">Definition</span> <span class="nf">usingAll</span> : proofTreeOf_wrapped a1 (C1 \/&#39; (C2 /\&#39; (Implies C4 C4)) \/&#39; C3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1
  (C1 \/&#39; C2 /\&#39; (C4 -&gt;&#39; C4) \/&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkf2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1
  (C1 \/&#39; C2 /\&#39; (C4 -&gt;&#39; C4) \/&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkf3"><span class="nb">eexists</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (C1 \/&#39; C2 /\&#39; (C4 -&gt;&#39; C4) \/&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkf4"><span class="nb">eapply</span> (or_intro1 _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (C1 \/&#39; C2 /\&#39; (C4 -&gt;&#39; C4))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkf5"><span class="nb">eapply</span> (or_intro2 _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (C2 /\&#39; (C4 -&gt;&#39; C4))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkf6"><span class="nb">eapply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> C2</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (C4 -&gt;&#39; C4)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkf7"><span class="nb">apply</span> (assume _e_ a1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (C4 -&gt;&#39; C4)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkf8"><span class="nb">eapply</span> (trust _ _ _ _ trustT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> <span class="nl">?a2</span> \<span class="kr">in</span> (C4 -&gt;&#39; C4)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkf9"><span class="nb">eapply</span> (impl_intro e4 _ a1 C4 C4 _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?bx</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> C4</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume _e4_ a1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkfa"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda e4 (AtomicEvid _e4_) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkfb"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{|
  _e :=
    Left
      (Right
         {{AtomicEvid _e_,
         Lambda e4 (AtomicEvid _e4_)}});
  _p :=
    or_intro1
      (Right
         {{AtomicEvid _e_,
         Lambda e4 (AtomicEvid _e4_)}}) a1
      (C1 \/&#39; C2 /\&#39; (C4 -&gt;&#39; C4)) C3
      (or_intro2
         {{AtomicEvid _e_,
         Lambda e4 (AtomicEvid _e4_)}} a1 C1
         (C2 /\&#39; (C4 -&gt;&#39; C4))
         (and_intro (AtomicEvid _e_)
            (Lambda e4 (AtomicEvid _e4_)) a1 C2
            (C4 -&gt;&#39; C4) (assume _e_ a1 C2)
            (trust (Lambda e4 (AtomicEvid _e4_)) a1 a1
               (C4 -&gt;&#39; C4) trustT
               (impl_intro e4 (AtomicEvid _e4_) a1 C4
                  C4 <span class="nl">?H</span> (assume _e4_ a1 C4)))))
|}</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">notUsedInInnerLambda e4 (AtomicEvid _e4_) = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkfc"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree usingAll.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{} e^{a_{1}} \in C_{2} $}\AxiomC{$ C_{4} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{4}^{a_{1}} \in C_{4} \vdash_{} e_{4}^{a_{1}} \in C_{4} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ \lambda(x_{4})(x_{4})^{a_{1}} \in (C_{4} \rightarrow C_{4}) $} \AxiomC{$a_{1}Ta_{1}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ \lambda(x_{4})(x_{4})^{a_{1}} \in (C_{4} \rightarrow C_{4}) $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{T} (e, \lambda(x_{4})(x_{4}))^{a_{1}} \in (C_{2} \wedge (C_{4} \rightarrow C_{4})) $} \RightLabel{ $ \lor^{+2} $} \UnaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{T} j((e, \lambda(x_{4})(x_{4})))^{a_{1}} \in (C_{1} \vee (C_{2} \wedge (C_{4} \rightarrow C_{4}))) $} \RightLabel{ $ \lor^{+1} $} \UnaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{T} i(j((e, \lambda(x_{4})(x_{4}))))^{a_{1}} \in ((C_{1} \vee (C_{2} \wedge (C_{4} \rightarrow C_{4}))) \vee C_{3}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkfd"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForNaturalLanguage usingAll.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">- Assuming claim 2 is supported by $e$ which actor 1 uses then ((claim 1 or (claim 2 and (claim 4 implies claim 4))) or claim 3) is supported by $i(j((e, \lambda(x_{4})(x_{4}))))$ which actor 1 uses, because</span>
<span class="s2">  - Assuming claim 2 is supported by $e$ which actor 1 uses then (claim 1 or (claim 2 and (claim 4 implies claim 4))) is supported by $j((e, \lambda(x_{4})(x_{4})))$ which actor 1 uses, because</span>
<span class="s2">    - Assuming claim 2 is supported by $e$ which actor 1 uses then (claim 2 and (claim 4 implies claim 4)) is supported by $(e, \lambda(x_{4})(x_{4}))$ which actor 1 uses, because</span>
<span class="s2">      - Assuming claim 2 is supported by $e$ which actor 1 uses then claim 2 is supported by $e$ which actor 1 uses, because</span>
<span class="s2">      - claim 2 is a veracity claim.</span>
<span class="s2">      - by assumption.</span>
<span class="s2">      - (claim 4 implies claim 4) is supported by $\lambda(x_{4})(x_{4})$ which actor 1 uses, because</span>
<span class="s2">        - (claim 4 implies claim 4) is supported by $\lambda(x_{4})(x_{4})$ which actor 1 uses, because</span>
<span class="s2">          - Assuming claim 4 is supported by $e_{4}$ which actor 1 uses then claim 4 is supported by $e_{4}$ which actor 1 uses, because</span>
<span class="s2">          - claim 4 is a veracity claim.</span>
<span class="s2">          - by assumption.</span>
<span class="s2">        - by a logical rule for implication.</span>
<span class="s2">      - by the trust relation trust relation T.</span>
<span class="s2">    - by a logical rule for &#39;and&#39;.</span>
<span class="s2">  - by a logical rule for &#39;or&#39;.</span>
<span class="s2">- by a logical rule for &#39;or&#39;.</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkfe"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq usingAll.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">     = <span class="s2">&quot;</span>

<span class="s2">### Veracity proof that ((claim 1 or (claim 2 and (claim 4 implies claim 4))) or claim 3) is held by actor 1 by the evidence i(j((e, \lambda(x_{4})(x_{4}))))</span>
<span class="s2">  - ((claim 1 or (claim 2 and (claim 4 implies claim 4))) or claim 3) is held by actor 1 by the evidence $i(j((e, \lambda(x_{4})(x_{4}))))$</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - Assumptions made:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - claim 2 is held by actor 1 by the evidence $e$</span>
<span class="s2">    - Trust relations used:</span>
<span class="s2">      collapsed:: true</span>
<span class="s2">      - trust relation T</span>
<span class="s2">    - Logical rule used: or introduction (1)</span>
<span class="s2">      - Sub-proof:</span>
<span class="s2">        - (claim 1 or (claim 2 and (claim 4 implies claim 4))) is held by actor 1 by the evidence $j((e, \lambda(x_{4})(x_{4})))$</span>
<span class="s2">          collapsed:: true</span>
<span class="s2">          - Assumptions made:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - claim 2 is held by actor 1 by the evidence $e$</span>
<span class="s2">          - Trust relations used:</span>
<span class="s2">            collapsed:: true</span>
<span class="s2">            - trust relation T</span>
<span class="s2">          - Logical rule used: or introduction (2)</span>
<span class="s2">            - Sub-proof:</span>
<span class="s2">              - (claim 2 and (claim 4 implies claim 4)) is held by actor 1 by the evidence $(e, \lambda(x_{4})(x_{4}))$</span>
<span class="s2">                collapsed:: true</span>
<span class="s2">                - Assumptions made:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - claim 2 is held by actor 1 by the evidence $e$</span>
<span class="s2">                - Trust relations used:</span>
<span class="s2">                  collapsed:: true</span>
<span class="s2">                  - trust relation T</span>
<span class="s2">                - Logical rule used: and introduction</span>
<span class="s2">                  - Sub-proofs:</span>
<span class="s2">                    - claim 2 is held by actor 1 by the evidence $e$</span>
<span class="s2">                      collapsed:: true</span>
<span class="s2">                      - Assumptions made:</span>
<span class="s2">                        collapsed:: true</span>
<span class="s2">                        - claim 2 is held by actor 1 by the evidence $e$</span>
<span class="s2">                      - Logical rule used: we assume this</span>
<span class="s2">                    - (claim 4 implies claim 4) is held by actor 1 by the evidence $\lambda(x_{4})(x_{4})$</span>
<span class="s2">                      collapsed:: true</span>
<span class="s2">                      - Trust relations used:</span>
<span class="s2">                        collapsed:: true</span>
<span class="s2">                        - trust relation T</span>
<span class="s2">                      - Logical rule used: trust, with relation trust relation T</span>
<span class="s2">                        - Sub-proof:</span>
<span class="s2">                          - (claim 4 implies claim 4) is held by actor 1 by the evidence $\lambda(x_{4})(x_{4})$</span>
<span class="s2">                            - Logical rule used: implication introduction</span>
<span class="s2">                              - Sub-proof:</span>
<span class="s2">                                - claim 4 is held by actor 1 by the evidence $e_{4}$</span>
<span class="s2">                                  collapsed:: true</span>
<span class="s2">                                  - Assumptions made:</span>
<span class="s2">                                    collapsed:: true</span>
<span class="s2">                                    - claim 4 is held by actor 1 by the evidence $e_{4}$</span>
<span class="s2">                                  - Logical rule used: we assume this</span>
<span class="s2">  - Atomic evidence is abbreviated as follows:</span>
<span class="s2">    collapsed:: true</span>
<span class="s2">    - e = atomic evidence e</span>
<span class="s2">    - e_{4} = atomic evidence 4</span>

<span class="s2">&quot;</span>
     : string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">VeracityLogic</span>.</span></span></pre><p><em>The proofs on this page are rendered using MathJax which happens to require at least one explicit math command</em>. Hence: <span class="math">\(x\)</span>.</p>
</div>
</div>
</div></body>
</html>
