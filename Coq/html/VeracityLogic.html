<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Veracity Logic Mechanised in Coq</title>
<script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js?config=TeX-AMS_CHTML"></script>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="veracity-logic-mechanised-in-coq">
<h1 class="title">Veracity Logic Mechanised in Coq</h1>

<p><strong>Note: the commentary is out of date.</strong></p>
<p>This version aims to more closely align with the draft paper.
It also features a LaTeX/MathJax visualisation of completed proofs.</p>
<p>This is possible due to not using <code class="highlight coq"><span class="kt">Prop</span></code> at all. &quot;<em>In fact in my logic there are no propositions</em>&quot; - Steve.
Instead, this aims to model the process of constructing proof trees, just like they are done on paper.</p>
<p>A correct proof tree is a datatype with similarities to a tree datatype, which makes it possible to write a function that prints a proof out.</p>
<p>Coq is useful here because we can construct correct proof trees in &quot;proof mode&quot;. In fact, we are just defining particular proof trees, but it is convenient to use &quot;proof mode&quot;.</p>
<p>Lastly, we use Coq's dependent types to enforce that it's not just any proof tree that we build, but it is a correct proof tree for the given judgement.
The type <code class="highlight coq"><span class="n">proofTreeOf</span></code> depends on the value, <code class="highlight coq"><span class="n">j</span></code>, of type <code class="highlight coq"><span class="n">judgement</span></code> which constrains what a <code class="highlight coq"><span class="n">proofTreeOf</span> <span class="n">j</span></code> is.
This is similar to a type such as <code class="highlight coq"><span class="n">vector</span></code> depending on a value, <code class="highlight coq"><span class="n">n</span></code>, (the vector's length) of type <code class="highlight coq"><span class="n">nat</span></code> which constrains what a <code class="highlight coq"><span class="n">vector</span> <span class="n">n</span></code> is.</p>
<p>Handling a trust relation and weights are future work (2024).</p>
<!-- The following is required to get MathJax to process the outputs marked with the class coq-math. -->
<link rel="stylesheet" href="overrides.css">

<script type="text/javascript">
  document.addEventListener("DOMContentLoaded", () => {
     // 1. Find all relevant Alectryon tags
     var spans = document.querySelectorAll(".coq-math > * > * > * > * > * > .s2, .custom-math");

     // 2. Wrap the contents of each in \(\) math delimiters, add mathjax class
     spans.forEach(function (e) {
         e.innerText = '\\[' + e.innerText + '\\]';
         e.classList.add("mathjax_process");
     });

     // 3. If MathJax has already loaded, force reprocessing
     window.MathJax && MathJax.typesetPromise(spans);
  });
</script>

<style type="text/css"> /* Override MathJax margins */
    .coq-math .goal-conclusion > *,
    .coq-math .hyp-body span > *,
    .coq-math .hyp-type span > * {
        margin: 0 !important;
    }
</style><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> String.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Strings.Ascii.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Bool.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Program.</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">VeracityLogic</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">atomic_evid_name</span> :=
  | _e_
  | _e1_
  | _e2_
  | _e3_
  | _e4_
  | _eB_
  | _eQ_
  | _l_
  | _s_
  | _c_evid_
  | _belief_
  | _testing_
  | _audit_
  | _compile_
  | _review_
  | _assess_
  | _business_procedure_
  | _ingredients_percentage_list_
  | _breakdown_of_formulations_list_
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">atomic_evid_name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">actor_name</span> :=
  | _a1_
  | _a2_
  | _a3_
  | _a4_
  | _aQ_
  | _retailer_
  | _vineyard_
  | _winery_
  | _P_
  | _Q_
  | _applicant_
  | _certifier_
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">actor_name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">claim_name</span> :=
  | _c_
  | _c1_
  | _c2_
  | _c3_
  | _c4_
  | _c5_
  | _cQ_
  | _healthy_
  | _nonToxic_
  | _organic_
  | _ingredients_valid_
  | _ingredients_valid_approved_
  | _recipe_valid_
  | _percentage_ingredients_valid_
  | _breakdown_of_formulations_valid_
  | _successful_market_compliance_assessment_
.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">claim_name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">trust_relation_name</span> :=
  | _T_
  | _U_
  | _V_
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">trust_relation_name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ShowForProofTree</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    showForProofTree : A -&gt; string
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree atomic_evid_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _e_ =&gt; <span class="s2">&quot;e&quot;</span>
      | _e1_ =&gt; <span class="s2">&quot;e_{1}&quot;</span>
      | _e2_ =&gt; <span class="s2">&quot;e_{2}&quot;</span>
      | _e3_ =&gt; <span class="s2">&quot;e_{3}&quot;</span>
      | _e4_ =&gt; <span class="s2">&quot;e_{4}&quot;</span>
      | _eB_  =&gt; <span class="s2">&quot;e_{\bot}&quot;</span>
      | _eQ_ =&gt; <span class="s2">&quot;e_{?}&quot;</span>
      | _l_ =&gt; <span class="s2">&quot;l&quot;</span>
      | _s_ =&gt; <span class="s2">&quot;s&quot;</span>
      | _c_evid_ =&gt; <span class="s2">&quot;c&quot;</span>
      | _belief_ =&gt; <span class="s2">&quot;b&quot;</span>
      | _testing_ =&gt; <span class="s2">&quot;t&quot;</span>
      | _audit_ =&gt; <span class="s2">&quot;a&quot;</span>
      | _compile_=&gt; <span class="s2">&quot;c&quot;</span>
      | _review_=&gt; <span class="s2">&quot;r&quot;</span>
      | _assess_ =&gt; <span class="s2">&quot;a&quot;</span>
      | _business_procedure_ =&gt; <span class="s2">&quot;p&quot;</span>
      | _ingredients_percentage_list_ =&gt; <span class="s2">&quot;e_{PI}&quot;</span>
      | _breakdown_of_formulations_list_=&gt; <span class="s2">&quot;e_{BF}&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree actor_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _a1_ =&gt; <span class="s2">&quot;a_{1}&quot;</span>
      | _a2_ =&gt; <span class="s2">&quot;a_{2}&quot;</span>
      | _a3_ =&gt; <span class="s2">&quot;a_{3}&quot;</span>
      | _a4_ =&gt; <span class="s2">&quot;a_{4}&quot;</span>
      | _aQ_ =&gt; <span class="s2">&quot;a_{?}&quot;</span>
      | _retailer_ =&gt; <span class="s2">&quot;r&quot;</span>
      | _vineyard_ =&gt; <span class="s2">&quot;v&quot;</span>
      | _winery_ =&gt; <span class="s2">&quot;w&quot;</span>
      | _P_ =&gt; <span class="s2">&quot;P&quot;</span>
      | _Q_ =&gt; <span class="s2">&quot;Q&quot;</span>
      | _applicant_ =&gt; <span class="s2">&quot;A&quot;</span>
      | _certifier_ =&gt; <span class="s2">&quot;C&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree claim_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _c_ =&gt; <span class="s2">&quot;C&quot;</span>
      | _c1_ =&gt; <span class="s2">&quot;C_{1}&quot;</span>
      | _c2_ =&gt; <span class="s2">&quot;C_{2}&quot;</span>
      | _c3_ =&gt; <span class="s2">&quot;C_{3}&quot;</span>
      | _c4_ =&gt; <span class="s2">&quot;C_{4}&quot;</span>
      | _c5_ =&gt; <span class="s2">&quot;C_{5}&quot;</span>
      | _cQ_ =&gt; <span class="s2">&quot;C_{?}&quot;</span>
      | _healthy_ =&gt; <span class="s2">&quot;H&quot;</span>
      | _nonToxic_ =&gt; <span class="s2">&quot;N&quot;</span>
      | _organic_ =&gt; <span class="s2">&quot;O&quot;</span>
      | _ingredients_valid_ =&gt; <span class="s2">&quot;\mathit{IV}&quot;</span>
      | _ingredients_valid_approved_ =&gt; <span class="s2">&quot;\mathit{IVA}&quot;</span>
      | _recipe_valid_ =&gt; <span class="s2">&quot;\mathit{RV}&quot;</span>      
      | _percentage_ingredients_valid_ =&gt; <span class="s2">&quot;\mathit{PIV}&quot;</span>
      | _breakdown_of_formulations_valid_ =&gt; <span class="s2">&quot;\mathit{BFV}&quot;</span>
      | _successful_market_compliance_assessment_ =&gt; <span class="s2">&quot;\mathit{SMCA}&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree trust_relation_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _T_ =&gt; <span class="s2">&quot;T&quot;</span>
      | _U_ =&gt; <span class="s2">&quot;U&quot;</span>
      | _V_ =&gt; <span class="s2">&quot;V&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ShowForNaturalLanguage</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    showForNaturalLanguage : A -&gt; string
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">ShowForLogSeq</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    showForLogSeq : A -&gt; string
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage atomic_evid_name := { 
  showForNaturalLanguage n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _e_ =&gt; <span class="s2">&quot;atomic evidence e&quot;</span>
      | _e1_ =&gt; <span class="s2">&quot;atomic evidence 1&quot;</span>
      | _e2_ =&gt; <span class="s2">&quot;atomic evidence 2&quot;</span>
      | _e3_ =&gt; <span class="s2">&quot;atomic evidence 3&quot;</span>
      | _e4_ =&gt; <span class="s2">&quot;atomic evidence 4&quot;</span>
      | _eB_ =&gt;  <span class="s2">&quot;evidence for bottom&quot;</span>
      | _eQ_ =&gt;  <span class="s2">&quot;unknown evidence&quot;</span>
      | _l_ =&gt; <span class="s2">&quot;atomic evidence l&quot;</span>
      | _s_ =&gt; <span class="s2">&quot;atomic evidence s&quot;</span>
      | _c_evid_ =&gt; <span class="s2">&quot;atomic evidence c&quot;</span>
      | _belief_ =&gt; <span class="s2">&quot;belief&quot;</span>
      | _testing_ =&gt; <span class="s2">&quot;testing&quot;</span>
      | _audit_ =&gt; <span class="s2">&quot;audit&quot;</span>
      | _compile_=&gt; <span class="s2">&quot;compile&quot;</span>
      | _review_=&gt; <span class="s2">&quot;review&quot;</span>
      | _assess_ =&gt; <span class="s2">&quot;assess&quot;</span>
      | _business_procedure_ =&gt; <span class="s2">&quot;business procedure&quot;</span>
      | _ingredients_percentage_list_ =&gt; <span class="s2">&quot;ingredients percentage list&quot;</span>
      | _breakdown_of_formulations_list_ =&gt; <span class="s2">&quot;breakdown of formulations list&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq atomic_evid_name := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage actor_name := { 
  showForNaturalLanguage n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _a1_ =&gt; <span class="s2">&quot;actor 1&quot;</span>
      | _a2_ =&gt; <span class="s2">&quot;actor 2&quot;</span>
      | _a3_ =&gt; <span class="s2">&quot;actor 3&quot;</span>
      | _a4_ =&gt; <span class="s2">&quot;actor 4&quot;</span>
      | _aQ_ =&gt; <span class="s2">&quot;unknown actor&quot;</span>
      | _retailer_ =&gt; <span class="s2">&quot;retailer&quot;</span>
      | _vineyard_ =&gt; <span class="s2">&quot;vineyard&quot;</span>
      | _winery_ =&gt; <span class="s2">&quot;winery&quot;</span>
      | _P_ =&gt; <span class="s2">&quot;Penelope&quot;</span>
      | _Q_ =&gt; <span class="s2">&quot;Quintin&quot;</span>
      | _applicant_ =&gt; <span class="s2">&quot;applicant&quot;</span>
      | _certifier_ =&gt; <span class="s2">&quot;certifier&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq actor_name := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage claim_name := { 
  showForNaturalLanguage n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _c_ =&gt; <span class="s2">&quot;claim c&quot;</span>
      | _c1_ =&gt; <span class="s2">&quot;claim 1&quot;</span>
      | _c2_ =&gt; <span class="s2">&quot;claim 2&quot;</span>
      | _c3_ =&gt; <span class="s2">&quot;claim 3&quot;</span>
      | _c4_ =&gt; <span class="s2">&quot;claim 4&quot;</span>
      | _c5_ =&gt; <span class="s2">&quot;claim 5&quot;</span>
      | _cQ_ =&gt; <span class="s2">&quot;unknown claim&quot;</span>
      | _healthy_ =&gt; <span class="s2">&quot;healthy&quot;</span>
      | _nonToxic_ =&gt; <span class="s2">&quot;non-toxic&quot;</span>
      | _organic_ =&gt; <span class="s2">&quot;organic&quot;</span>
      | _ingredients_valid_ =&gt; <span class="s2">&quot;ingredients-valid&quot;</span>
      | _ingredients_valid_approved_ =&gt; <span class="s2">&quot;ingredients-valid-approved&quot;</span>
      | _recipe_valid_ =&gt; <span class="s2">&quot;recipe-valid&quot;</span>      
      | _percentage_ingredients_valid_ =&gt; <span class="s2">&quot;percentage-ingredients-valid&quot;</span>
      | _breakdown_of_formulations_valid_ =&gt; <span class="s2">&quot;breakdown-of-formulations-valid&quot;</span>
      | _successful_market_compliance_assessment_ =&gt; <span class="s2">&quot;successful-market-compliance-assessment&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq claim_name := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage trust_relation_name := { 
  showForNaturalLanguage n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _T_ =&gt; <span class="s2">&quot;trust relation T&quot;</span>
      | _U_ =&gt; <span class="s2">&quot;trust relation U&quot;</span>
      | _V_ =&gt; <span class="s2">&quot;trust relation V&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq trust_relation_name := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">claim</span> :=
  | AtomicClaim (n : claim_name)
  | Bottom
  | And (c1 c2 : claim)
  | Or  (c1 c2 : claim)
  | Implies  (c1 c2 : claim).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">claim</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">function_name</span> :=
  | _f_
  | _g_
  | _h_
    | _u_
  | _v_
  | _w_
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree function_name := { 
  showForProofTree n := 
    <span class="kr">match</span> n <span class="kr">with</span>
      | _f_ =&gt; <span class="s2">&quot;f&quot;</span>
      | _g_ =&gt; <span class="s2">&quot;g&quot;</span>
      | _h_ =&gt; <span class="s2">&quot;h&quot;</span>
      | _u_ =&gt; <span class="s2">&quot;u&quot;</span>
      | _v_ =&gt; <span class="s2">&quot;v&quot;</span>
      | _w_ =&gt; <span class="s2">&quot;w&quot;</span>
    <span class="kr">end</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">function_name</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">evid</span> :=
  | AtomicEvid (n : atomic_evid_name)
  | BotEvid
  | BotEvidApplied (e1 : evid)
  | Pair (e1 e2: evid)
  | Left (e1 : evid)
  | Right (e1 : evid)
  | Lambda (n : function_name) (e1 e2 : evid) (c1 c2 : claim)
  | Apply (n : function_name) (e1 : evid)
  | Cases (c : evid) (d e : function_name).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">evid</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">actor</span> :=
  | Actor (n : actor_name).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">actor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">trustRelation</span> :=
  | Trust (n : trust_relation_name).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">trustRelation</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">judgement</span> :=
  Judgement (e : evid) (a : actor) (c: claim).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">judgement</span>.</span></span></pre><p>Judgements are a list of <strong>single</strong> judgements entailing some single judgement, or state that some claim <code class="highlight coq"><span class="n">c</span></code> is a veracity claim.</p>
<p>Next, we introduce some notation for Coq.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;E \by A \in C&quot;</span> := (Judgement E A C) (<span class="kn">at level</span> <span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;/\&#39;&quot;</span> := And (<span class="kn">at level</span> <span class="mi">81</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;\/&#39;&quot;</span> := Or (<span class="kn">at level</span> <span class="mi">86</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;_|_&quot;</span> := (Bottom) (<span class="kn">at level</span> <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;{{ x , y , .. , z }}&quot;</span> := (Pair .. (Pair x y) .. z).</span></span></pre><p>We define a tagged type representing a trust relation.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Beq</span> <span class="nv">A</span> : <span class="kt">Type</span> :=
  {
    beq : A -&gt; A -&gt; bool
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk0"><span class="kn">Infix</span> <span class="s2">&quot;=?&quot;</span> := beq : beq_scope.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Declaring a scope implicitly <span class="kr">is</span> deprecated; use <span class="kr">in</span>
advance an explicit <span class="s2">&quot;Declare Scope beq_scope.&quot;</span>.
[undeclared-scope,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq atomic_evid_name := { beq := atomic_evid_name_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq actor_name := { beq := actor_name_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq claim_name := { beq := claim_name_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq trust_relation_name := { beq := trust_relation_name_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq evid := { beq := evid_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq claim := { beq := claim_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq actor := { beq := actor_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq trustRelation := { beq := trustRelation_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq judgement := { beq := judgement_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq function_name := { beq := function_name_beq }.</span></span></pre><p>For now, I have only implemented one inference rule, <code class="highlight coq"><span class="n">and_intro</span></code>, as well as the <code class="highlight coq"><span class="n">assume</span></code> rule and a rule <code class="highlight coq"><span class="n">leaf</span></code> that declares that it is correct for a proof tree to stop on a statement such as <span class="math">\(C_1 \textit{ is a claim}\)</span>.</p>
<p><code class="highlight coq"><span class="n">proofTreeOf</span></code> is a data type, a tree, which depends on a judgement. The type <code class="highlight coq"><span class="n">tree</span> <span class="n">j</span></code> describes a tree which correctly proves <code class="highlight coq"><span class="n">j</span></code>.</p>
<p>But this is not a proposition. This is best thought of as the datatype for (correct) proof trees.</p>
<p>The remaining rules will be easy to add, this will be done in 2024.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">definedFDef</span> :=
  DF : function_name -&gt; evid -&gt; evid -&gt; claim -&gt; claim -&gt; definedFDef.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Scheme Equality for</span> <span class="nf">definedFDef</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : Beq definedFDef := { beq := definedFDef_beq }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eqFunction</span> <span class="nv">d</span> <span class="nv">d&#39;</span> :=
  <span class="kr">match</span> d,d&#39; <span class="kr">with</span>
  DF n _ _ _ _,DF n&#39; _ _ _ _ =&gt; (n =? n&#39;)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eqTypes</span> <span class="nv">d</span> <span class="nv">d&#39;</span> :=
  <span class="kr">match</span> d,d&#39; <span class="kr">with</span>
  DF _ _ _ C1 C2,DF _ _ _ C1&#39; C2&#39; =&gt; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">contains</span> (<span class="nv">x</span> : definedFDef) (<span class="nv">l</span> : list definedFDef) : bool :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; false
  | h :: tl =&gt; (x =? h) || contains x tl
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">containsMatchingEvidArgument</span> (<span class="nv">x</span> : definedFDef) (<span class="nv">l</span> : list definedFDef) : bool :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; false
  | h :: tl =&gt;
    <span class="kr">match</span> x,h <span class="kr">with</span>
    | DF n e _ _ _,DF n&#39; e&#39; _ _ _ =&gt; (n =? n&#39;) &amp;&amp; (e =? e&#39;) || containsMatchingEvidArgument x tl
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">removeDups</span> {<span class="nv">A</span>} `{Beq A} (l : list A) : list A :=
    <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; []
    | h :: tl =&gt; <span class="kr">if</span> existsb (beq h) tl <span class="kr">then</span> removeDups tl <span class="kr">else</span> h :: removeDups tl
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">inconsitentTypes</span> (<span class="nv">l</span> : list definedFDef) : list definedFDef :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; []
  | h :: tl =&gt; removeDups (filter (<span class="kr">fun</span> <span class="nv">d&#39;</span> =&gt; negb (eqTypes h d&#39;)) (filter (eqFunction h) l) ++ inconsitentTypes tl)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">containsMatchingType</span> (<span class="nv">x</span> : definedFDef) (<span class="nv">l</span> : list definedFDef) : bool :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; false
  | h :: tl =&gt;
    <span class="kr">match</span> x,h <span class="kr">with</span>
    | DF n _ _ C1 C2,DF n&#39; _ _ C1&#39; C2&#39; =&gt; (n =? n&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) || containsMatchingType x tl
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">keepOnlyDuplicates_helper</span> (<span class="nv">l</span> : list definedFDef) (<span class="nv">seenOnce</span> : list definedFDef) (<span class="nv">seenMultiple</span> : list definedFDef) : list definedFDef :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; seenMultiple
  | h :: tl =&gt; <span class="kr">if</span> containsMatchingEvidArgument h seenOnce <span class="kr">then</span> keepOnlyDuplicates_helper tl seenOnce (h :: seenMultiple)
          <span class="kr">else</span> keepOnlyDuplicates_helper tl (h :: seenOnce) seenMultiple
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">keepOnlyDuplicates</span> <span class="nv">l</span> := keepOnlyDuplicates_helper l [] [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">proofTreeOf</span> {<span class="nv">fDef</span> : (list definedFDef)} {<span class="nv">HFDefValid</span> : (keepOnlyDuplicates fDef) ++ (inconsitentTypes fDef) = []} : judgement -&gt; <span class="kt">Type</span> :=
| assume e a c : proofTreeOf (e \<span class="bp">by</span> a \<span class="kr">in</span> c)
| bot_elim e a C

        (M : proofTreeOf (e \<span class="bp">by</span> a \<span class="kr">in</span> _|_))
                           :
             proofTreeOf ((BotEvidApplied e) \<span class="bp">by</span> a \<span class="kr">in</span> C)

| and_intro e1 e2 a C1 C2

(L: proofTreeOf (e1 \<span class="bp">by</span> a \<span class="kr">in</span> C1))
                           (R: proofTreeOf (e2 \<span class="bp">by</span> a \<span class="kr">in</span> C2))
                        :
    proofTreeOf ({{e1, e2}} \<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2))

| and_elim1 e1 e2 a C1 C2

    (M : proofTreeOf ({{e1, e2}} \<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2)))
                           :
             proofTreeOf (e1 \<span class="bp">by</span> a \<span class="kr">in</span> C1)

| and_elim2 e1 e2 a C1 C2

    (M : proofTreeOf ({{e1, e2}} \<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2)))
                          :
        proofTreeOf (e2 \<span class="bp">by</span> a \<span class="kr">in</span> C2)

| or_intro1 e1 a C1 C2

           (M: proofTreeOf (e1 \<span class="bp">by</span> a \<span class="kr">in</span> C1))
                          :
    proofTreeOf ((Left e1) \<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2))

| or_intro2 e2 a C1 C2

           (M: proofTreeOf (e2 \<span class="bp">by</span> a \<span class="kr">in</span> C2))
                          :
    proofTreeOf ((Right e2) \<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2))

| or_elim1 e1 a C1 C2

      (M: proofTreeOf ((Left e1) \<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2)))
                          :
        proofTreeOf (e1 \<span class="bp">by</span> a \<span class="kr">in</span> C1)

| or_elim2 e2 a C1 C2

      (M : proofTreeOf ((Right e2) \<span class="bp">by</span> a \<span class="kr">in</span> (C1 \/&#39; C2)))
                            :
          proofTreeOf (e2 \<span class="bp">by</span> a \<span class="kr">in</span> C2)

| or_elim3 c A B x d C y e a
      (H1 : proofTreeOf (c \<span class="bp">by</span> a \<span class="kr">in</span> (A \/&#39; B)))
      (H2 : proofTreeOf (Apply d x) \<span class="bp">by</span> a \<span class="kr">in</span> C)
      (H3 : proofTreeOf (Apply e y) \<span class="bp">by</span> a \<span class="kr">in</span> C)
                      :
          proofTreeOf ((Cases c d e) \<span class="bp">by</span> a \<span class="kr">in</span> C)

| trust e a1 a2 C (name : trustRelation)

(L: proofTreeOf (e \<span class="bp">by</span> a2 \<span class="kr">in</span> C))
                          :
            proofTreeOf (e \<span class="bp">by</span> a1 \<span class="kr">in</span> C)

| impl_intro (e1 : evid) e2 a (C1 : claim) C2 n
             (H : contains (DF n e1 e2 C1 C2) fDef = true)

              (M: proofTreeOf (e2 \<span class="bp">by</span> a \<span class="kr">in</span> C2))
                              :
   proofTreeOf ((Lambda n e1 e2 C1 C2) \<span class="bp">by</span> a \<span class="kr">in</span> (Implies C1 C2))

| impl_elim e1 e2 a C1 C2 n
             (H : contains (DF n e1 e2 C1 C2) fDef = true)

(L: proofTreeOf ((Lambda n e1 e2 C1 C2) \<span class="bp">by</span> a \<span class="kr">in</span> (Implies C1 C2)))
                           (R: proofTreeOf (e1 \<span class="bp">by</span> a \<span class="kr">in</span> C1))
                        :
    proofTreeOf ((Apply n e1) \<span class="bp">by</span> a \<span class="kr">in</span> C2)

| by_def1 e1 e2 a n C1 C2 
             (H : contains (DF n e1 e2 C1 C2) fDef = true)

     (H1 : proofTreeOf ((Lambda n e1 e2 C1 C2) \<span class="bp">by</span> a \<span class="kr">in</span> (Implies C1 C2)))
           (M : proofTreeOf (e2 \<span class="bp">by</span> a \<span class="kr">in</span> C2))
                  :
            proofTreeOf ((Apply n e1) \<span class="bp">by</span> a \<span class="kr">in</span> C2)
| by_def2 e1 e2 a n C1 C2 
               (H : contains (DF n e1 e2 C1 C2) fDef = true)

       (H1 : proofTreeOf ((Lambda n e1 e2 C1 C2) \<span class="bp">by</span> a \<span class="kr">in</span> (Implies C1 C2)))
     (M : proofTreeOf ((Apply n e1) \<span class="bp">by</span> a \<span class="kr">in</span> C2))
                  :
            proofTreeOf (e2 \<span class="bp">by</span> a \<span class="kr">in</span> C2)
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e</span> := AtomicEvid _e_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C</span> := AtomicClaim _c_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e1</span> := AtomicEvid _e1_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a1</span> := Actor _a1_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c1</span> := AtomicClaim _c1_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e2</span> := AtomicEvid _e2_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a2</span> := Actor  _a2_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c2</span> := AtomicClaim _c2_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e3</span> := AtomicEvid _e3_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a3</span> := Actor _a3_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c3</span> := AtomicClaim _c3_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">e4</span> := AtomicEvid  _e4_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">a4</span> := Actor _a4_ .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c4</span> := AtomicClaim _c4_.</span></span></pre><p>This is the <code class="highlight coq"><span class="n">and_intro</span></code> rule as Coq sees it:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1"><span class="kn">Check</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">and_intro
     : <span class="kr">forall</span> (<span class="nv">e1</span> <span class="nv">e2</span> : evid) (<span class="nv">a</span> : actor)
         (<span class="nv">C1</span> <span class="nv">C2</span> : claim),
       proofTreeOf e1 \<span class="bp">by</span> a \<span class="kr">in</span> C1 -&gt;
       proofTreeOf e2 \<span class="bp">by</span> a \<span class="kr">in</span> C2 -&gt;
       proofTreeOf {{e1, e2}} \<span class="bp">by</span> a \<span class="kr">in</span> (C1 /\&#39; C2)
<span class="kn">where</span>
<span class="nl">?fDef</span> : [ |- list definedFDef]
<span class="nl">?HFDefValid</span> : [
              |- keepOnlyDuplicates <span class="nl">?fDef</span> ++
                 inconsitentTypes <span class="nl">?fDef</span> = []]</blockquote></div></div></small></span></pre><!-- For some reason, math:: directives cause prooftree to crash. The following is an alternative that works. -->
<p>Here is a <em>manual</em> translation of the above rule into Latex.</p>
<pre class="code custom-math literal-block">
\begin{prooftree}
\AxiomC{$Ps \vdash e_1^a \in C_1 \quad Ps \vdash e_2^a \in C_2$}
\RightLabel{ $and\_intro$}
\UnaryInfC{$Ps ++ Qs \vdash (e_1, e_2)^a \in (C_1 \wedge C_2)$}
\end{prooftree}
</pre>
<div class="section" id="example-actors-evidence-claims-and-judgements">
<h1>Example actors, evidence, claims and judgements</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string.</span></span></pre><p>We can also assume arbitrary evidence/claims exist. This currently doesn't work well with printing to Latex. An experimental alternative is demonstrated in the experimental-NamedC-and-NamedE branch.</p>
<p>Example Single judgements:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sj1</span> := e1 \<span class="bp">by</span> a1 \<span class="kr">in</span> c1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sj3</span> := e3 \<span class="bp">by</span> a3 \<span class="kr">in</span> c3.</span></span></pre><p>Example Judgments:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">j1</span> := e2 \<span class="bp">by</span> a2 \<span class="kr">in</span> c2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">j2</span> := e4 \<span class="bp">by</span> a4 \<span class="kr">in</span> c4.</span></span></pre><p>Example use of notation:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2"><span class="kn">Check</span> e1 \<span class="bp">by</span> a1 \<span class="kr">in</span> c1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">e1 \<span class="bp">by</span> a1 \<span class="kr">in</span> c1
     : judgement</blockquote></div></div></small></span></pre><p>For each datatype defined earlier, we define a string representation of it.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree evid := {
  showForProofTree :=
  <span class="kr">fix</span> showForProofTreeEvid e :=
      <span class="kr">match</span> e <span class="kr">with</span>
      | AtomicEvid name =&gt; showForProofTree name
      | Pair e1 e2 =&gt; <span class="s2">&quot;(&quot;</span> ++ (showForProofTreeEvid e1) ++ <span class="s2">&quot;, &quot;</span>
                          ++ (showForProofTreeEvid e2) ++ <span class="s2">&quot;)&quot;</span>
      | Left e =&gt; <span class="s2">&quot;i(&quot;</span> ++ showForProofTreeEvid e ++ <span class="s2">&quot;)&quot;</span>
      | Right e =&gt; <span class="s2">&quot;j(&quot;</span> ++ showForProofTreeEvid e ++ <span class="s2">&quot;)&quot;</span>
      | Lambda f e1 e2 _ _ =&gt; <span class="s2">&quot;(\lambda &quot;</span> ++ showForProofTree f ++ <span class="s2">&quot;)&quot;</span>
      | Apply f e1 =&gt; showForProofTree f ++ <span class="s2">&quot;(&quot;</span> ++ showForProofTreeEvid e1 ++ <span class="s2">&quot;)&quot;</span>
      | Cases c d e =&gt; <span class="s2">&quot;cases(&quot;</span> ++ showForProofTreeEvid c ++ <span class="s2">&quot;,  &quot;</span> ++ showForProofTree d ++ <span class="s2">&quot;, &quot;</span> ++ showForProofTree e ++ <span class="s2">&quot;)&quot;</span>
      | BotEvid =&gt; <span class="s2">&quot;e_{\bot}&quot;</span>
      | BotEvidApplied e =&gt; <span class="s2">&quot;R_{0}(&quot;</span> ++ showForProofTreeEvid e ++ <span class="s2">&quot;)&quot;</span>
    <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage evid := { showForNaturalLanguage := showForProofTree }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq evid := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree claim := {
  showForProofTree :=
  <span class="kr">fix</span> showForProofTreeClaim c :=
    <span class="kr">match</span> c <span class="kr">with</span>
      | AtomicClaim name =&gt; showForProofTree name
      | Bottom =&gt; <span class="s2">&quot;\bot&quot;</span>
      | And c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForProofTreeClaim c1 ++ <span class="s2">&quot; \wedge &quot;</span> ++ showForProofTreeClaim c2 ++ <span class="s2">&quot;)&quot;</span>
      | Or c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForProofTreeClaim c1 ++ <span class="s2">&quot; \vee &quot;</span> ++ showForProofTreeClaim c2 ++ <span class="s2">&quot;)&quot;</span>
      | Implies c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForProofTreeClaim c1 ++ <span class="s2">&quot; \rightarrow &quot;</span> ++ showForProofTreeClaim c2 ++ <span class="s2">&quot;)&quot;</span>
    <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage claim := {
  showForNaturalLanguage :=
  <span class="kr">fix</span> showForNaturalLanguageClaim c :=
    <span class="kr">match</span> c <span class="kr">with</span>
      | AtomicClaim name =&gt; showForNaturalLanguage name
      | Bottom =&gt; <span class="s2">&quot;impossible&quot;</span>
      | And c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForNaturalLanguageClaim c1 ++ <span class="s2">&quot; and &quot;</span> ++ showForNaturalLanguageClaim c2  ++ <span class="s2">&quot;)&quot;</span>
      | Or c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForNaturalLanguageClaim c1 ++ <span class="s2">&quot; or &quot;</span> ++ showForNaturalLanguageClaim c2 ++ <span class="s2">&quot;)&quot;</span>
      | Implies c1 c2 =&gt; <span class="s2">&quot;(&quot;</span> ++ showForNaturalLanguageClaim c1 ++ <span class="s2">&quot; implies &quot;</span> ++ showForNaturalLanguageClaim c2 ++ <span class="s2">&quot;)&quot;</span>
    <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq claim := {showForLogSeq := showForNaturalLanguage}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree actor := {
  showForProofTree a :=
  <span class="kr">match</span> a <span class="kr">with</span>
    | Actor name =&gt; showForProofTree name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage actor := {
  showForNaturalLanguage a :=
  <span class="kr">match</span> a <span class="kr">with</span>
    | Actor name =&gt; showForNaturalLanguage name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq actor := {
  showForLogSeq a :=
  <span class="kr">match</span> a <span class="kr">with</span>
    | Actor name =&gt; showForLogSeq name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree trustRelation := {
  showForProofTree t :=
  <span class="kr">match</span> t <span class="kr">with</span>
    | Trust name =&gt; showForProofTree name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage trustRelation := {
  showForNaturalLanguage t :=
  <span class="kr">match</span> t <span class="kr">with</span>
    | Trust name =&gt; showForNaturalLanguage name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq trustRelation := {
  showForLogSeq t :=
  <span class="kr">match</span> t <span class="kr">with</span>
    | Trust name =&gt; showForLogSeq name
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForProofTree_list</span> {<span class="nv">A</span>} `{ShowForProofTree A} (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;&quot;</span>
    | [h] =&gt; showForProofTree h
    | h1 :: (h2 :: tl) <span class="kr">as</span> tl&#39; =&gt; showForProofTree h1 ++ <span class="s2">&quot;, &quot;</span> ++ showForProofTree_list tl&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForProofTree_list_instance</span> (<span class="nv">A</span> : <span class="kt">Type</span>) `(ShowForProofTree A) : ShowForProofTree (list A) := {
  showForProofTree l := showForProofTree_list l
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3"><span class="kn">Fixpoint</span> <span class="nf">showForNaturalLanguage_list</span> {<span class="nv">A</span>} `{ShowForNaturalLanguage A} (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;no items&quot;</span>
    | [h] =&gt; showForNaturalLanguage h
    | [h1;h2] =&gt; showForNaturalLanguage h1 ++ <span class="s2">&quot;, and &quot;</span> ++ showForNaturalLanguage h2
    | h1 :: (h2 :: tl) <span class="kr">as</span> tl&#39; =&gt; showForNaturalLanguage h1 ++ <span class="s2">&quot;, &quot;</span> ++ showForNaturalLanguage_list tl&#39;
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Unused variable tl might be a misspelled <span class="nb">constructor</span>.
Use _ or _tl to silence this warning.
[unused-<span class="nb">pattern</span>-matching-variable,<span class="nb">pattern</span>-matching]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForNaturalLanguage_list_instance</span> (<span class="nv">A</span> : <span class="kt">Type</span>) `(ShowForNaturalLanguage A) : ShowForNaturalLanguage (list A) := {
    showForNaturalLanguage l := showForNaturalLanguage_list l
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForLogSeq_list</span> {<span class="nv">A</span>} `{ShowForLogSeq A} (indent : string) (l : list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; <span class="s2">&quot;&quot;</span>
    | [h] =&gt; indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq h
    | h :: tl =&gt; indent ++ <span class="s2">&quot;- &quot;</span> ++ showForLogSeq h ++ <span class="s2">&quot;</span>
<span class="s2">&quot;</span> ++ showForLogSeq_list indent tl
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Instance showForLogSeq_list_instance (A : Type) `(ShowForLogSeq A) (indent : string) : ShowForLogSeq (list A) := {</span>
<span class="c">    showForLogSeq l := showForLogSeq_list indent l</span>
<span class="c">  }. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForProofTree judgement := {
  showForProofTree j :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | Judgement e a c =&gt; showForProofTree e ++ <span class="s2">&quot;^{&quot;</span> ++ showForProofTree a ++ <span class="s2">&quot;} \in &quot;</span>
                                  ++ showForProofTree c
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForNaturalLanguage judgement := {
  showForNaturalLanguage j :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | Judgement e a c =&gt; showForNaturalLanguage c ++ <span class="s2">&quot; is supported by $&quot;</span> ++ showForNaturalLanguage e ++ <span class="s2">&quot;$ which &quot;</span> ++ showForNaturalLanguage a ++ <span class="s2">&quot; uses&quot;</span>
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq judgement := {
  showForLogSeq j :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | Judgement e a c =&gt; showForLogSeq c ++ <span class="s2">&quot; is held by &quot;</span> ++ showForLogSeq a ++ <span class="s2">&quot; by the evidence $&quot;</span> ++ showForLogSeq e ++ <span class="s2">&quot;$&quot;</span>
  <span class="kr">end</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForProofTree_judgement</span> {<span class="nv">fDef</span> <span class="nv">HfDef</span>} (<span class="nv">Ps</span> : list judgement) (<span class="nv">Ts</span> : list trustRelation) (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : @proofTreeOf fDef HfDef j) :=
    <span class="kr">match</span> Ps <span class="kr">with</span>
      | [] =&gt; showForProofTree j
      | (h :: tl) <span class="kr">as</span> Ps =&gt; showForProofTree Ps ++ <span class="s2">&quot; \vdash_{&quot;</span> ++ showForProofTree Ts ++ <span class="s2">&quot;} &quot;</span> ++ (showForProofTree j)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk4"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree_judgement [(e1 \<span class="bp">by</span> a1 \<span class="kr">in</span> c1)] [] (e1 \<span class="bp">by</span> a1 \<span class="kr">in</span> c1) (assume e1 a1 c1).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1}&quot;</span>
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Definition showForNaturalLanguage_judgement (Ps : list judgement) (Ts : list trustRelation) (j : judgement) (p : proofTreeOf j) :=</span>
<span class="c">  match Ps with</span>
<span class="c">    | [] =&gt; showForNaturalLanguage j</span>
<span class="c">    | (h :: tl) as Ps =&gt; &quot;Assuming &quot; ++ showForNaturalLanguage Ps ++ &quot; then &quot; ++ showForNaturalLanguage j</span>
<span class="c">  end. *)</span>

<span class="c">(* Definition showForLogSeq_judgement (Ps : list judgement) (Ts : list trustRelation) (indent : string) (j : judgementPart) (p : proofTreeOf j) :=</span>
<span class="c">  DELETEME  </span>
<span class="c">  match Ps,Ts with</span>
<span class="c">        | [],[] =&gt; showForLogSeq j ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made: None&quot; ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used: None&quot;</span>
<span class="c">        | (h :: tl),[] =&gt; showForLogSeq j ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made:&quot; ++ showForLogSeq_list (&quot;  &quot; ++ indent) Ps ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used: None&quot;</span>
<span class="c">        | [],(h :: tl) =&gt; showForLogSeq j ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made: None&quot; ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used:&quot; ++ showForLogSeq_list (&quot;  &quot; ++ indent) Ts</span>
<span class="c">        | (h :: tl),(h2::tl2) =&gt; showForLogSeq j ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made:&quot; ++ showForLogSeq_list (&quot;  &quot; ++ indent) Ps ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used:&quot; ++ showForLogSeq_list (&quot;  &quot; ++ indent) Ts</span>
<span class="c">      end. *)</span>


<span class="c">(* Definition showForLogSeq_judgement (Ps : list judgement) (Ts : list trustRelation) (indent : string) (j : judgement) (p : proofTreeOf j) :=</span>
<span class="c">  match Ps,Ts with</span>
<span class="c">        | [],[] =&gt; showForLogSeq j</span>
<span class="c">        | (h :: tl),[] =&gt; showForLogSeq j ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;collapsed:: true</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made:</span>
<span class="c">&quot; ++ indent ++ &quot;  collapsed:: true</span>
<span class="c">&quot; ++ showForLogSeq_list (&quot;  &quot; ++ indent) Ps</span>
<span class="c">        | [],(h :: tl) =&gt; showForLogSeq j ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;collapsed:: true</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used:</span>
<span class="c">&quot; ++ indent ++ &quot;  collapsed:: true</span>
<span class="c">&quot; ++ showForLogSeq_list (&quot;  &quot; ++ indent) Ts</span>
<span class="c">        | (h :: tl),(h2::tl2) =&gt; showForLogSeq j ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;collapsed:: true</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Assumptions made:</span>
<span class="c">&quot; ++ indent ++ &quot;  collapsed:: true</span>
<span class="c">&quot; ++ showForLogSeq_list (&quot;  &quot; ++ indent) Ps ++ &quot;</span>
<span class="c">&quot; ++ indent ++ &quot;- &quot; ++ &quot;Trust relations used:</span>
<span class="c">&quot; ++ indent ++ &quot;  collapsed:: true</span>
<span class="c">&quot; ++ showForLogSeq_list (&quot;  &quot; ++ indent) Ts</span>
<span class="c">  end. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAllTrustRelationsUsed</span> {<span class="nv">fDef</span> <span class="nv">HFDef</span>} (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : @proofTreeOf fDef HFDef j)
  : list trustRelation :=
<span class="kr">match</span> p <span class="kr">with</span>
| assume e a C =&gt; []
<span class="c">(* | assume_bot a =&gt; [] *)</span>
| bot_elim e a C M =&gt; getAllTrustRelationsUsed _ M
| and_intro e1 e2 a C1 C2 L R =&gt; 
    getAllTrustRelationsUsed _ L ++ getAllTrustRelationsUsed _ R 
| and_elim1 e1 e2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| and_elim2 e1 e2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_intro1 e1  a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_intro2 e2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_elim1 e1 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_elim2 e2 a C1 C2 M =&gt; getAllTrustRelationsUsed _ M
| or_elim3 _ _ _ _ _ _ _ _ _ _ _ M =&gt; getAllTrustRelationsUsed _ M
| trust e a1 a2 C name L =&gt; 
    name :: getAllTrustRelationsUsed _ L
| impl_intro _ _ _ _ _ _ _ M =&gt; getAllTrustRelationsUsed _ M
| impl_elim _ _ _ _ _ _ _ L R =&gt; 
   getAllTrustRelationsUsed _ L ++ getAllTrustRelationsUsed _ R 
| by_def1 _ _ _ _ _ _ _ _ M =&gt; getAllTrustRelationsUsed _ M
| by_def2 _ _ _ _ _ _ _ _ M =&gt; getAllTrustRelationsUsed _ M
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAllEvidence</span> {<span class="nv">fDef</span> <span class="nv">HFDef</span>} (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : @proofTreeOf fDef HFDef j)
  : list evid :=
<span class="kr">match</span> p <span class="kr">with</span>
| assume e a C =&gt; [e]
<span class="c">(* | assume_bot a =&gt; [BotEvid] *)</span>
| bot_elim e a C M =&gt; (getAllEvidence _ M)
| and_intro e1 e2 a C1 C2 L R =&gt; getAllEvidence _ L ++ getAllEvidence _ R 
| and_elim1 e1 e2 a C1 C2 M =&gt; getAllEvidence _ M
| and_elim2 e1 e2 a C1 C2 M =&gt; getAllEvidence _ M
| or_intro1 e1 a C1 C2 M =&gt; getAllEvidence _ M
| or_intro2 e2 a C1 C2 M =&gt; getAllEvidence _ M
| or_elim1 e1 a C1 C2 M =&gt; getAllEvidence _ M
| or_elim2 e2 a C1 C2 M =&gt; getAllEvidence _ M
| or_elim3 _ _ _ _ _ _ _ _ _ _ _ M =&gt; getAllEvidence _ M
| trust e a1 a2 C name L =&gt; getAllEvidence _ L
| impl_intro _ _ _ _ _ _ _ M =&gt; getAllEvidence _ M
| impl_elim _ _ _ _ _ _ _ L R =&gt; 
getAllEvidence _ L ++ getAllEvidence _ R
| by_def1 _ _ _ _ _ _ _ _ M =&gt; getAllEvidence _ M
| by_def2 _ _ _ _ _ _ _ _ M =&gt; getAllEvidence _ M
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isAtomicEvidence</span> (<span class="nv">e</span> : evid) : bool :=
<span class="kr">match</span> e <span class="kr">with</span>
  | AtomicEvid _ =&gt; true
  | _ =&gt; false
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">removeFirstMatch</span> {<span class="nv">A</span>} (<span class="nv">f</span> : A -&gt; bool) (<span class="nv">l</span>:list A) : list A :=
      <span class="kr">match</span> l <span class="kr">with</span>
        | nil =&gt; nil
        | h :: tl =&gt; <span class="kr">if</span> f h <span class="kr">then</span> tl <span class="kr">else</span> h :: removeFirstMatch f tl
      <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">getAssumptions</span> {<span class="nv">fDef</span> <span class="nv">HFDef</span>} (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : @proofTreeOf fDef HFDef j) : list judgement := 
<span class="kr">match</span> p <span class="kr">with</span>
| assume e a C =&gt; [e \<span class="bp">by</span> a \<span class="kr">in</span> C]
<span class="c">(* | assume_bot a =&gt; [BotEvid \by a \in Bottom] *)</span>
| bot_elim e a C M =&gt; getAssumptions _ M
| and_intro e1 e2 a C1 C2 L R =&gt; 
    getAssumptions _ L ++ getAssumptions _ R 
| and_elim1 e1 e2 a C1 C2 M =&gt; getAssumptions _ M
| and_elim2 e1 e2 a C1 C2 M =&gt; getAssumptions _ M
| or_intro1 e1 a C1 C2 M =&gt; getAssumptions _ M
| or_intro2 e2 a C1 C2 M =&gt; getAssumptions _ M
| or_elim1 e1 a C1 C2 M =&gt; getAssumptions _ M
| or_elim2 e2 a C1 C2 M =&gt; getAssumptions _ M
| or_elim3 c A B x d C y e a H1 H2 H3 =&gt; getAssumptions _ H1
    ++ filter (<span class="kr">fun</span> <span class="nv">j</span> =&gt; negb (judgement_beq (x \<span class="bp">by</span> a \<span class="kr">in</span> A) j)) (getAssumptions _ H2)
    ++ filter (<span class="kr">fun</span> <span class="nv">j</span> =&gt; negb (judgement_beq (y \<span class="bp">by</span> a \<span class="kr">in</span> B) j)) (getAssumptions _ H3)
| trust e a1 a2 C name L =&gt; 
    getAssumptions _ L
| impl_intro e1 e2 a C1 C2 _ _ M =&gt; filter (<span class="kr">fun</span> <span class="nv">j</span> =&gt; negb (judgement_beq (e1 \<span class="bp">by</span> a \<span class="kr">in</span> C1) j)) (getAssumptions _ M)
| impl_elim _ _ _ _ _ _ _ L R =&gt; 
getAssumptions _ L ++ getAssumptions _ R
| by_def1 _ _ _ _ _ _ _ _ M =&gt; getAssumptions _ M
| by_def2 _ _ _ _ _ _ _ _ M =&gt; getAssumptions _ M
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Fixpoint proofTreeOf_beq {j1 j2 : judgement} (P1 : proofTreeOf j1) (P2 : proofTreeOf j2) : bool :=</span>
<span class="c">match P1,P2 with</span>
<span class="c">| assume e a1 C1, assume e2 a2 C2 =&gt; (e =? e2) &amp;&amp; (a1 =? a2) &amp;&amp; (C1 =? C2)</span>
<span class="c">| bot_elim e a1 C1 M1, bot_elim e2 a2 C2 M2 =&gt; (e =? e2) &amp;&amp; (a1 =? a2) &amp;&amp; (C1 =? C2) &amp;&amp; proofTreeOf_beq M1 M2</span>
<span class="c">| and_intro e1 e2 a C1 C2 L R, and_intro e1&#39; e2&#39; a&#39; C1&#39; C2&#39; L&#39; R&#39; =&gt; (e1 =? e1&#39;) &amp;&amp; (e2 =? e2&#39;) &amp;&amp; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq L L&#39; &amp;&amp; proofTreeOf_beq R R&#39;</span>
<span class="c">| and_elim1 e1 e2 a C1 C2 M, and_elim1 e1&#39; e2&#39; a&#39; C1&#39; C2&#39; M&#39; =&gt; (e1 =? e1&#39;) &amp;&amp; (e2 =? e2&#39;) &amp;&amp; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;</span>
<span class="c">| and_elim2 e1 e2 a C1 C2 M, and_elim2 e1&#39; e2&#39; a&#39; C1&#39; C2&#39; M&#39; =&gt; (e1 =? e1&#39;) &amp;&amp; (e2 =? e2&#39;) &amp;&amp; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;</span>
<span class="c">| or_intro1 e1 a C1 C2 M, or_intro1 e1&#39; a&#39; C1&#39; C2&#39; M&#39; =&gt; (e1 =? e1&#39;) &amp;&amp; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;</span>
<span class="c">| or_intro2 e2 a C1 C2 M, or_intro2 e2&#39; a&#39; C1&#39; C2&#39; M&#39; =&gt; (e2 =? e2&#39;) &amp;&amp; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;</span>
<span class="c">| or_elim1 e1 a C1 C2 M, or_elim1 e1&#39; a&#39; C1&#39; C2&#39; M&#39; =&gt; (e1 =? e1&#39;) &amp;&amp; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;</span>
<span class="c">| or_elim2 e2 a C1 C2 M, or_elim2 e2&#39; a&#39; C1&#39; C2&#39; M&#39; =&gt; (e2 =? e2&#39;) &amp;&amp; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;</span>
<span class="c">| trust e a1 a2 C T L, trust e&#39; a1&#39; a2&#39; C&#39; T&#39; L&#39; =&gt; (e =? e&#39;) &amp;&amp; (a1 =? a1&#39;) &amp;&amp; (a2 =? a2&#39;) &amp;&amp; (C =? C&#39;) &amp;&amp; (T =? T&#39;) &amp;&amp; proofTreeOf_beq L L&#39;</span>
<span class="c">| impl_intro e1 e2 a C1 C2 M, impl_intro e1&#39; e2&#39; a&#39; C1&#39; C2&#39; M&#39; =&gt; (e1 =? e1&#39;) &amp;&amp; (e2 =? e2&#39;) &amp;&amp; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq M M&#39;</span>
<span class="c">| impl_elim e1 e2 a C1 C2 L R, impl_elim e1&#39; e2&#39; a&#39; C1&#39; C2&#39; L&#39; R&#39; =&gt; (e1 =? e1&#39;) &amp;&amp; (e2 =? e2&#39;) &amp;&amp; (a =? a&#39;) &amp;&amp; (C1 =? C1&#39;) &amp;&amp; (C2 =? C2&#39;) &amp;&amp; proofTreeOf_beq L L&#39; &amp;&amp; proofTreeOf_beq R R&#39;</span>
<span class="c">| _,_ =&gt; false</span>
<span class="c">end. *)</span>

<span class="c">(* Instance beq_proofTreeOf_instance (j : judgement) : Beq (proofTreeOf j) := { beq := proofTreeOf_beq }. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">showForProofTree_proofTreeOf_helper</span> {<span class="nv">fDef</span> <span class="nv">HFDef</span>} (<span class="nv">j</span> : judgement) (<span class="nv">p</span> : @proofTreeOf fDef HFDef j)
  : string :=
<span class="kr">let</span> <span class="nv">Ts</span> := (removeDups (getAllTrustRelationsUsed j p)) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">Ps</span> := (removeDups (getAssumptions j p)) <span class="kr">in</span>
<span class="kr">match</span> p <span class="kr">with</span>
| assume e a C =&gt; <span class="s2">&quot;\AxiomC{$ &quot;</span> 
             ++ showForProofTree C 
             ++ <span class="s2">&quot; \textit{ is a veracity claim} $}&quot;</span>
    ++ <span class="s2">&quot; \RightLabel{ $ assume $}\UnaryInfC{$ &quot;</span>
    ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
<span class="c">(* | assume_bot a =&gt; &quot;\AxiomC{$ &quot; </span>
<span class="c">             ++ showForProofTree C </span>
<span class="c">             ++ &quot; \textit{ is a veracity claim} $}&quot;</span>
<span class="c">    ++ &quot; \RightLabel{ $ assume_{bot} $}\UnaryInfC{$ &quot;</span>
<span class="c">    ++ showForProofTree_judgement Ps Ts _ p ++ &quot; $}&quot; *)</span>
| bot_elim e a C M =&gt; showForProofTree_proofTreeOf_helper _ M
    ++ <span class="s2">&quot; \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ &quot;</span>
    ++ showForProofTree_judgement Ps Ts _ p
    ++ <span class="s2">&quot; $}&quot;</span>
| and_intro e1 e2 a C1 C2 L R =&gt; 
    showForProofTree_proofTreeOf_helper _ L
 ++ showForProofTree_proofTreeOf_helper _ R 
 ++ <span class="s2">&quot; \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
| and_elim1 e1 e2 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \land^{-1} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| and_elim2 e1 e2 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \land^{-2} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_intro1 e1 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{+1} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_intro2 e2 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{+2} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_elim1 e1 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{-1} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| or_elim2 e2 a C1 C2 M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{-2} $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
 | or_elim3 _ _ _ _ _ _ _ _ _ H1 H2 H3 =&gt; showForProofTree_proofTreeOf_helper _ H1
 ++ showForProofTree_proofTreeOf_helper _ H2
 ++ showForProofTree_proofTreeOf_helper _ H3
 ++ <span class="s2">&quot; \RightLabel{ $ \lor^{-} $} \TrinaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
 | trust e a1 a2 C name L =&gt; 
    showForProofTree_proofTreeOf_helper _ L
 ++ <span class="s2">&quot; \AxiomC{$&quot;</span> ++ showForProofTree a1 ++ showForProofTree name ++ showForProofTree a2 ++ <span class="s2">&quot;$} &quot;</span>
 ++ <span class="s2">&quot; \RightLabel{ $ trust\ &quot;</span> ++ showForProofTree name
 ++ <span class="s2">&quot;$} \BinaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
| impl_intro e1 e2 a C1 C2 n H M =&gt; showForProofTree_proofTreeOf_helper _ M
 ++ <span class="s2">&quot; \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p
 ++ <span class="s2">&quot; $}&quot;</span>
| impl_elim e1 e2 a C1 C2 n H L R =&gt; 
     showForProofTree_proofTreeOf_helper _ L
 ++ showForProofTree_proofTreeOf_helper _ R 
 ++ <span class="s2">&quot; \RightLabel{ $ \rightarrow^{-} $} \BinaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
| by_def1 _ _ _ _ _ _ _ L R =&gt;
    showForProofTree_proofTreeOf_helper _ L
 ++ showForProofTree_proofTreeOf_helper _ R 
 ++ <span class="s2">&quot; \RightLabel{ $ \rightarrow^{=}_1 $} \BinaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
 | by_def2 _ _ _ _ _ _ _ L R =&gt;
    showForProofTree_proofTreeOf_helper _ L
 ++ showForProofTree_proofTreeOf_helper _ R 
 ++ <span class="s2">&quot; \RightLabel{ $ \rightarrow^{=}_2 $} \BinaryInfC{$ &quot;</span>
 ++ showForProofTree_judgement Ps Ts _ p ++ <span class="s2">&quot; $}&quot;</span>
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Fixpoint showForNaturalLanguage_proofTreeOf_helper (indent : string) (j : judgement) (p : proofTreeOf j)</span>
<span class="c">  : string :=</span>
<span class="c">let Ts := (removeDups (getAllTrustRelationsUsed j p)) in</span>
<span class="c">let Ps := (removeDups (getAssumptions j p)) in</span>
<span class="c">match p with</span>
<span class="c">| assume e a C =&gt; </span>
<span class="c">indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ indent ++ showForNaturalLanguage C ++ &quot; is a veracity claim.&quot; ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by assumption.&quot;</span>
<span class="c">| bot_elim e a C M =&gt;</span>
<span class="c">indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by the logical principle of explosion.&quot;</span>
<span class="c">| and_intro e1 e2 a C1 C2 L R =&gt; </span>
<span class="c">indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ L ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ R ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;and&#39;.&quot;</span>
<span class="c">| and_elim1 e1 e2 a C1 C2 M =&gt;</span>
<span class="c">indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;and&#39;.&quot;</span>
<span class="c">| and_elim2 e1 e2 a C1 C2 M =&gt; </span>
<span class="c">indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;and&#39;.&quot;</span>
<span class="c">| or_intro1 e1 a C1 C2 M =&gt;</span>
<span class="c">indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;or&#39;.&quot;</span>
<span class="c">| or_intro2 e2 a C1 C2 M =&gt;</span>
<span class="c">indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;or&#39;.&quot;</span>
<span class="c">| or_elim1 e1 a C1 C2 M =&gt;</span>
<span class="c">indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;or&#39;.&quot;</span>
<span class="c">| or_elim2 e2 a C1 C2 M =&gt; </span>
<span class="c">indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for &#39;or&#39;.&quot;</span>
<span class="c">| trust e a1 a2 C name L =&gt; </span>
<span class="c">indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ L ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by the trust relation &quot; ++ showForNaturalLanguage name ++ &quot;.&quot;</span>
<span class="c">| impl_intro e1 e2 a C1 C2 M =&gt; </span>
<span class="c">indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ M ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for implication.&quot;</span>
<span class="c">| impl_elim e1 e2 a C1 C2 L R =&gt; </span>
<span class="c">indent ++ showForNaturalLanguage_judgement Ps Ts _ p ++ &quot;, because</span>
<span class="c">&quot; </span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ L ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ showForNaturalLanguage_proofTreeOf_helper (&quot;  &quot; ++ indent) _ R ++ &quot;</span>
<span class="c">&quot;</span>
<span class="c">++ indent ++ &quot;by a logical rule for implication.&quot;</span>
<span class="c">end. *)</span>

<span class="c">(* Fixpoint showForLogSeq_proofTreeOf_helper (indent : string) (j : judgement) (p : proofTreeOf j)</span>
<span class="c">  : string :=</span>
<span class="c">let Ts := (removeDups (getAllTrustRelationsUsed j p)) in</span>
<span class="c">let Ps := (removeDups (getAssumptions j p)) in</span>
<span class="c">match p with</span>
<span class="c">| assume e a C =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showForLogSeq_judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: we assume this&quot;</span>
<span class="c">| bot_elim e a C M =&gt;</span>
<span class="c">indent ++ &quot;- &quot; ++ showForLogSeq_judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: the principle of explosion</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| and_intro e1 e2 a C1 C2 L R =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showForLogSeq_judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: and introduction</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proofs:</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ L ++ &quot;</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ R</span>
<span class="c">| and_elim1 e1 e2 a C1 C2 M =&gt;</span>
<span class="c">indent ++ &quot;- &quot; ++ showForLogSeq_judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: and elimination (1)</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| and_elim2 e1 e2 a C1 C2 M =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showForLogSeq_judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: and elimination (2)</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| or_intro1 e1 a C1 C2 M =&gt;</span>
<span class="c">indent ++ &quot;- &quot; ++ showForLogSeq_judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: or introduction (1)</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| or_intro2 e2 a C1 C2 M =&gt;</span>
<span class="c">indent ++ &quot;- &quot; ++ showForLogSeq_judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: or introduction (2)</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| or_elim1 e1 a C1 C2 M =&gt;</span>
<span class="c">indent ++ &quot;- &quot; ++ showForLogSeq_judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: or elimination (1)</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| or_elim2 e2 a C1 C2 M =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showForLogSeq_judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: or elimination (2)</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| trust e a1 a2 C name L =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showForLogSeq_judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: trust, with relation &quot; ++ showForLogSeq name ++ &quot;</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ L</span>
<span class="c">| impl_intro e1 e2 a C1 C2 M =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showForLogSeq_judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: implication introduction</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proof:</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ M</span>
<span class="c">| impl_elim e1 e2 a C1 C2 L R =&gt; </span>
<span class="c">indent ++ &quot;- &quot; ++ showForLogSeq_judgement Ps Ts (&quot;  &quot; ++ indent) _ p ++ &quot;</span>
<span class="c">  &quot; ++ indent ++ &quot;- &quot; ++ &quot;Logical rule used: implication elimination</span>
<span class="c">    &quot; ++ indent ++ &quot;- &quot; ++ &quot;Sub-proofs:</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ L ++ &quot;</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper (&quot;      &quot; ++ indent) _ R</span>
<span class="c">end. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">showForProofTree_proofTreeOf</span> <span class="nv">fDef</span> <span class="nv">HFDef</span> <span class="nv">j</span> <span class="nv">p</span>
  := <span class="s2">&quot;\begin{prooftree}&quot;</span> ++ @showForProofTree_proofTreeOf_helper fDef HFDef j p
       ++ <span class="s2">&quot;\end{prooftree}&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForProofTree_proofTreeOf_instance</span> <span class="nv">fDef</span> <span class="nv">HFDef</span> (<span class="nv">j</span> : judgement)
  : ShowForProofTree (proofTreeOf j) := { showForProofTree := @showForProofTree_proofTreeOf fDef HFDef j}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Definition showForNaturalLanguage_proofTreeOf j p := &quot;</span>

<span class="c">&quot; ++ showForNaturalLanguage_proofTreeOf_helper &quot;- &quot; j p ++ &quot;</span>

<span class="c">&quot;.</span>
<span class="c">Instance showForNaturalLanguage_proofTreeOf_instance (j : judgement)</span>
<span class="c">  : ShowForNaturalLanguage (proofTreeOf j) := { showForNaturalLanguage := showForNaturalLanguage_proofTreeOf j}. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">printProofTitle</span> <span class="nv">j</span> :=
<span class="kr">match</span> j <span class="kr">with</span>
| Judgement e a c =&gt; <span class="s2">&quot;### Veracity proof that &quot;</span> ++ showForLogSeq c ++ <span class="s2">&quot; is held by &quot;</span> ++ showForLogSeq a ++ <span class="s2">&quot; by the evidence &quot;</span> ++ showForLogSeq e
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> : ShowForLogSeq string := { showForLogSeq := id}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Definition showForLogSeq_proofTreeOf j p := </span>
<span class="c">let evidenceList := (removeDups (filter isAtomicEvidence (getAllEvidence j p))) in</span>
<span class="c">let evidenceWithNames := map (fun e =&gt; match e with</span>
<span class="c">                                   | AtomicEvid n =&gt; showForLogSeq e ++ &quot; = &quot; ++ showForLogSeq n</span>
<span class="c">                                   | _ =&gt; &quot;&quot;</span>
<span class="c">                                   end) evidenceList in</span>
<span class="c">&quot;</span>

<span class="c">&quot; ++ printProofTitle j ++ &quot;</span>
<span class="c">&quot; ++ showForLogSeq_proofTreeOf_helper &quot;  &quot; j p ++ &quot;</span>
<span class="c">  - Atomic evidence is abbreviated as follows:</span>
<span class="c">    collapsed:: true</span>
<span class="c">&quot; ++ showForLogSeq_list &quot;    &quot; evidenceWithNames ++ &quot;</span>

<span class="c">&quot;.</span>
<span class="c">Instance showForLogSeq_proofTreeOf_instance (j : judgement)</span>
<span class="c">  : ShowForLogSeq (proofTreeOf j) := { showForLogSeq := showForLogSeq_proofTreeOf j}.</span>

<span class="c">Fixpoint showListOfProofTrees {j : judgement} (l : list (proofTreeOf j)) :=</span>
<span class="c">    match l with</span>
<span class="c">      | [] =&gt; &quot;&quot;</span>
<span class="c">      | h :: tl =&gt; &quot;</span>

<span class="c">----------------</span>

<span class="c">&quot; ++ showForProofTree h ++ showListOfProofTrees tl</span>
<span class="c">    end. *)</span>







</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">proofTreeOf_wrapped</span> (<span class="nv">a</span> : actor) (<span class="nv">c</span> : claim) := {
      _f : list definedFDef;
      _fDef : _;
      _e : evid;
      _p : @proofTreeOf _f _fDef (_e \<span class="bp">by</span> a \<span class="kr">in</span> c)
    }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Unfold</span> keepOnlyDuplicates : veracityPrf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Unfold</span> keepOnlyDuplicates_helper : veracityPrf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Unfold</span> containsMatchingEvidArgument : veracityPrf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">showForProofTree_proofTreeOf_wrapped_instance</span> (<span class="nv">a</span> : actor) (<span class="nv">c</span> : claim) : ShowForProofTree (proofTreeOf_wrapped a c) := { showForProofTree p := showForProofTree (_p a c p) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Instance showForNaturalLanguage_proofTreeOf_wrapped_instance (c : claim) : ShowForNaturalLanguage (proofTreeOf_wrapped c) := { showForNaturalLanguage p := showForNaturalLanguage (_p c p) }.</span>
<span class="c">Instance showForLogSeq_proofTreeOf_wrapped_instance (c : claim) : ShowForLogSeq (proofTreeOf_wrapped c) := { showForLogSeq p := showForLogSeq (_p c p) }. *)</span>


    <span class="c">(* eassert(proofTreeOf ((Lambda &quot;f&quot; e2 e1) \by a1 \in (Implies c1 c1))) as lF.</span>
<span class="c">    eapply (by_def2 _ _ _ _ _ _).</span>
<span class="c">    eassert(proofTreeOf ((Lambda &quot;g&quot; _ _) \by a1 \in _)) as lG by eapply assume.</span>
<span class="c">    eassert(proofTreeOf ((Lambda &quot;h&quot; _ _) \by a1 \in _)) as lH by eapply assume. *)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> beq_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">validateFDef</span> :=
  <span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">simpl</span>; <span class="nb">autounfold with</span> veracityPrf; <span class="nb">simpl</span>; <span class="bp">reflexivity</span>);
  <span class="kp">try</span> (<span class="nb">simpl</span>; <span class="bp">reflexivity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk5"><span class="kn">Definition</span> <span class="nf">impl_intro1</span> : proofTreeOf_wrapped a1 ((Implies c1 c1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (Implies c1 c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk6"><span class="nb">eexists</span> [DF _f_ e1 e1 c1 c1] _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c1 c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk7"><span class="nb">eapply</span> (impl_intro e1 _ _ _ _ _f_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume e1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates [DF _f_ e1 e1 c1 c1] ++
 inconsitentTypes [DF _f_ e1 e1 c1 c1])%list = []</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _f_ e1 e1 c1 c1) [DF _f_ e1 e1 c1 c1] =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* intros. simpl. autounfold with veracityPrf. simpl. reflexivity.</span>
<span class="c">    simpl. reflexivity. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree impl_intro1).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ (\lambda f)^{a_{1}} \in (C_{1} \rightarrow C_{1}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka"><span class="kn">Definition</span> <span class="nf">impl_intro2</span> : proofTreeOf_wrapped a1 (Implies c1 (Implies c1 c1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (Implies c1 (Implies c1 c1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb"><span class="nb">eexists</span> [DF _f_ e1 (Lambda _g_ e1 e1 c1 c1) c1 (Implies c1 c1); DF _g_ e1 e1 c1 c1] _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c1 (Implies c1 c1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc"><span class="nb">eapply</span> (impl_intro e1 _ _ _ _ _f_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c1 c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd"><span class="nb">eapply</span> (impl_intro e1 _ _ _ _ _g_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume e1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chke"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates
   [DF _f_ e1 (Lambda _g_ e1 e1 c1 c1) c1
      (Implies c1 c1); DF _g_ e1 e1 c1 c1] ++
 inconsitentTypes
   [DF _f_ e1 (Lambda _g_ e1 e1 c1 c1) c1
      (Implies c1 c1); DF _g_ e1 e1 c1 c1])%list = []</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains
  (DF _f_ e1 (Lambda _g_ e1 e1 c1 c1) c1
     (Implies c1 c1))
  [DF _f_ e1 (Lambda _g_ e1 e1 c1 c1) c1
     (Implies c1 c1); DF _g_ e1 e1 c1 c1] = true</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _g_ e1 e1 c1 c1)
  [DF _f_ e1 (Lambda _g_ e1 e1 c1 c1) c1
     (Implies c1 c1); DF _g_ e1 e1 c1 c1] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkf"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree impl_intro2).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ (\lambda g)^{a_{1}} \in (C_{1} \rightarrow C_{1}) $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ (\lambda f)^{a_{1}} \in (C_{1} \rightarrow (C_{1} \rightarrow C_{1})) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk10"><span class="kn">Definition</span> <span class="nf">impl_elim1</span> : proofTreeOf_wrapped a1 c1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk11"><span class="nb">eexists</span> [DF _f_ e2 e1 c2 c1; DF _g_ e1 e1 c1 c1] _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk12"><span class="nb">eapply</span> (impl_elim _ _ _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  (Lambda <span class="nl">?n</span> <span class="nl">?e1</span> <span class="nl">?e2</span> <span class="nl">?C1</span> c1) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies <span class="nl">?C1</span> c1)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> <span class="nl">?C1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk13"><span class="nb">eapply</span> (impl_intro e2 _ _ _ _ _f_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e2 \<span class="bp">by</span> a1 \<span class="kr">in</span> <span class="nl">?C1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk14"><span class="nb">eapply</span> (assume e1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e2 \<span class="bp">by</span> a1 \<span class="kr">in</span> <span class="nl">?C1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume e2 _ c2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk15"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates
   [DF _f_ e2 e1 c2 c1; DF _g_ e1 e1 c1 c1] ++
 inconsitentTypes
   [DF _f_ e2 e1 c2 c1; DF _g_ e1 e1 c1 c1])%list = []</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _f_ e2 e1 c2 c1)
  [DF _f_ e2 e1 c2 c1; DF _g_ e1 e1 c1 c1] = true</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _f_ e2 e1 c2 c1)
  [DF _f_ e2 e1 c2 c1; DF _g_ e1 e1 c1 c1] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk16"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree impl_elim1).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} (\lambda f)^{a_{1}} \in (C_{2} \rightarrow C_{1}) $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{} e_{2}^{a_{1}} \in C_{2} $} \RightLabel{ $ \rightarrow^{-} $} \BinaryInfC{$ e_{1}^{a_{1}} \in C_{1}, e_{2}^{a_{1}} \in C_{2} \vdash_{} f(e_{2})^{a_{1}} \in C_{1} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk17"><span class="kn">Definition</span> <span class="nf">impl_by_def</span> : proofTreeOf_wrapped a1 c1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk18"><span class="nb">eexists</span> [DF _f_ e2 e1 c1 c1; DF _g_ e1 e1 c1 c1] _ _; 
    <span class="nb">eapply</span> (by_def2 _ _ _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  (Lambda <span class="nl">?n</span> <span class="nl">?e1</span> <span class="nl">?Goal0</span> <span class="nl">?C1</span> c1) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies <span class="nl">?C1</span> c1)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (Apply <span class="nl">?n</span> <span class="nl">?e1</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk19"><span class="nb">eapply</span> (impl_intro e2 _ _ c1 _ _f_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (Apply _f_ e2) \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1a"><span class="nb">eapply</span> (assume e1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (Apply _f_ e2) \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1b"><span class="nb">eapply</span> (by_def1 _ _ _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  (Lambda _f_ e2 <span class="nl">?e2</span> <span class="nl">?C1</span> c1) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies <span class="nl">?C1</span> c1)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1c"><span class="nb">eapply</span> (impl_intro e2 _ _ c1 _ _f_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1d"><span class="nb">eapply</span> (assume e1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e1 \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume e1 _ c1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1e"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates
   [DF _f_ e2 e1 c1 c1; DF _g_ e1 e1 c1 c1] ++
 inconsitentTypes
   [DF _f_ e2 e1 c1 c1; DF _g_ e1 e1 c1 c1])%list = []</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _f_ e2 e1 c1 c1)
  [DF _f_ e2 e1 c1 c1; DF _g_ e1 e1 c1 c1] = true</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _f_ e2 e1 c1 c1)
  [DF _f_ e2 e1 c1 c1; DF _g_ e1 e1 c1 c1] = true</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _f_ e2 e1 c1 c1)
  [DF _f_ e2 e1 c1 c1; DF _g_ e1 e1 c1 c1] = true</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _f_ e2 e1 c1 c1)
  [DF _f_ e2 e1 c1 c1; DF _g_ e1 e1 c1 c1] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk1f"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree impl_by_def).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} (\lambda f)^{a_{1}} \in (C_{1} \rightarrow C_{1}) $}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} (\lambda f)^{a_{1}} \in (C_{1} \rightarrow C_{1}) $}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^{=}_1 $} \BinaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} f(e_{2})^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^{=}_2 $} \BinaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk20"><span class="kn">Definition</span> <span class="nf">impl_and</span> : proofTreeOf_wrapped a1 (Implies (c1 /\&#39; c2) c1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (Implies (c1 /\&#39; c2) c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk21"><span class="nb">eexists</span> [DF _f_ e1 e1 (c1 /\&#39; c2) c1] _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies (c1 /\&#39; c2) c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk22"><span class="nb">eapply</span> (impl_intro e1 _ _ _ _ _f_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk23"><span class="nb">eapply</span> (and_elim1 _ _ _ _ c2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{<span class="nl">?e2</span>, <span class="nl">?e20</span>}} \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 /\&#39; c2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk24"><span class="nb">eapply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e20</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk25"><span class="nb">eapply</span> (assume e1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume e2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk26"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates [DF _f_ e1 e1 (c1 /\&#39; c2) c1] ++
 inconsitentTypes [DF _f_ e1 e1 (c1 /\&#39; c2) c1])%list =
[]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _f_ e1 e1 (c1 /\&#39; c2) c1)
  [DF _f_ e1 e1 (c1 /\&#39; c2) c1] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk27"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree impl_and).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{} e_{2}^{a_{1}} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e_{1}^{a_{1}} \in C_{1}, e_{2}^{a_{1}} \in C_{2} \vdash_{} (e_{1}, e_{2})^{a_{1}} \in (C_{1} \wedge C_{2}) $} \RightLabel{ $ \land^{-1} $} \UnaryInfC{$ e_{1}^{a_{1}} \in C_{1}, e_{2}^{a_{1}} \in C_{2} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ e_{1}^{a_{1}} \in C_{1}, e_{2}^{a_{1}} \in C_{2} \vdash_{} (\lambda f)^{a_{1}} \in ((C_{1} \wedge C_{2}) \rightarrow C_{1}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk28"><span class="kn">Definition</span> <span class="nf">impl_and&#39;</span> : proofTreeOf_wrapped a1 (Implies c1 (Implies c2 c1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (Implies c1 (Implies c2 c1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk29"><span class="nb">eexists</span> [DF _f_ e1 (Lambda _g_ e2 e1 c2 c1) c1
    (Implies c2 c1); DF _g_ e2 e1 c2 c1] _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c1 (Implies c2 c1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2a"><span class="nb">eapply</span> (impl_intro e1 _ _ _ _ _f_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c2 c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2b"><span class="nb">eapply</span> (impl_intro e2 _ _ _ _ _g_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2c"><span class="nb">eapply</span> (and_elim1 _ _ _ _ c2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{<span class="nl">?e2</span>, <span class="nl">?e20</span>}} \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 /\&#39; c2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2d"><span class="nb">eapply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e20</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2e"><span class="nb">eapply</span> (assume e1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume e2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk2f"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates
   [DF _f_ e1 (Lambda _g_ e2 e1 c2 c1) c1
      (Implies c2 c1); DF _g_ e2 e1 c2 c1] ++
 inconsitentTypes
   [DF _f_ e1 (Lambda _g_ e2 e1 c2 c1) c1
      (Implies c2 c1); DF _g_ e2 e1 c2 c1])%list = []</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains
  (DF _f_ e1 (Lambda _g_ e2 e1 c2 c1) c1
     (Implies c2 c1))
  [DF _f_ e1 (Lambda _g_ e2 e1 c2 c1) c1
     (Implies c2 c1); DF _g_ e2 e1 c2 c1] = true</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _g_ e2 e1 c2 c1)
  [DF _f_ e1 (Lambda _g_ e2 e1 c2 c1) c1
     (Implies c2 c1); DF _g_ e2 e1 c2 c1] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk30"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree impl_and&#39;).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{} e_{2}^{a_{1}} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e_{1}^{a_{1}} \in C_{1}, e_{2}^{a_{1}} \in C_{2} \vdash_{} (e_{1}, e_{2})^{a_{1}} \in (C_{1} \wedge C_{2}) $} \RightLabel{ $ \land^{-1} $} \UnaryInfC{$ e_{1}^{a_{1}} \in C_{1}, e_{2}^{a_{1}} \in C_{2} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} (\lambda g)^{a_{1}} \in (C_{2} \rightarrow C_{1}) $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ (\lambda f)^{a_{1}} \in (C_{1} \rightarrow (C_{2} \rightarrow C_{1})) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk31"><span class="kn">Definition</span> <span class="nf">impl_and&#39;&#39;</span> : proofTreeOf_wrapped a1 (Implies (c1 /\&#39; c2) c1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (Implies (c1 /\&#39; c2) c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk32"><span class="nb">eexists</span> [DF _f_ {{e1, e2}} e1 (c1 /\&#39; c2) c1] _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies (c1 /\&#39; c2) c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk33"><span class="nb">eapply</span> (impl_intro {{e1,e2}} _ _ _ _ _f_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk34"><span class="nb">eapply</span> (and_elim1 _ _ _ _ c2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{<span class="nl">?e2</span>, <span class="nl">?e20</span>}} \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 /\&#39; c2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume {{e1,e2}}).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk35"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates
   [DF _f_ {{e1, e2}} e1 (c1 /\&#39; c2) c1] ++
 inconsitentTypes
   [DF _f_ {{e1, e2}} e1 (c1 /\&#39; c2) c1])%list = []</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _f_ {{e1, e2}} e1 (c1 /\&#39; c2) c1)
  [DF _f_ {{e1, e2}} e1 (c1 /\&#39; c2) c1] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk36"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree impl_and&#39;&#39;).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ (C_{1} \wedge C_{2}) \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ (e_{1}, e_{2})^{a_{1}} \in (C_{1} \wedge C_{2}) \vdash_{} (e_{1}, e_{2})^{a_{1}} \in (C_{1} \wedge C_{2}) $} \RightLabel{ $ \land^{-1} $} \UnaryInfC{$ (e_{1}, e_{2})^{a_{1}} \in (C_{1} \wedge C_{2}) \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ (\lambda f)^{a_{1}} \in ((C_{1} \wedge C_{2}) \rightarrow C_{1}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk37"><span class="kn">Definition</span> <span class="nf">and_example</span> : proofTreeOf_wrapped a1 (Implies c1 (c1 /\&#39; c1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (Implies c1 (c1 /\&#39; c1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk38"><span class="nb">eexists</span> [DF _f_ e1 {{e1, e1}} c1 (c1 /\&#39; c1)] _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c1 (c1 /\&#39; c1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk39"><span class="nb">eapply</span> (impl_intro e1 _ _ _ _ _f_ _ ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 /\&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3a"><span class="nb">eapply</span> (and_intro).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3b"><span class="nb">eapply</span> (assume e1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> (assume e1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3c"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates
   [DF _f_ e1 {{e1, e1}} c1 (c1 /\&#39; c1)] ++
 inconsitentTypes
   [DF _f_ e1 {{e1, e1}} c1 (c1 /\&#39; c1)])%list = []</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _f_ e1 {{e1, e1}} c1 (c1 /\&#39; c1))
  [DF _f_ e1 {{e1, e1}} c1 (c1 /\&#39; c1)] = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3d"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree and_example).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} (e_{1}, e_{1})^{a_{1}} \in (C_{1} \wedge C_{1}) $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ (\lambda f)^{a_{1}} \in (C_{1} \rightarrow (C_{1} \wedge C_{1})) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3e"><span class="kn">Definition</span> <span class="nf">or_elim3_example</span> : proofTreeOf_wrapped a1 (Implies ((c1 \/&#39; c2) /\&#39; (Implies c1 _|_)) c2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk3f"><span class="nb">pose</span> ([
      DF _g_ e2 e2 c2 c2;  
      DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}} (Cases e4 _w_ _g_) ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
      DF _u_ e1 BotEvid c1 _|_;
      DF _w_ e1 (BotEvidApplied BotEvid) c1 c2
    ] : list definedFDef).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></small><span class="alectryon-wsp">    
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk40"><span class="nb">eexists</span> l _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk41"><span class="nb">epose proof</span> (@assume l _ {{_, (Lambda _u_ e1 BotEvid c1 _|_)}} a1 ((c1 \/&#39; c2) /\&#39; (Implies c1 _|_))) <span class="kr">as</span> p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk42"><span class="nb">eassert</span>(@proofTreeOf l _ (_ \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2))) <span class="kr">as</span> p2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk43" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk43"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk44"><span class="nb">eapply</span>(and_elim1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  {{<span class="nl">?e</span>, <span class="nl">?e2</span>}} \<span class="bp">by</span> a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; <span class="nl">?C2</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk45"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk46"><span class="nb">eapply</span> p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk47"><span class="nb">eassert</span>(@proofTreeOf l _ ((Lambda _u_ _ _ c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c1 _|_))) <span class="kr">as</span> p3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  (Lambda _u_ <span class="nl">?e1</span> <span class="nl">?e2</span> c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ <span class="nl">?e1</span> <span class="nl">?e2</span> c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk48"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk49"><span class="nb">eapply</span>(and_elim2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  {{<span class="nl">?e10</span>, Lambda _u_ <span class="nl">?e1</span> <span class="nl">?e2</span> c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (<span class="nl">?C1</span> /\&#39; Implies c1 _|_)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ <span class="nl">?e1</span> <span class="nl">?e2</span> c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk4a"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk4b"><span class="nb">eapply</span> p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk4c"><span class="nb">eassert</span>(@proofTreeOf l _ _ \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c1 c2)) <span class="kr">as</span> p4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c1 c2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk4d"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk4e"><span class="nb">eapply</span>(impl_intro e1 _ _ _ _ _w_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _w_ e1 <span class="nl">?e2</span> c1 c2) l = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk4f"><hr></label><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 <span class="nl">?e2</span> c1 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk50"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk51"><span class="nb">shelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 <span class="nl">?e2</span> c1 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk52"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk53"><span class="nb">eapply</span> (bot_elim BotEvid).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf BotEvid \<span class="bp">by</span> a1 \<span class="kr">in</span> _|_</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk54" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk54"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk55"><span class="nb">eapply</span> (by_def2 _ _ _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  (Lambda <span class="nl">?n</span> <span class="nl">?e10</span> BotEvid <span class="nl">?C1</span> _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies <span class="nl">?C1</span> _|_)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk56"><hr></label><div class="goal-conclusion">proofTreeOf (Apply <span class="nl">?n</span> <span class="nl">?e10</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> _|_</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk57" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk57"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk58"><span class="nb">eapply</span> p3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (Apply _u_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> _|_</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk59"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk5a"><span class="nb">eapply</span>(impl_elim e1 _ _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  (Lambda _u_ e1 <span class="nl">?e2</span> <span class="nl">?C1</span> _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies <span class="nl">?C1</span> _|_)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk5b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk5b"><hr></label><div class="goal-conclusion">proofTreeOf e1 \<span class="bp">by</span> a1 \<span class="kr">in</span> <span class="nl">?C1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk5c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk5c"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk5d"><span class="nb">eapply</span> p3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e1 \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk5e"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk5f"><span class="nb">eapply</span> assume.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk60"><span class="nb">eassert</span>(@proofTreeOf l _ ((Apply _w_ _) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2)) <span class="kr">as</span> p5.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (Apply _w_ <span class="nl">?e10</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ <span class="nl">?e10</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk61"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk62"><span class="nb">eapply</span> (impl_elim _ _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">contains (DF _w_ <span class="nl">?e10</span> <span class="nl">?e2</span> <span class="nl">?C1</span> c2) l = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk63"><hr></label><div class="goal-conclusion">proofTreeOf
  (Lambda _w_ <span class="nl">?e10</span> <span class="nl">?e2</span> <span class="nl">?C1</span> c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies <span class="nl">?C1</span> c2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk64"><hr></label><div class="goal-conclusion">proofTreeOf <span class="nl">?e10</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> <span class="nl">?C1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ <span class="nl">?e10</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk65"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk66"><span class="nb">shelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  (Lambda _w_ <span class="nl">?e10</span> <span class="nl">?e2</span> <span class="nl">?C1</span> c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies <span class="nl">?C1</span> c2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk67"><hr></label><div class="goal-conclusion">proofTreeOf <span class="nl">?e10</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> <span class="nl">?C1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ <span class="nl">?e10</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk68"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk69"><span class="nb">eapply</span> p4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e1 \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk6a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk6a"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk6b"><span class="nb">eapply</span> (assume _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></small><span class="alectryon-wsp">    
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk6c"><span class="nb">eassert</span>(@proofTreeOf l _ ((Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c2 c2))) <span class="kr">as</span> p6.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c2 c2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk6d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk6d"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk6e"><span class="nb">eapply</span> (impl_intro e2 _ _ _ _ _g_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e2 \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk6f"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk70"><span class="nb">eapply</span> assume.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk71"><span class="nb">eassert</span>(@proofTreeOf l _ ((Apply _g_ _) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2)) <span class="kr">as</span> p7.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (Apply _g_ <span class="nl">?e10</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br><span><var>p7</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _g_ <span class="nl">?e10</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk72"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk73"><span class="nb">eapply</span> (by_def1 _ _ _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  (Lambda _g_ <span class="nl">?e10</span> <span class="nl">?e2</span> <span class="nl">?C1</span> c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies <span class="nl">?C1</span> c2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk74" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk74"><hr></label><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br><span><var>p7</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _g_ <span class="nl">?e10</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk75"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk76"><span class="nb">eapply</span> p6.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e2 \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br><span><var>p7</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _g_ e2) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk77"><hr></label><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk78"><span class="nb">eapply</span> assume.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br><span><var>p7</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _g_ e2) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk79"><span class="nb">eapply</span>(impl_intro {{e4, Lambda _u_ e1 BotEvid c1 _|_}} _ _ _ _ _h_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br><span><var>p7</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _g_ e2) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk7a"><span class="nb">eapply</span> (or_elim3 e4 _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br><span><var>p7</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _g_ e2) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e4 \<span class="bp">by</span> a1 \<span class="kr">in</span> (<span class="nl">?A</span> \/&#39; <span class="nl">?B</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk7b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br><span><var>p7</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _g_ e2) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk7b"><hr></label><div class="goal-conclusion">proofTreeOf (Apply <span class="nl">?d</span> <span class="nl">?x</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{<span class="nl">?e1</span>, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span>
  a1 \<span class="kr">in</span> ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br><span><var>p7</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _g_ e2) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk7c"><hr></label><div class="goal-conclusion">proofTreeOf (Apply <span class="nl">?e</span> <span class="nl">?y</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk7d"><span class="nb">apply</span> p2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{e4, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf e4 \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br><span><var>p7</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _g_ e2) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (Apply <span class="nl">?d</span> <span class="nl">?x</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{e4, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf e4 \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br><span><var>p7</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _g_ e2) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk7e"><hr></label><div class="goal-conclusion">proofTreeOf (Apply <span class="nl">?e</span> <span class="nl">?y</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk7f"><span class="nb">apply</span> p5.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{e4, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf e4 \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br><span><var>p7</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _g_ e2) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (Apply <span class="nl">?e</span> <span class="nl">?y</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> p7.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk80"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates l ++ inconsitentTypes l)%list = []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk81" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{e4, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf e4 \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk81"><hr></label><div class="goal-conclusion">contains (DF _w_ e1 (BotEvidApplied BotEvid) c1 c2) l =
true</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk82" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{e4, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf e4 \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk82"><hr></label><div class="goal-conclusion">contains (DF _u_ e1 BotEvid c1 _|_) l = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{e4, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf e4 \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk83"><hr></label><div class="goal-conclusion">contains (DF _u_ e1 BotEvid c1 _|_) l = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk84" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{e4, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf e4 \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk84"><hr></label><div class="goal-conclusion">contains (DF _w_ e1 (BotEvidApplied BotEvid) c1 c2) l =
true</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk85" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{e4, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf e4 \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk85"><hr></label><div class="goal-conclusion">contains (DF _g_ e2 e2 c2 c2) l = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk86" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{e4, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf e4 \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk86"><hr></label><div class="goal-conclusion">contains (DF _g_ e2 e2 c2 c2) l = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="veracitylogic-v-chk87" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>[DF _g_ e2 e2 c2 c2;
 DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
   (Cases e4 _w_ _g_)
   ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2;
 DF _u_ e1 BotEvid c1 _|_;
 DF _w_ e1 (BotEvidApplied BotEvid) c1 c2]
:
list definedFDef</span></span><span class="hyp-type"><b>: </b><span>list definedFDef</span></span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  {{e4, Lambda _u_ e1 BotEvid c1 _|_}} \<span class="bp">by</span> a1 \<span class="kr">in</span>
  ((c1 \/&#39; c2) /\&#39; Implies c1 _|_)</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>proofTreeOf e4 \<span class="bp">by</span> a1 \<span class="kr">in</span> (c1 \/&#39; c2)</span></span></span><br><span><var>p3</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _u_ e1 BotEvid c1 _|_) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c1 _|_)</span></span></span><br><span><var>p4</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _w_ e1 (BotEvidApplied BotEvid) c1 c2) \<span class="bp">by</span>
  a1 \<span class="kr">in</span> (Implies c1 c2)</span></span></span><br><span><var>p5</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _w_ e1) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br><span><var>p6</var><span class="hyp-type"><b>: </b><span>proofTreeOf
  (Lambda _g_ e2 e2 c2 c2) \<span class="bp">by</span> a1 \<span class="kr">in</span>
  (Implies c2 c2)</span></span></span><br><span><var>p7</var><span class="hyp-type"><b>: </b><span>proofTreeOf (Apply _g_ e2) \<span class="bp">by</span> a1 \<span class="kr">in</span> c2</span></span></span><br></div><label class="goal-separator" for="veracitylogic-v-chk87"><hr></label><div class="goal-conclusion">contains
  (DF _h_ {{e4, Lambda _u_ e1 BotEvid c1 _|_}}
     (Cases e4 _w_ _g_)
     ((c1 \/&#39; c2) /\&#39; Implies c1 _|_) c2) l = true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="kp">try</span> <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* unfold inconsitentTypes. remember (keepOnlyDuplicates l) as asdf. simpl. *)</span>
<span class="c">(* autounfold with veracityPrf. simpl. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk88"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree or_elim3_example).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) \vdash_{} (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) $} \RightLabel{ $ \land^{-1} $} \UnaryInfC{$ (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) \vdash_{} e_{4}^{a_{1}} \in (C_{1} \vee C_{2}) $}\AxiomC{$ ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) \vdash_{} (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) $} \RightLabel{ $ \land^{-2} $} \UnaryInfC{$ (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) \vdash_{} (\lambda u)^{a_{1}} \in (C_{1} \rightarrow \bot) $}\AxiomC{$ ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) \vdash_{} (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) $} \RightLabel{ $ \land^{-2} $} \UnaryInfC{$ (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) \vdash_{} (\lambda u)^{a_{1}} \in (C_{1} \rightarrow \bot) $}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^{-} $} \BinaryInfC{$ (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)), e_{1}^{a_{1}} \in C_{1} \vdash_{} u(e_{1})^{a_{1}} \in \bot $} \RightLabel{ $ \rightarrow^{=}_2 $} \BinaryInfC{$ (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)), e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)), e_{1}^{a_{1}} \in C_{1} \vdash_{} R_{0}(e_{\bot})^{a_{1}} \in C_{2} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) \vdash_{} (\lambda w)^{a_{1}} \in (C_{1} \rightarrow C_{2}) $}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{1}^{a_{1}} \in C_{1} \vdash_{} e_{1}^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^{-} $} \BinaryInfC{$ (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)), e_{1}^{a_{1}} \in C_{1} \vdash_{} w(e_{1})^{a_{1}} \in C_{2} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{} e_{2}^{a_{1}} \in C_{2} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ (\lambda g)^{a_{1}} \in (C_{2} \rightarrow C_{2}) $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{} e_{2}^{a_{1}} \in C_{2} $} \RightLabel{ $ \rightarrow^{=}_1 $} \BinaryInfC{$ e_{2}^{a_{1}} \in C_{2} \vdash_{} g(e_{2})^{a_{1}} \in C_{2} $} \RightLabel{ $ \lor^{-} $} \TrinaryInfC{$ (e_{4}, (\lambda u))^{a_{1}} \in ((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) \vdash_{} cases(e_{4},  w, g)^{a_{1}} \in C_{2} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ (\lambda h)^{a_{1}} \in (((C_{1} \vee C_{2}) \wedge (C_{1} \rightarrow \bot)) \rightarrow C_{2}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre></div>
<div class="section" id="an-example-from-the-paper">
<h1>An example from the paper</h1>
<p>This example is the top half of the proof tree on p13 (Section 4.2) of the draft paper.</p>
<p>The proof trees visualised in this section are <strong>automatically generated</strong> by Coq.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">l</span> := AtomicEvid _l_ .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">s</span> := AtomicEvid _s_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">c</span> := AtomicEvid _c_evid_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">P</span> := Actor _P_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Q</span> := Actor _Q_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C1</span> := AtomicClaim _c1_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C2</span> := AtomicClaim _c2_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C3</span> := AtomicClaim _c3_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C4</span> := AtomicClaim _c4_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">C5</span> := AtomicClaim _c5_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trustT</span> := Trust _T_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trustU</span> := Trust _U_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trustV</span> := Trust _V_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk89"><span class="kn">Program Definition</span> <span class="nf">concreteProofTreeExampleWith2Conjuncts</span> : 
@proofTreeOf [] _ ({{l, s}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8a"><span class="nb">apply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf l \<span class="bp">by</span> P \<span class="kr">in</span> C1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf s \<span class="bp">by</span> P \<span class="kr">in</span> C2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8b"><span class="nb">apply</span> assume.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf s \<span class="bp">by</span> P \<span class="kr">in</span> C2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> assume.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8c"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith2Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in (C_{1} \wedge C_{2}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8d"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith2Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForNaturalLanguage</span>) :=
     <span class="nl">?ShowForNaturalLanguage</span> <span class="kr">in</span>
   showForNaturalLanguage)
    (and_intro (AtomicEvid _l_) (AtomicEvid _s_)
       (Actor _P_) (AtomicClaim _c1_)
       (AtomicClaim _c2_)
       (assume (AtomicEvid _l_) (Actor _P_)
          (AtomicClaim _c1_))
       (assume (AtomicEvid _s_) (Actor _P_)
          (AtomicClaim _c2_)))
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8e"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith2Conjuncts.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForLogSeq</span>) := <span class="nl">?ShowForLogSeq</span> <span class="kr">in</span>
   showForLogSeq)
    (and_intro (AtomicEvid _l_) (AtomicEvid _s_)
       (Actor _P_) (AtomicClaim _c1_)
       (AtomicClaim _c2_)
       (assume (AtomicEvid _l_) (Actor _P_)
          (AtomicClaim _c1_))
       (assume (AtomicEvid _s_) (Actor _P_)
          (AtomicClaim _c2_)))
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk8f"><span class="kn">Program Definition</span> <span class="nf">concreteProofTreeExampleWith3Conjuncts</span> : 
@proofTreeOf [] _ ({{{{l, s}},c}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk90"><span class="nb">apply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk91"><span class="nb">apply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf l \<span class="bp">by</span> P \<span class="kr">in</span> C1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf s \<span class="bp">by</span> P \<span class="kr">in</span> C2</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk92"><span class="nb">apply</span> (assume l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf s \<span class="bp">by</span> P \<span class="kr">in</span> C2</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk93"><span class="nb">apply</span> (assume s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume c).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk94"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith3Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in (C_{1} \wedge C_{2}) $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk95"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith3Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForNaturalLanguage</span>) :=
     <span class="nl">?ShowForNaturalLanguage</span> <span class="kr">in</span>
   showForNaturalLanguage)
    (and_intro {{AtomicEvid _l_, AtomicEvid _s_}}
       (AtomicEvid _c_evid_) (Actor _P_)
       (AtomicClaim _c1_ /\&#39; AtomicClaim _c2_)
       (AtomicClaim _c3_)
       (and_intro (AtomicEvid _l_)
          (AtomicEvid _s_) (Actor _P_)
          (AtomicClaim _c1_) (AtomicClaim _c2_)
          (assume (AtomicEvid _l_) (Actor _P_)
             (AtomicClaim _c1_))
          (assume (AtomicEvid _s_) (Actor _P_)
             (AtomicClaim _c2_)))
       (assume (AtomicEvid _c_evid_) (Actor _P_)
          (AtomicClaim _c3_)))
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk96"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith3Conjuncts.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForLogSeq</span>) := <span class="nl">?ShowForLogSeq</span> <span class="kr">in</span>
   showForLogSeq)
    (and_intro {{AtomicEvid _l_, AtomicEvid _s_}}
       (AtomicEvid _c_evid_) (Actor _P_)
       (AtomicClaim _c1_ /\&#39; AtomicClaim _c2_)
       (AtomicClaim _c3_)
       (and_intro (AtomicEvid _l_)
          (AtomicEvid _s_) (Actor _P_)
          (AtomicClaim _c1_) (AtomicClaim _c2_)
          (assume (AtomicEvid _l_) (Actor _P_)
             (AtomicClaim _c1_))
          (assume (AtomicEvid _s_) (Actor _P_)
             (AtomicClaim _c2_)))
       (assume (AtomicEvid _c_evid_) (Actor _P_)
          (AtomicClaim _c3_)))
: string</blockquote></div></div></small></span></pre><p>We can also combine existing trees into new trees, when appropriate. For example:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk97"><span class="kn">Program Definition</span> <span class="nf">concreteProofTreeExampleWith3ConjunctsUsingExistingTree</span> : 
@proofTreeOf [] _ {{{{l, s}},c}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk98"><span class="nb">apply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s}} \<span class="bp">by</span> P \<span class="kr">in</span> (C1 /\&#39; C2)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk99"><span class="bp">exact</span> concreteProofTreeExampleWith2Conjuncts.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9a"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(and_intro {{l, s}} c P (C1 /\&#39; C2) C3
   concreteProofTreeExampleWith2Conjuncts <span class="nl">?Goal</span>)</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf c \<span class="bp">by</span> P \<span class="kr">in</span> C3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume c).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9b"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith3Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in (C_{1} \wedge C_{2}) $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9c"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith3Conjuncts).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForNaturalLanguage</span>) :=
     <span class="nl">?ShowForNaturalLanguage</span> <span class="kr">in</span>
   showForNaturalLanguage)
    (and_intro {{AtomicEvid _l_, AtomicEvid _s_}}
       (AtomicEvid _c_evid_) (Actor _P_)
       (AtomicClaim _c1_ /\&#39; AtomicClaim _c2_)
       (AtomicClaim _c3_)
       (and_intro (AtomicEvid _l_)
          (AtomicEvid _s_) (Actor _P_)
          (AtomicClaim _c1_) (AtomicClaim _c2_)
          (assume (AtomicEvid _l_) (Actor _P_)
             (AtomicClaim _c1_))
          (assume (AtomicEvid _s_) (Actor _P_)
             (AtomicClaim _c2_)))
       (assume (AtomicEvid _c_evid_) (Actor _P_)
          (AtomicClaim _c3_)))
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9d"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith3Conjuncts.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForLogSeq</span>) := <span class="nl">?ShowForLogSeq</span> <span class="kr">in</span>
   showForLogSeq)
    (and_intro {{AtomicEvid _l_, AtomicEvid _s_}}
       (AtomicEvid _c_evid_) (Actor _P_)
       (AtomicClaim _c1_ /\&#39; AtomicClaim _c2_)
       (AtomicClaim _c3_)
       (and_intro (AtomicEvid _l_)
          (AtomicEvid _s_) (Actor _P_)
          (AtomicClaim _c1_) (AtomicClaim _c2_)
          (assume (AtomicEvid _l_) (Actor _P_)
             (AtomicClaim _c1_))
          (assume (AtomicEvid _s_) (Actor _P_)
             (AtomicClaim _c2_)))
       (assume (AtomicEvid _c_evid_) (Actor _P_)
          (AtomicClaim _c3_)))
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9e"><span class="kn">Program Definition</span> <span class="nf">concreteProofTreeExampleTrust</span> : 
@proofTreeOf [] _ e \<span class="bp">by</span> a1 \<span class="kr">in</span> (C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e \<span class="bp">by</span> a1 \<span class="kr">in</span> C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chk9f"><span class="nb">eapply</span> (trust _ a1 a2 C trustT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf e \<span class="bp">by</span> a2 \<span class="kr">in</span> C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume e).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka0"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleTrust).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{2}} \in C \vdash_{} e^{a_{2}} \in C $} \AxiomC{$a_{1}Ta_{2}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ e^{a_{2}} \in C \vdash_{T} e^{a_{1}} \in C $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka1"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleTrust).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForNaturalLanguage</span>) :=
     <span class="nl">?ShowForNaturalLanguage</span> <span class="kr">in</span>
   showForNaturalLanguage)
    (trust (AtomicEvid _e_) (Actor _a1_)
       (Actor _a2_) (AtomicClaim _c_) (Trust _T_)
       (assume (AtomicEvid _e_) (Actor _a2_)
          (AtomicClaim _c_)))
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka2"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleTrust.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForLogSeq</span>) := <span class="nl">?ShowForLogSeq</span> <span class="kr">in</span>
   showForLogSeq)
    (trust (AtomicEvid _e_) (Actor _a1_)
       (Actor _a2_) (AtomicClaim _c_) (Trust _T_)
       (assume (AtomicEvid _e_) (Actor _a2_)
          (AtomicClaim _c_)))
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka3"><span class="kn">Program Definition</span> <span class="nf">concreteProofTreeExampleWith3ConjunctsWithTrust</span> : 
@proofTreeOf [] _ {{{{l, s}},c}} \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka4"><span class="nb">eapply</span> (trust _ _ _ _ trustU).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> <span class="nl">?a2</span> \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concreteProofTreeExampleWith3ConjunctsUsingExistingTree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka5"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith3ConjunctsWithTrust).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in (C_{1} \wedge C_{2}) $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $} \AxiomC{$QUP$}  \RightLabel{ $ trust\ U$} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{U} ((l, s), c)^{Q} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small><span class="alectryon-wsp"> </span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka6"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith3ConjunctsWithTrust).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForNaturalLanguage</span>) :=
     <span class="nl">?ShowForNaturalLanguage</span> <span class="kr">in</span>
   showForNaturalLanguage)
    (trust
       {{AtomicEvid _l_, AtomicEvid _s_,
       AtomicEvid _c_evid_}} (Actor _Q_)
       (Actor _P_)
       (AtomicClaim _c1_ /\&#39; AtomicClaim _c2_ /\&#39;
        AtomicClaim _c3_) (Trust _U_)
       (and_intro
          {{AtomicEvid _l_, AtomicEvid _s_}}
          (AtomicEvid _c_evid_) (Actor _P_)
          (AtomicClaim _c1_ /\&#39; AtomicClaim _c2_)
          (AtomicClaim _c3_)
          (and_intro (AtomicEvid _l_)
             (AtomicEvid _s_) (Actor _P_)
             (AtomicClaim _c1_)
             (AtomicClaim _c2_)
             (assume (AtomicEvid _l_) (Actor _P_)
                (AtomicClaim _c1_))
             (assume (AtomicEvid _s_) (Actor _P_)
                (AtomicClaim _c2_)))
          (assume (AtomicEvid _c_evid_)
             (Actor _P_) (AtomicClaim _c3_))))
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka7"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith3ConjunctsWithTrust.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForLogSeq</span>) := <span class="nl">?ShowForLogSeq</span> <span class="kr">in</span>
   showForLogSeq)
    (trust
       {{AtomicEvid _l_, AtomicEvid _s_,
       AtomicEvid _c_evid_}} (Actor _Q_)
       (Actor _P_)
       (AtomicClaim _c1_ /\&#39; AtomicClaim _c2_ /\&#39;
        AtomicClaim _c3_) (Trust _U_)
       (and_intro
          {{AtomicEvid _l_, AtomicEvid _s_}}
          (AtomicEvid _c_evid_) (Actor _P_)
          (AtomicClaim _c1_ /\&#39; AtomicClaim _c2_)
          (AtomicClaim _c3_)
          (and_intro (AtomicEvid _l_)
             (AtomicEvid _s_) (Actor _P_)
             (AtomicClaim _c1_)
             (AtomicClaim _c2_)
             (assume (AtomicEvid _l_) (Actor _P_)
                (AtomicClaim _c1_))
             (assume (AtomicEvid _s_) (Actor _P_)
                (AtomicClaim _c2_)))
          (assume (AtomicEvid _c_evid_)
             (Actor _P_) (AtomicClaim _c3_))))
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka8"><span class="kn">Program Definition</span> <span class="nf">concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras</span> : 
@proofTreeOf [] _ {{{{l, s}},c}} \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chka9"><span class="nb">eapply</span> (trust _ Q Q _ trustU).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkaa"><span class="nb">eapply</span> (trust _ Q Q _ trustV).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> Q \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkab"><span class="nb">eapply</span> (trust _ _ _ _ trustU).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf {{l, s, c}} \<span class="bp">by</span> <span class="nl">?a2</span> \<span class="kr">in</span> (C1 /\&#39; C2 /\&#39; C3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concreteProofTreeExampleWith3ConjunctsUsingExistingTree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkac"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(trust {{l, s, c}} Q Q (C1 /\&#39; C2 /\&#39; C3) trustU
   (trust {{l, s, c}} Q Q (C1 /\&#39; C2 /\&#39; C3) trustV
      (trust {{l, s, c}} Q P (C1 /\&#39; C2 /\&#39; C3) trustU
         concreteProofTreeExampleWith3ConjunctsUsingExistingTree)))</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkad"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForProofTree concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ l^{P} \in C_{1} \vdash_{} l^{P} \in C_{1} $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ s^{P} \in C_{2} \vdash_{} s^{P} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2} \vdash_{} (l, s)^{P} \in (C_{1} \wedge C_{2}) $}\AxiomC{$ C_{3} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ c^{P} \in C_{3} \vdash_{} c^{P} \in C_{3} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{} ((l, s), c)^{P} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $} \AxiomC{$QUP$}  \RightLabel{ $ trust\ U$} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{U} ((l, s), c)^{Q} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $} \AxiomC{$QVQ$}  \RightLabel{ $ trust\ V$} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{V, U} ((l, s), c)^{Q} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $} \AxiomC{$QUQ$}  \RightLabel{ $ trust\ U$} \BinaryInfC{$ l^{P} \in C_{1}, s^{P} \in C_{2}, c^{P} \in C_{3} \vdash_{V, U} ((l, s), c)^{Q} \in ((C_{1} \wedge C_{2}) \wedge C_{3}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small><span class="alectryon-wsp"> </span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkae"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> (showForNaturalLanguage concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForNaturalLanguage</span>) :=
     <span class="nl">?ShowForNaturalLanguage</span> <span class="kr">in</span>
   showForNaturalLanguage)
    (trust
       {{AtomicEvid _l_, AtomicEvid _s_,
       AtomicEvid _c_evid_}} (Actor _Q_)
       (Actor _Q_)
       (AtomicClaim _c1_ /\&#39; AtomicClaim _c2_ /\&#39;
        AtomicClaim _c3_) (Trust _U_)
       (trust
          {{AtomicEvid _l_, AtomicEvid _s_,
          AtomicEvid _c_evid_}} (Actor _Q_)
          (Actor _Q_)
          (AtomicClaim _c1_ /\&#39; AtomicClaim _c2_ /\&#39;
           AtomicClaim _c3_) (Trust _V_)
          (trust
             {{AtomicEvid _l_, AtomicEvid _s_,
             AtomicEvid _c_evid_}} (Actor _Q_)
             (Actor _P_)
             (AtomicClaim _c1_ /\&#39;
              AtomicClaim _c2_ /\&#39;
              AtomicClaim _c3_) (Trust _U_)
             (and_intro
                {{AtomicEvid _l_,
                AtomicEvid _s_}}
                (AtomicEvid _c_evid_) (Actor _P_)
                (AtomicClaim _c1_ /\&#39;
                 AtomicClaim _c2_)
                (AtomicClaim _c3_)
                (and_intro (AtomicEvid _l_)
                   (AtomicEvid _s_) (Actor _P_)
                   (AtomicClaim _c1_)
                   (AtomicClaim _c2_)
                   (assume (AtomicEvid _l_)
                      (Actor _P_)
                      (AtomicClaim _c1_))
                   (assume (AtomicEvid _s_)
                      (Actor _P_)
                      (AtomicClaim _c2_)))
                (assume (AtomicEvid _c_evid_)
                   (Actor _P_) (AtomicClaim _c3_))))))
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkaf"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForLogSeq</span>) := <span class="nl">?ShowForLogSeq</span> <span class="kr">in</span>
   showForLogSeq)
    (trust
       {{AtomicEvid _l_, AtomicEvid _s_,
       AtomicEvid _c_evid_}} (Actor _Q_)
       (Actor _Q_)
       (AtomicClaim _c1_ /\&#39; AtomicClaim _c2_ /\&#39;
        AtomicClaim _c3_) (Trust _U_)
       (trust
          {{AtomicEvid _l_, AtomicEvid _s_,
          AtomicEvid _c_evid_}} (Actor _Q_)
          (Actor _Q_)
          (AtomicClaim _c1_ /\&#39; AtomicClaim _c2_ /\&#39;
           AtomicClaim _c3_) (Trust _V_)
          (trust
             {{AtomicEvid _l_, AtomicEvid _s_,
             AtomicEvid _c_evid_}} (Actor _Q_)
             (Actor _P_)
             (AtomicClaim _c1_ /\&#39;
              AtomicClaim _c2_ /\&#39;
              AtomicClaim _c3_) (Trust _U_)
             (and_intro
                {{AtomicEvid _l_,
                AtomicEvid _s_}}
                (AtomicEvid _c_evid_) (Actor _P_)
                (AtomicClaim _c1_ /\&#39;
                 AtomicClaim _c2_)
                (AtomicClaim _c3_)
                (and_intro (AtomicEvid _l_)
                   (AtomicEvid _s_) (Actor _P_)
                   (AtomicClaim _c1_)
                   (AtomicClaim _c2_)
                   (assume (AtomicEvid _l_)
                      (Actor _P_)
                      (AtomicClaim _c1_))
                   (assume (AtomicEvid _s_)
                      (Actor _P_)
                      (AtomicClaim _c2_)))
                (assume (AtomicEvid _c_evid_)
                   (Actor _P_) (AtomicClaim _c3_))))))
: string</blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb0"><span class="kn">Definition</span> <span class="nf">exampleWithProofOf</span> : proofTreeOf_wrapped a1 C1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb2"><span class="nb">eexists</span> [] _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume e a1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb3"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates [] ++ inconsitentTypes [])%list =
[]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb4"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree exampleWithProofOf.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{1} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C_{1} \vdash_{} e^{a_{1}} \in C_{1} $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb5"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForNaturalLanguage exampleWithProofOf.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForNaturalLanguage</span>) :=
     <span class="nl">?ShowForNaturalLanguage</span> <span class="kr">in</span>
   showForNaturalLanguage)
    {|
      _f := [];
      _fDef := eq_refl;
      _e := AtomicEvid _e_;
      _p :=
        assume (AtomicEvid _e_) (Actor _a1_)
          (AtomicClaim _c1_)
    |}
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb6"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq exampleWithProofOf.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForLogSeq</span>) := <span class="nl">?ShowForLogSeq</span> <span class="kr">in</span>
   showForLogSeq)
    {|
      _f := [];
      _fDef := eq_refl;
      _e := AtomicEvid _e_;
      _p :=
        assume (AtomicEvid _e_) (Actor _a1_)
          (AtomicClaim _c1_)
    |}
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb7"><span class="kn">Definition</span> <span class="nf">usingAll</span> : proofTreeOf_wrapped a1 (Implies _|_ C1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (Implies _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (Implies _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkb9"><span class="nb">eexists</span> [DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ c1] _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkba"><span class="nb">eapply</span> (or_elim1 _ _ _ C2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  (Left <span class="nl">?Goal0</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies _|_ C1 \/&#39; C2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkbb"><span class="nb">eapply</span> or_intro1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkbc"><span class="nb">eapply</span> (or_elim2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  (Right <span class="nl">?Goal0</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> (<span class="nl">?C1</span> \/&#39; Implies _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkbd"><span class="nb">eapply</span> or_intro2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkbe"><span class="nb">eapply</span> and_elim1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  {{<span class="nl">?Goal0</span>, <span class="nl">?e2</span>}} \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies _|_ C1 /\&#39; <span class="nl">?C2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkbf"><span class="nb">eapply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies _|_ C1)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> <span class="nl">?C2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc0"><span class="nb">eapply</span> and_elim2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf
  {{<span class="nl">?e1</span>, <span class="nl">?Goal0</span>}} \<span class="bp">by</span> a1 \<span class="kr">in</span> (<span class="nl">?C10</span> /\&#39; Implies _|_ C1)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> <span class="nl">?C2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc1"><span class="nb">eapply</span> and_intro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> <span class="nl">?C10</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies _|_ C1)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> <span class="nl">?C2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc2"><span class="nb">apply</span> (assume e a1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies _|_ C1)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> <span class="nl">?C2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc3"><span class="mi">2</span>: <span class="nb">apply</span> (assume e a1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc4"><span class="nb">eapply</span> (trust _ _ _ _ trustT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal0</span> \<span class="bp">by</span> <span class="nl">?a2</span> \<span class="kr">in</span> (Implies _|_ C1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc5"><span class="nb">eapply</span> (impl_intro BotEvid (BotEvidApplied BotEvid) a1 _|_ C1 _f_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (BotEvidApplied BotEvid) \<span class="bp">by</span> a1 \<span class="kr">in</span> C1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc6"><span class="nb">eapply</span> bot_elim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf BotEvid \<span class="bp">by</span> a1 \<span class="kr">in</span> _|_</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (assume BotEvid a1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc7"><span class="kn">Unshelve</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates
   [DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ c1] ++
 inconsitentTypes
   [DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ c1])%list =
[]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">claim</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">claim</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">claim</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains
  (DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ C1)
  [DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ c1] =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc8"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{|
  _f :=
    [DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ c1];
  _fDef := <span class="nl">?Goal</span>;
  _e :=
    Lambda _f_ BotEvid (BotEvidApplied BotEvid) _|_ C1;
  _p :=
    or_elim1
      (Lambda _f_ BotEvid (BotEvidApplied BotEvid) _|_
         C1) a1 (Implies _|_ C1) C2
      (or_intro1
         (Lambda _f_ BotEvid (BotEvidApplied BotEvid)
            _|_ C1) a1 (Implies _|_ C1) C2
         (or_elim2
            (Lambda _f_ BotEvid
               (BotEvidApplied BotEvid) _|_ C1) a1 
            <span class="nl">?C1</span> (Implies _|_ C1)
            (or_intro2
               (Lambda _f_ BotEvid
                  (BotEvidApplied BotEvid) _|_ C1) a1
               <span class="nl">?C1</span> (Implies _|_ C1)
               (and_elim1
                  (Lambda _f_ BotEvid
                     (BotEvidApplied BotEvid) _|_ C1)
                  e a1 (Implies _|_ C1) <span class="nl">?C2</span>
                  (and_intro
                     (Lambda _f_ BotEvid
                        (BotEvidApplied BotEvid) _|_
                        C1) e a1 (Implies _|_ C1) 
                     <span class="nl">?C2</span>
                     (and_elim2 e
                        (Lambda _f_ BotEvid
                           (BotEvidApplied BotEvid)
                           _|_ C1) a1 <span class="nl">?C10</span>
                        (Implies _|_ C1)
                        (and_intro e
                           (Lambda _f_ BotEvid
                              (BotEvidApplied BotEvid)
                              _|_ C1) a1 <span class="nl">?C10</span>
                           (Implies _|_ C1)
                           (assume e a1 <span class="nl">?C10</span>)
                           (trust
                              (Lambda _f_ BotEvid
                                 (BotEvidApplied
                                    BotEvid) _|_ C1)
                              a1 a1 (Implies _|_ C1)
                              trustT
                              (impl_intro BotEvid
                                 (BotEvidApplied
                                    BotEvid) a1 _|_ C1
                                 _f_ <span class="nl">?H</span>
                                 (bot_elim BotEvid a1
                                    C1
                                    (assume BotEvid a1
                                       _|_))))))
                     (assume e a1 <span class="nl">?C2</span>))))))
|}</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates
   [DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ c1] ++
 inconsitentTypes
   [DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ c1])%list =
[]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">claim</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">claim</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">claim</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains
  (DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ C1)
  [DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ c1] =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkc9"><span class="kp">all</span>: <span class="kp">try</span> <span class="nb">apply</span> _c_; <span class="kp">try</span> <span class="nb">apply</span> C2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(keepOnlyDuplicates
   [DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ c1] ++
 inconsitentTypes
   [DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ c1])%list =
[]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains
  (DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ C1)
  [DF _f_ BotEvid (BotEvidApplied BotEvid) _|_ c1] =
true</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkca"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForProofTree usingAll.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="s2">&quot;\begin{prooftree}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{} e^{a_{1}} \in C_{2} $}\AxiomC{$ \bot \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} e_{\bot}^{a_{1}} \in \bot $} \RightLabel{ $ \bot^{-} $} \UnaryInfC{$ e_{\bot}^{a_{1}} \in \bot \vdash_{} R_{0}(e_{\bot})^{a_{1}} \in C_{1} $} \RightLabel{ $ \rightarrow^+ $} \UnaryInfC{$ (\lambda f)^{a_{1}} \in (\bot \rightarrow C_{1}) $} \AxiomC{$a_{1}Ta_{1}$}  \RightLabel{ $ trust\ T$} \BinaryInfC{$ (\lambda f)^{a_{1}} \in (\bot \rightarrow C_{1}) $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{T} (e, (\lambda f))^{a_{1}} \in (C_{2} \wedge (\bot \rightarrow C_{1})) $} \RightLabel{ $ \land^{-2} $} \UnaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{T} (\lambda f)^{a_{1}} \in (\bot \rightarrow C_{1}) $}\AxiomC{$ C_{2} \textit{ is a veracity claim} $} \RightLabel{ $ assume $}\UnaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{} e^{a_{1}} \in C_{2} $} \RightLabel{ $ \wedge^{+} $} \BinaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{T} ((\lambda f), e)^{a_{1}} \in ((\bot \rightarrow C_{1}) \wedge C_{2}) $} \RightLabel{ $ \land^{-1} $} \UnaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{T} (\lambda f)^{a_{1}} \in (\bot \rightarrow C_{1}) $} \RightLabel{ $ \lor^{+2} $} \UnaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{T} j((\lambda f))^{a_{1}} \in (C_{2} \vee (\bot \rightarrow C_{1})) $} \RightLabel{ $ \lor^{-2} $} \UnaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{T} (\lambda f)^{a_{1}} \in (\bot \rightarrow C_{1}) $} \RightLabel{ $ \lor^{+1} $} \UnaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{T} i((\lambda f))^{a_{1}} \in ((\bot \rightarrow C_{1}) \vee C_{2}) $} \RightLabel{ $ \lor^{-1} $} \UnaryInfC{$ e^{a_{1}} \in C_{2} \vdash_{T} (\lambda f)^{a_{1}} \in (\bot \rightarrow C_{1}) $}\end{prooftree}&quot;</span>
: string</blockquote></div></div></small></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkcb"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForNaturalLanguage usingAll.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForNaturalLanguage</span>) :=
     <span class="nl">?ShowForNaturalLanguage</span> <span class="kr">in</span>
   showForNaturalLanguage)
    {|
      _f :=
        [DF _f_ BotEvid (BotEvidApplied BotEvid)
           _|_ (AtomicClaim _c1_)];
      _fDef := eq_refl;
      _e :=
        Lambda _f_ BotEvid
          (BotEvidApplied BotEvid) _|_
          (AtomicClaim _c1_);
      _p :=
        or_elim1
          (Lambda _f_ BotEvid
             (BotEvidApplied BotEvid) _|_
             (AtomicClaim _c1_)) (Actor _a1_)
          (Implies _|_ (AtomicClaim _c1_))
          (AtomicClaim _c2_)
          (or_intro1
             (Lambda _f_ BotEvid
                (BotEvidApplied BotEvid) _|_
                (AtomicClaim _c1_)) (Actor _a1_)
             (Implies _|_ (AtomicClaim _c1_))
             (AtomicClaim _c2_)
             (or_elim2
                (Lambda _f_ BotEvid
                   (BotEvidApplied BotEvid) _|_
                   (AtomicClaim _c1_))
                (Actor _a1_) (AtomicClaim _c2_)
                (Implies _|_ (AtomicClaim _c1_))
                (or_intro2
                   (Lambda _f_ BotEvid
                      (BotEvidApplied BotEvid)
                      _|_ (AtomicClaim _c1_))
                   (Actor _a1_)
                   (AtomicClaim _c2_)
                   (Implies _|_
                      (AtomicClaim _c1_))
                   (and_elim1
                      (Lambda _f_ BotEvid
                         (BotEvidApplied BotEvid)
                         _|_ (AtomicClaim _c1_))
                      (AtomicEvid _e_)
                      (Actor _a1_)
                      (Implies _|_
                         (AtomicClaim _c1_))
                      (AtomicClaim _c2_)
                      (and_intro
                         (Lambda _f_ BotEvid
                            (BotEvidApplied
                               BotEvid) _|_
                            (AtomicClaim _c1_))
                         (AtomicEvid _e_)
                         (Actor _a1_)
                         (Implies _|_
                            (AtomicClaim _c1_))
                         (AtomicClaim _c2_)
                         (and_elim2
                            (AtomicEvid _e_)
                            (Lambda _f_ BotEvid
                               (BotEvidApplied
                                  BotEvid) _|_
                               (AtomicClaim _c1_))
                            (Actor _a1_)
                            (AtomicClaim _c2_)
                            (Implies _|_
                               (AtomicClaim _c1_))
                            (and_intro
                               (AtomicEvid _e_)
                               (Lambda _f_
                                  BotEvid
                                  (BotEvidApplied
                                     BotEvid) _|_
                                  (AtomicClaim
                                     _c1_))
                               (Actor _a1_)
                               (AtomicClaim _c2_)
                               (Implies _|_
                                  (AtomicClaim
                                     _c1_))
                               (assume
                                  (AtomicEvid _e_)
                                  (Actor _a1_)
                                  (AtomicClaim
                                     _c2_))
                               (trust
                                  (Lambda _f_
                                     BotEvid
                                     (BotEvidApplied
                                        BotEvid)
                                     _|_
                                     (AtomicClaim
                                        _c1_))
                                  (Actor _a1_)
                                  (Actor _a1_)
                                  (Implies _|_
                                     (AtomicClaim
                                        _c1_))
                                  (Trust _T_)
                                  (impl_intro
                                     BotEvid
                                     (BotEvidApplied
                                        BotEvid)
                                     (Actor _a1_)
                                     _|_
                                     (AtomicClaim
                                        _c1_) _f_
                                     eq_refl
                                     (bot_elim
                                        BotEvid
                                        (Actor
                                           _a1_)
                                        (AtomicClaim
                                           _c1_)
                                        (assume
                                           BotEvid
                                           ...
                                           _|_))))))
                         (assume (AtomicEvid _e_)
                            (Actor _a1_)
                            (AtomicClaim _c2_)))))))
    |}
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkcc"><span class="kn">Eval</span> <span class="nb">compute</span> <span class="kr">in</span> showForLogSeq usingAll.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="kr">let</span> (<span class="nv">showForLogSeq</span>) := <span class="nl">?ShowForLogSeq</span> <span class="kr">in</span>
   showForLogSeq)
    {|
      _f :=
        [DF _f_ BotEvid (BotEvidApplied BotEvid)
           _|_ (AtomicClaim _c1_)];
      _fDef := eq_refl;
      _e :=
        Lambda _f_ BotEvid
          (BotEvidApplied BotEvid) _|_
          (AtomicClaim _c1_);
      _p :=
        or_elim1
          (Lambda _f_ BotEvid
             (BotEvidApplied BotEvid) _|_
             (AtomicClaim _c1_)) (Actor _a1_)
          (Implies _|_ (AtomicClaim _c1_))
          (AtomicClaim _c2_)
          (or_intro1
             (Lambda _f_ BotEvid
                (BotEvidApplied BotEvid) _|_
                (AtomicClaim _c1_)) (Actor _a1_)
             (Implies _|_ (AtomicClaim _c1_))
             (AtomicClaim _c2_)
             (or_elim2
                (Lambda _f_ BotEvid
                   (BotEvidApplied BotEvid) _|_
                   (AtomicClaim _c1_))
                (Actor _a1_) (AtomicClaim _c2_)
                (Implies _|_ (AtomicClaim _c1_))
                (or_intro2
                   (Lambda _f_ BotEvid
                      (BotEvidApplied BotEvid)
                      _|_ (AtomicClaim _c1_))
                   (Actor _a1_)
                   (AtomicClaim _c2_)
                   (Implies _|_
                      (AtomicClaim _c1_))
                   (and_elim1
                      (Lambda _f_ BotEvid
                         (BotEvidApplied BotEvid)
                         _|_ (AtomicClaim _c1_))
                      (AtomicEvid _e_)
                      (Actor _a1_)
                      (Implies _|_
                         (AtomicClaim _c1_))
                      (AtomicClaim _c2_)
                      (and_intro
                         (Lambda _f_ BotEvid
                            (BotEvidApplied
                               BotEvid) _|_
                            (AtomicClaim _c1_))
                         (AtomicEvid _e_)
                         (Actor _a1_)
                         (Implies _|_
                            (AtomicClaim _c1_))
                         (AtomicClaim _c2_)
                         (and_elim2
                            (AtomicEvid _e_)
                            (Lambda _f_ BotEvid
                               (BotEvidApplied
                                  BotEvid) _|_
                               (AtomicClaim _c1_))
                            (Actor _a1_)
                            (AtomicClaim _c2_)
                            (Implies _|_
                               (AtomicClaim _c1_))
                            (and_intro
                               (AtomicEvid _e_)
                               (Lambda _f_
                                  BotEvid
                                  (BotEvidApplied
                                     BotEvid) _|_
                                  (AtomicClaim
                                     _c1_))
                               (Actor _a1_)
                               (AtomicClaim _c2_)
                               (Implies _|_
                                  (AtomicClaim
                                     _c1_))
                               (assume
                                  (AtomicEvid _e_)
                                  (Actor _a1_)
                                  (AtomicClaim
                                     _c2_))
                               (trust
                                  (Lambda _f_
                                     BotEvid
                                     (BotEvidApplied
                                        BotEvid)
                                     _|_
                                     (AtomicClaim
                                        _c1_))
                                  (Actor _a1_)
                                  (Actor _a1_)
                                  (Implies _|_
                                     (AtomicClaim
                                        _c1_))
                                  (Trust _T_)
                                  (impl_intro
                                     BotEvid
                                     (BotEvidApplied
                                        BotEvid)
                                     (Actor _a1_)
                                     _|_
                                     (AtomicClaim
                                        _c1_) _f_
                                     eq_refl
                                     (bot_elim
                                        BotEvid
                                        (Actor
                                           _a1_)
                                        (AtomicClaim
                                           _c1_)
                                        (assume
                                           BotEvid
                                           ...
                                           _|_))))))
                         (assume (AtomicEvid _e_)
                            (Actor _a1_)
                            (AtomicClaim _c2_)))))))
    |}
: string</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">healthy</span> := AtomicClaim _healthy_ .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">nonToxic</span> := AtomicClaim _nonToxic_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">organic</span> := AtomicClaim _organic_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">belief</span> := AtomicEvid _belief_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">testing</span> := AtomicEvid _testing_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">audit</span> := AtomicEvid _audit_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">retailer</span> := Actor _retailer_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">vineyard</span> := Actor _vineyard_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">winery</span> := Actor _winery_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* Definition exampleFromJosh : proofTreeOf_wrapped healthy.</span>
<span class="c">eexists _ retailer.</span>
<span class="c">eapply (impl_elim _ _ _ (nonToxic /\&#39; organic)).</span>
<span class="c">try (apply (assume belief retailer (Implies (nonToxic /\&#39; organic) healthy))).</span>
<span class="c">try (apply (assume testing vineyard nonToxic)).</span>
<span class="c">try (apply (assume audit winery organic)).</span>
<span class="c">eapply and_intro.</span>
<span class="c">eapply (trust _ retailer vineyard _ trustT).</span>
<span class="c">try (apply (assume belief retailer (Implies (nonToxic /\&#39; organic) healthy))).</span>
<span class="c">try (apply (assume testing vineyard nonToxic)).</span>
<span class="c">try (apply (assume audit winery organic)).</span>
<span class="c">eapply (trust _ retailer winery _ trustT).</span>
<span class="c">try (apply (assume belief retailer (Implies (nonToxic /\&#39; organic) healthy))).</span>
<span class="c">try (apply (assume testing vineyard nonToxic)).</span>
<span class="c">try (apply (assume audit winery organic)).</span>
<span class="c">Show Proof.</span>
<span class="c">Defined. *)</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* Eval compute in showForProofTree exampleFromJosh. *)</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* Eval compute in showForNaturalLanguage exampleFromJosh. *)</span>
<span class="c">(* Eval compute in showForLogSeq exampleFromJosh. *)</span>

<span class="c">(* Definition certifier := Actor _certifier_.</span>
<span class="c">Definition applicant := Actor _applicant_.</span>
<span class="c">Definition ingredients_valid := AtomicClaim _ingredients_valid_.</span>
<span class="c">Definition ingredients_valid_approved := AtomicClaim _ingredients_valid_approved_.</span>
<span class="c">Definition recipe_valid := AtomicClaim _recipe_valid_.</span>
<span class="c">Definition percentage_ingredients_valid := AtomicClaim _percentage_ingredients_valid_.</span>
<span class="c">Definition breakdown_of_formulations_valid := AtomicClaim _breakdown_of_formulations_valid_.</span>
<span class="c">Definition successful_market_compliance_assessment := AtomicClaim _successful_market_compliance_assessment_.</span>
<span class="c">Definition compile := AtomicEvid _compile_.</span>
<span class="c">Definition review := AtomicEvid _review_.</span>
<span class="c">Definition assess := AtomicEvid _assess_.</span>
<span class="c">Definition business_procedure := AtomicEvid _business_procedure_.</span>
<span class="c">Definition ingredients_percentage_list := AtomicEvid _ingredients_percentage_list_.</span>
<span class="c">Definition breakdown_of_formulations_list := AtomicEvid _breakdown_of_formulations_list_.</span>

<span class="c">Definition preAssessmentRequirements : proofTreeOf_wrapped recipe_valid.</span>
<span class="c">Proof.</span>
<span class="c">eexists _ certifier.</span>
<span class="c">eapply (trust _ certifier applicant _ trustT).</span>
<span class="c">eapply (impl_elim _ _ _ breakdown_of_formulations_valid).</span>
<span class="c">eapply (trust _ applicant certifier  _ trustU).</span>
<span class="c">eapply (impl_elim _ _ _ ingredients_valid_approved).</span>
<span class="c">eapply (assume business_procedure).</span>
<span class="c">eapply (impl_elim _ _ _ successful_market_compliance_assessment).</span>
<span class="c">eapply (impl_elim _ _ _ (ingredients_valid)).</span>
<span class="c">eapply (assume review).</span>
<span class="c">eapply (trust _ certifier applicant _ trustT).</span>
<span class="c">eapply (impl_elim _ _ _ percentage_ingredients_valid).</span>
<span class="c">eapply (assume compile).</span>
<span class="c">eapply (assume ingredients_percentage_list). </span>
<span class="c">eapply (assume assess certifier).</span>
<span class="c">eapply (assume breakdown_of_formulations_list).</span>
<span class="c">Defined. *)</span></span></pre><pre class="alectryon-io highlight coq-math"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* Eval compute in showForProofTree preAssessmentRequirements. *)</span></span></pre><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* Eval compute in (showForNaturalLanguage preAssessmentRequirements). *)</span>
<span class="c">(* Eval compute in showForLogSeq preAssessmentRequirements. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkcd"><span class="kn">Definition</span> <span class="nf">problematicExample1</span> : proofTreeOf_wrapped a1 (Implies c1 c1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (Implies c1 c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkce"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf_wrapped a1 (Implies c1 c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkcf"><span class="nb">eexists</span> _ _ _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?Goal1</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> (Implies c1 c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd0"><span class="nb">eapply</span> (impl_intro e1 _ _ _ _ _f_ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf <span class="nl">?e2</span> \<span class="bp">by</span> a1 \<span class="kr">in</span> c1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd1"><span class="nb">eapply</span> or_elim2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (Right <span class="nl">?e2</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> (<span class="nl">?C1</span> \/&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="veracitylogic-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd2"><span class="kn">Fail</span> <span class="nb">eapply</span> or_intro1.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Unable to <span class="nb">unify</span>
 <span class="s2">&quot;proofTreeOf</span>
<span class="s2">    (Left ?M12350) \by ?M12351 \in</span>
<span class="s2">    (?M12352 \/&#39; ?M12353)&quot;</span>
<span class="kr">with</span>
 <span class="s2">&quot;proofTreeOf (Right ?e2) \by a1 \in (?C1 \/&#39; c1)&quot;</span>.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (Right <span class="nl">?e2</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> (<span class="nl">?C1</span> \/&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="veracitylogic-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="veracitylogic-v-chkd3"><span class="kn">Fail</span> <span class="nb">eapply</span> (assume e1 a1 c1).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Unable to <span class="nb">unify</span> <span class="s2">&quot;proofTreeOf e1 \by a1 \in c1&quot;</span> <span class="kr">with</span>
 <span class="s2">&quot;proofTreeOf (Right ?e2) \by a1 \in (?C1 \/&#39; c1)&quot;</span>.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">proofTreeOf (Right <span class="nl">?e2</span>) \<span class="bp">by</span> a1 \<span class="kr">in</span> (<span class="nl">?C1</span> \/&#39; c1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> string_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">allProofsAsString</span> := 
    showForProofTree concreteProofTreeExampleWith2Conjuncts
 ++ showForProofTree concreteProofTreeExampleWith3Conjuncts
 ++ showForProofTree concreteProofTreeExampleTrust
 ++ showForProofTree concreteProofTreeExampleWith3ConjunctsWithTrust
 ++ showForProofTree concreteProofTreeExampleWith3ConjunctsWithTrustAndExtras
 ++ showForProofTree exampleWithProofOf
 ++ showForProofTree usingAll
 <span class="c">(* ++ showForProofTree exampleFromJosh *)</span>
 <span class="c">(* ++ showForProofTree preAssessmentRequirements *)</span>
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">VeracityLogic</span>.</span></span></pre></div>
</div>
</div></body>
</html>
